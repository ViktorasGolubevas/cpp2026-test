# U4: Gilus Kopijavimas (Deep Copy)

**SavaitÄ—s:** 7-8  
**Svoris:** 1 balas  
**Terminas:** SavaitÄ—s 8 pabaiga

---

## ğŸ“š PrieÅ¡ pradedant

**Priminimas:** Taikomi tie patys reikalavimai kaip U1-U3.  
ğŸ‘‰ Å½r. **[UÅ¾duoÄiÅ³ Gidas](UzduotiuGidas.md)**

**SVARBU:** Å i uÅ¾duotis **tÄ™sia U3** (Kambarys/Langas/Durys). Jei nepadarÄ—te U3, pirmiausia uÅ¾baikite jÄ…!

---

## ğŸ¯ UÅ¾duoties tikslas

IÅ¡mokti **teisingai kopijuoti** objektus, kurie turi dinaminius resursus (rodykles). Suprasti **shallow copy** vs **deep copy** problemÄ…. Ä®gyvendinti **Rule of Three** (destruktorius, copy constructor, copy assignment operator).

---

## ğŸ“š Mokymosi tikslai

AtlikÄ™ Å¡iÄ… uÅ¾duotÄ¯, mokÄ—site:

- âœ… Suprasti shallow copy problemÄ… (dangling pointer)
- âœ… RaÅ¡yti **copy constructor** su deep copy
- âœ… RaÅ¡yti **copy assignment operator** (`operator=`)
- âœ… Taikyti **Rule of Three** principÄ…
- âœ… Testuoti kopijavimÄ… su pass-by-value
- âœ… Debug'inti memory problemas su logging

---

## ğŸ’¡ Kas yra Shallow vs Deep Copy?

### **Shallow Copy (Seklus kopijavimas):**

**Default behavior** - C++ kompiliatorius automatiÅ¡kai sukuria:
```cpp
Kambarys k2 = k1;  // Default copy constructor
```

**Problema:** Kopijuoja **tik rodyklÄ—s reikÅ¡mÄ™** (memory address), **ne objektÄ…**!

```
k1:  durys â†’ [Durys objektas @0x1234]
              â†‘
k2:  durys â”€â”€â”˜  (ta pati rodyklÄ—!)
```

**Rezultatas:**
- Abu objektai **dalijasi** tuo paÄiu `Durys` objektu
- Destruktorius bando `delete` **du kartus** â†’ **CRASH!** ğŸ’¥

---

### **Deep Copy (Gilus kopijavimas):**

**MÅ«sÅ³ sprendimas:** Kopijuoti **patÄ¯ objektÄ…**, ne tik rodyklÄ™!

```
k1:  durys â†’ [Durys objektas @0x1234]

k2:  durys â†’ [Durys objektas @0x5678]  (NAUJA kopija!)
```

**Rezultatas:**
- Kiekvienas objektas turi **savo** `Durys` kopijÄ…
- Destruktorius `delete` **skirtingus** objektus â†’ **SAFE!** âœ…

---

## ğŸ’¡ Rule of Three

Jei jÅ«sÅ³ klasÄ— turi **bent vienÄ…** iÅ¡ Å¡iÅ³:
1. Destruktorius
2. Copy constructor
3. Copy assignment operator

...tai **privalote turÄ—ti visus tris**!

**KodÄ—l?**
- Destruktorius â†’ klasÄ— valdo resursus
- Valdo resursus â†’ reikia deep copy
- Reikia deep copy â†’ reikia copy constructor **IR** copy assignment

**Kambarys klasei:**
1. âœ… `~Kambarys()` - destruktorius (turÄ—jome U3)
2. âœ… `Kambarys(const Kambarys&)` - copy constructor (pridÄ—sime U4)
3. âœ… `Kambarys& operator=(const Kambarys&)` - copy assignment (pridÄ—sime U4)

---

## ğŸ“‹ UÅ¾duoties Å¾ingsniai

### **1 Å¾ingsnis: Shallow copy problema (demo)**

**Direktorija:** `U4/01/`

**Reikalavimai:**

1. **Kopijuokite U3/03/ kodÄ…** Ä¯ `U4/01/`
   - Visos klasÄ—s: `Langas`, `Durys`, `Kambarys`
   - Visi failai: `.h`, `.cpp`, `skaiciavimai.*`, `main.cpp`, `Makefile`

2. **Sukurkite globaliÄ… funkcijÄ…** `skaiciavimai.h`/`.cpp`:
   ```cpp
   void testuotiKopija(Kambarys k);  // Pass-by-VALUE (kopija!)
   ```
   
   Funkcijos turinys:
   ```cpp
   void testuotiKopija(Kambarys k) {
       cout << "Funkcijoje: sienu plotas = " 
            << apskaiciuotiSienuPlota(k) << endl;
   }
   ```

3. **Main funkcijoje - demonstruoti problemÄ…:**
   ```cpp
   // Sukurti kambarÄ¯ su langais ir durimis
   Kambarys* k1 = new Kambarys(5.0, 4.0, 3.0);
   // ... pridÄ—ti langus, duris ...
   
   // TESTAS 1: Pirmas kvietimas (veiks)
   cout << "Pirmas kvietimas:" << endl;
   testuotiKopija(*k1);
   
   // TESTAS 2: Antras kvietimas (CRASH arba blogas rezultatas!)
   cout << "Antras kvietimas:" << endl;
   testuotiKopija(*k1);  // â† PROBLEMA Äia!
   
   delete k1;
   ```

**Rezultatas:**
- **1-as kvietimas:** Veikia OK
- **2-as kvietimas:** CRASH arba neteisingi rezultatai
- **KodÄ—l?** Shallow copy â†’ dangling pointer!

**Pavyzdys (galimas iÅ¡vesties fragmentas):**
```
Pirmas kvietimas:
Funkcijoje: sienu plotas = 49.20 mÂ²
[DEBUG] Kambarys naikinamas
[DEBUG] Kambarys naikina savo duris
[DEBUG] Durys sunaikintos. Liko duriu: 0  â† delete durys!

Antras kvietimas:
[CRASH] Segmentation fault  â† durys jau delete'intos!
```

**UÅ¾duotis studentui:**
- âœ… Paleisti programÄ…
- âœ… Pamatyti CRASH arba blogus rezultatus
- âœ… Suprasti problemÄ… (shallow copy)
- âœ… README.md - apraÅ¡yti, kas nutiko

---

### **2 Å¾ingsnis: Copy constructor**

**Direktorija:** `U4/02/`

**Reikalavimai:**

1. **PridÄ—ti copy constructor** Ä¯ `Kambarys.h`:
   ```cpp
   // Copy constructor
   Kambarys(const Kambarys& kitas);
   ```

2. **Implementuoti copy constructor** `Kambarys.cpp`:
   ```cpp
   Kambarys::Kambarys(const Kambarys& kitas) 
       : ilgis(kitas.ilgis), 
         plotis(kitas.plotis), 
         aukstis(kitas.aukstis) {
       
       cout << "[DEBUG] Kambarys kopijuojamas (copy constructor)" << endl;
       
       // 1. Kopijuoti langus (vector daro deep copy automatiÅ¡kai!)
       langai = kitas.langai;
       
       // 2. Kopijuoti duris (DEEP COPY - naujas objektas!)
       if (kitas.durys != nullptr) {
           durys = new Durys(*kitas.durys);  // Sukurti NAUJÄ„ Durys objektÄ…
       } else {
           durys = nullptr;
       }
   }
   ```

3. **Testuoti su ta paÄia `testuotiKopija()` funkcija:**
   ```cpp
   // Dabar turÄ—tÅ³ veikti!
   cout << "Pirmas kvietimas:" << endl;
   testuotiKopija(*k1);
   
   cout << "Antras kvietimas:" << endl;
   testuotiKopija(*k1);  // â† Dabar OK!
   ```

**Rezultatas:**
- âœ… Abu kvietimai veikia!
- âœ… Logging rodo copy constructor kvietimus
- âœ… Kiekvienas `Kambarys` turi **savo** durÅ³ kopijÄ…

**Pavyzdys (iÅ¡vestis):**
```
Pirmas kvietimas:
[DEBUG] Kambarys kopijuojamas (copy constructor)
[DEBUG] Durys sukurtos (2Ã—0.9). Viso duriu: 2  â† Nauja kopija!
Funkcijoje: sienu plotas = 49.20 mÂ²
[DEBUG] Kambarys naikinamas
[DEBUG] Kambarys naikina savo duris
[DEBUG] Durys sunaikintos. Liko duriu: 1

Antras kvietimas:
[DEBUG] Kambarys kopijuojamas (copy constructor)
[DEBUG] Durys sukurtos (2Ã—0.9). Viso duriu: 2  â† Dar viena kopija!
Funkcijoje: sienu plotas = 49.20 mÂ²
[DEBUG] Kambarys naikinamos
[DEBUG] Kambarys naikina savo duris
[DEBUG] Durys sunaikintos. Liko duriu: 1
```

---

### **3 Å¾ingsnis: Copy assignment operator (Rule of Three)**

**Direktorija:** `U4/03/`

**Reikalavimai:**

1. **PridÄ—ti copy assignment operator** Ä¯ `Kambarys.h`:
   ```cpp
   // Copy assignment operator
   Kambarys& operator=(const Kambarys& kitas);
   ```

2. **Implementuoti operator=** `Kambarys.cpp`:
   ```cpp
   Kambarys& Kambarys::operator=(const Kambarys& kitas) {
       cout << "[DEBUG] Kambarys kopijuojamas (operator=)" << endl;
       
       // 1. Patikrinti self-assignment
       if (this == &kitas) {
           cout << "[DEBUG] Self-assignment aptiktas, praleidziama" << endl;
           return *this;
       }
       
       // 2. Atlaisvinti senus resursus
       if (durys != nullptr) {
           cout << "[DEBUG] Atlaisvinamos senos durys" << endl;
           delete durys;
           durys = nullptr;
       }
       langai.clear();  // IÅ¡valyti langÅ³ vektoriÅ³
       
       // 3. Kopijuoti naujus duomenis
       ilgis = kitas.ilgis;
       plotis = kitas.plotis;
       aukstis = kitas.aukstis;
       
       langai = kitas.langai;  // Vector deep copy
       
       if (kitas.durys != nullptr) {
           durys = new Durys(*kitas.durys);  // Deep copy
       } else {
           durys = nullptr;
       }
       
       return *this;
   }
   ```

3. **Testuoti su assignment:**
   ```cpp
   Kambarys k1(5.0, 4.0, 3.0);
   // ... pridÄ—ti langus, duris ...
   
   Kambarys k2(3.0, 3.0, 2.5);
   
   // Assignment
   cout << "--- Priskyrimas: k2 = k1 ---" << endl;
   k2 = k1;
   
   // Testuoti k2
   cout << "k2 sienu plotas: " << apskaiciuotiSienuPlota(k2) << endl;
   
   // Self-assignment testas
   cout << "--- Self-assignment: k2 = k2 ---" << endl;
   k2 = k2;  // TurÄ—tÅ³ aptikti ir praleisti
   ```

4. **Ekstremalus testas:**
   ```cpp
   Kambarys k1(5.0, 4.0, 3.0);
   // ... setup ...
   
   Kambarys k2(3.0, 3.0, 2.5);
   k2 = k1;
   
   // Delete k1, bet k2 turÄ—tÅ³ veikti!
   delete &k1;  // (jei dynamic)
   
   cout << "Po k1 delete, k2 sienu plotas: " 
        << apskaiciuotiSienuPlota(k2) << endl;  // â† TurÄ—tÅ³ veikti!
   ```

**Rezultatas:**
- âœ… Copy assignment veikia
- âœ… Self-assignment aptiktas
- âœ… k2 veikia net po k1 sunaikinimo (deep copy!)

---

## ğŸ“¦ Pateikimas

### **GitLab direktorijÅ³ struktÅ«ra:**

```
cpp-2026/
â”œâ”€â”€ README.md
â”œâ”€â”€ .gitignore
â”œâ”€â”€ U1/, U2/, U3/
â””â”€â”€ U4/
    â”œâ”€â”€ README.md          â† UÅ¾duoties santrauka (PRIVALOMA)
    â”œâ”€â”€ 01/                â† Shallow copy problema
    â”‚   â”œâ”€â”€ Langas.h, Langas.cpp
    â”‚   â”œâ”€â”€ Durys.h, Durys.cpp
    â”‚   â”œâ”€â”€ Kambarys.h, Kambarys.cpp
    â”‚   â”œâ”€â”€ skaiciavimai.h, skaiciavimai.cpp
    â”‚   â”œâ”€â”€ main.cpp
    â”‚   â””â”€â”€ Makefile
    â”œâ”€â”€ 02/                â† Copy constructor
    â”‚   â”œâ”€â”€ [visi failai kaip 01/]
    â”‚   â””â”€â”€ Kambarys.cpp (modifikuotas)
    â””â”€â”€ 03/                â† Copy assignment (Rule of Three) - FINAL
        â”œâ”€â”€ [visi failai]
        â””â”€â”€ Kambarys.cpp (modifikuotas)
```

### **Git workflow:**

```bash
git add U4/01/
git commit -m "U4: 1 Å¾ingsnis - Shallow copy problema (demo)"
git push

git add U4/02/
git commit -m "U4: 2 Å¾ingsnis - Copy constructor (deep copy)"
git push

git add U4/03/
git commit -m "U4: 3 Å¾ingsnis - Copy assignment operator (Rule of Three)"
git push
```

### **U4/README.md Å¡ablonas:**

```markdown
# U4: Gilus Kopijavimas (Deep Copy)

**BÅ«sena**: âœ… Atlikta  
**Pateikta**: 2026-03-28

---

## ğŸ“ Å½ingsniai

| Å½ingsnis | Direktorija | ApraÅ¡ymas |
|----------|-------------|-----------|
| 1 | `01/` | Shallow copy problema (crash demo) |
| 2 | `02/` | Copy constructor (deep copy) |
| 3 | `03/` | Copy assignment operator (Rule of Three) |

---

## ğŸ§ª Testavimas

**Testas 1 (shallow copy - 01/)**:
```
Pirmas kvietimas: âœ… VEIKIA
Antras kvietimas: âŒ CRASH (dangling pointer)
```

**Testas 2 (copy constructor - 02/)**:
```
Pirmas kvietimas: âœ… VEIKIA
Antras kvietimas: âœ… VEIKIA (deep copy!)
```

**Testas 3 (copy assignment - 03/)**:
```
k2 = k1
Po k1 delete: k2 vis dar veikia âœ…
```

---

## ğŸ’­ PagrindinÄ—s Ä¯Å¾valgos

1. Shallow copy â†’ dangling pointer â†’ crash
2. Deep copy â†’ naujas objektas â†’ safe
3. Rule of Three: destruktorius + copy constructor + operator=
4. Self-assignment check svarbus!
```

### **Moodle pateikimas:**

```bash
cd cpp-2026
git archive --format=zip --output=U4_VardasPavarde.zip HEAD U4/ README.md .gitignore
```

---

## âœ… Vertinimo kriterijai

| Kriterijus | Balai |
|------------|-------|
| Programa kompiliuojasi be klaidÅ³ | 15% |
| Shallow copy problema pademonstruota | 15% |
| Copy constructor implementuotas | 25% |
| Copy assignment operator implementuotas | 25% |
| Self-assignment check | 10% |
| Testai veikia (pass-by-value, assignment) | 5% |
| README.md su problemÅ³ apraÅ¡ymu | 5% |
| **TOTAL** | **100%** |

---

## ğŸ’¡ Patarimai

1. **Shallow copy testas** - paleiskite 01/ ir pamatykite crash!
2. **Logging** - padeda suprasti, kada copy constructor kvieÄiamas
3. **Self-assignment** - `if (this == &kitas)` - BÅªTINA patikra!
4. **Delete before copy** - operator= turi atlaisvinti senus resursus
5. **Return *this** - operator= turi grÄ…Å¾inti nuorodÄ… (chaining: `a=b=c`)
6. **Vector deep copy** - automatinis! (nereikia raÅ¡yti rankiniu bÅ«du)

---

## ğŸ”— Naudingos nuorodos

- [Rule of Three](https://en.cppreference.com/w/cpp/language/rule_of_three)
- [Copy constructor](https://en.cppreference.com/w/cpp/language/copy_constructor)
- [Copy assignment](https://en.cppreference.com/w/cpp/language/copy_assignment)

---

## â“ DaÅ¾nai uÅ¾duodami klausimai

**K: KodÄ—l reikia `if (this == &kitas)` operator= ?**  
A: Self-assignment (`k = k`) be Å¡ios patikros gali sunaikinti objektÄ… prieÅ¡ kopijuojant!

**K: KodÄ—l `return *this` operator= ?**  
A: Kad veiktÅ³ chaining: `a = b = c` (deÅ¡inÄ— Ä¯ kairÄ™).

**K: Ar vector automatiÅ¡kai daro deep copy?**  
A: **Taip!** `langai = kitas.langai` - vector kopijuoja visus elementus.

**K: KodÄ—l `new Durys(*kitas.durys)`?**  
A: `*kitas.durys` - dereferencing (gauti objektÄ…), tada Durys copy constructor.

**K: Ar reikia `langai.clear()` operator= ?**  
A: Ne (assignment perkraus), bet gera praktika (explicit cleanup).

**Daugiau klausimÅ³?** â†’ Å½r. [UÅ¾duoÄiÅ³ Gidas - DUK](UzduotiuGidas.md#duk)

---

**SÄ—kmÄ—s!** ğŸš€
