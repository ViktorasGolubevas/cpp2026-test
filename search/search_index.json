{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Prad\u017eia","text":"<p>Naujienos (Atnaujinta: 2026-02-04)</p> <ul> <li>\u012ekelta x-ios paskaitos med\u017eiaga apie Rodykles.</li> <li>Pratyb\u0173 u\u017eduotis Nr. 1 jau pasiekiama Moodle.</li> </ul>"},{"location":"#programavimas-c-1-kursas","title":"Programavimas C++ (1 kursas)","text":"<p>Sveiki atvyk\u0119 \u012f objektinio programavimo C++ kalba kurs\u0105. \u0160ioje svetain\u0117je rasite vis\u0105 paskait\u0173 konspekt\u0105, kodo pavyzd\u017eius ir pratyb\u0173 u\u017eduotis.</p> <p>Organizacin\u0117 informacija</p> <ul> <li>Paskaitos: Pirmadieniais 10:00 (101 aud.)</li> <li>Pratybos: Tre\u010diadieniais 14:00 (202 aud. / Teams)</li> <li>Egzaminas: 2026-01-XX</li> <li>Moodle: Nuoroda \u012f kurs\u0105</li> </ul>"},{"location":"#naudingi-irankiai","title":"\ud83d\udee0\ufe0f Naudingi \u012frankiai","text":"<p>\u0160iuos \u012frankius naudosime viso kurso metu. Rekomenduoju i\u0161sisaugoti.</p> <p>Compiler Explorer (Godbolt){ .md-button .md-button--primary } C++ Reference{ .md-button } C++ Insights{ .md-button } Python Tutor (Vizualizacija){ .md-button }</p>"},{"location":"#vertinimo-sistema","title":"\ud83d\udcca Vertinimo sistema","text":"<p>Galutinis pa\u017eymys susideda i\u0161 kaupiamojo balo:</p> Dalis Svoris Apra\u0161ymas Laboratoriniai darbai 40% 3 gynimai semestro metu Kontrolinis (Kolokviumas) 20% Teorija ir praktin\u0117s u\u017eduotys (C dalis) Egzaminas 40% Objektinis programavimas ir STL <p>Svarbu</p> <p>Norint b\u016bti prileistam prie egzamino, privaloma atsiskaityti visus laboratorinius darbus.</p>"},{"location":"#kurso-struktura","title":"\ud83d\uddfa\ufe0f Kurso strukt\u016bra","text":"<p>Kursas suskirstytas \u012f tris loginius etapus. Detal\u0173 turin\u012f matote kair\u0117je meniu juostoje.</p>"},{"location":"#1-nuo-c-link-c-procedurinis-pagrindas","title":"1. Nuo C link C++ (Proced\u016brinis pagrindas)","text":"<p>Prisiminsime C kalb\u0105, rodykles (pointers), atminties valdym\u0105 ir pereisime prie C++ sintaks\u0117s pagerinim\u0173 (references, overload, namespace).</p>"},{"location":"#2-objektinis-programavimas-oop","title":"2. Objektinis Programavimas (OOP)","text":"<p>Pagrindin\u0117 kurso dalis. Klas\u0117s, inkapsuliacija, <code>Stack</code> evoliucija, konstruktoriai/destruktoriai, Rule of Three/Five, paveld\u0117jimas ir polimorfizmas.</p>"},{"location":"#3-stl-ir-modern-c","title":"3. STL ir Modern C++","text":"<p>Susipa\u017einsime su standartine biblioteka (<code>std::vector</code>, <code>std::map</code>), algoritmais ir i\u0161maniosiomis rodykl\u0117mis (<code>smart pointers</code>).</p> <p>Kaip naudotis \u0161ia med\u017eiaga</p> <ul> <li>Kodo pavyzd\u017eiuose naudokite vir\u0161uje esan\u010dius Skirtukus (Tabs), kad palygintum\u0117te sprendimus.</li> <li>Matydami ikon\u0105 \ud83d\ude80, spauskite j\u0105, kad atidarytum\u0117te kod\u0105 nar\u0161ykl\u0117je.</li> </ul>"},{"location":"design/","title":"Dizainas","text":""},{"location":"design/#stack-realizacijos-palyginimas","title":"Stack realizacijos palyginimas","text":"1 Etapas: C stilius6 Etapas: C++ Klas\u011710 Etapas: Modern C++ <pre><code>// Global\u016bs kintamieji\nchar stack[10];\nint top = 0;\n\nvoid push(char c) {\n    stack[top++] = c;\n}\n</code></pre> <pre><code>class Stack {\nprivate:\n    char stack[10];\n    int top;\npublic:\n    void push(char c) {\n        stack[top++] = c;\n    }\n};\n</code></pre> <pre><code>#include &lt;vector&gt;\n\ntemplate&lt;typename T&gt;\nclass Stack {\n    std::vector&lt;T&gt; data;\npublic:\n    void push(T item) {\n        data.push_back(item);\n    }\n};\n</code></pre>"},{"location":"design/#rodykliu-masyvo-struktura","title":"Rodykli\u0173 masyvo strukt\u016bra","text":"<pre><code>graph TD\n    M[Main Funkcija] --&gt;|Kuria| Arr[Rodykli\u0173 Masyvas]\n    Arr -- [0] --&gt; S1(Student Objektas)\n    Arr -- [1] --&gt; S2(Student Objektas)\n    Arr -- [2] --&gt; GS(GraduateStudent Objektas)\n\n    style GS fill:#f9f,stroke:#333,stroke-width:2px</code></pre>"},{"location":"design/#admonitions-perspejimai","title":"Admonitions (Persp\u0117jimai)","text":"<p>Da\u017ena klaida: Object Slicing</p> <p>Jei priskirsite <code>GraduateStudent</code> objekt\u0105 \u012f <code>Student</code> kintam\u0105j\u012f (ne rodykl\u0119), papildomi duomenys bus nupjauti!</p> <pre><code>    Student s = GraduateStudent(\"Jonas\"); // Blogai!\n</code></pre> <p>Patarimas</p> <p>Visada naudokite <code>std::vector</code> vietoj <code>new[]</code> masyv\u0173, nebent turite labai specifin\u0119 prie\u017east\u012f.</p> <p>Pastaba</p> <p>note, kad jums ir tada reikia naudoti <code>new[]</code> masyv\u0173.</p> <p>Informacija</p> <p>info, kad jums ir tada reikia naudoti <code>new[]</code> masyv\u0173.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#i-oji-dalis-nuo-monolito-iki-pilno-adt-c-kalboje","title":"I-oji dalis: Nuo Monolito iki Pilno ADT C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l Stack? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - suvokiame per reik\u0161mi\u0173 aib\u0119: - <code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ... - <code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ... - <code>float</code> \u2192 3.14, -2.71, ...</p> <p>ADT - suvokiame per operacijas, o ne per reik\u0161mes: - <code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code> - Mums ner\u016bpi kaip stekas atmintyje atrodo - Mums svarbu tik k\u0105 galime su juo daryti!</p> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>Kelion\u0117s \u017eem\u0117lapis</p> <p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code> linkage)</p> <p>05-06: User-Defined Type (struct + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnas ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> <li>Pamatysime kod\u0117l reikia evoliucijos</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - stack.c ir user.c</li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bkstamos deklaracijos</li> <li>Susidursime su linkavimo klaidomis - multiple definition</li> <li>I\u0161moksime kad <code>#include \"file.c\"</code> yra antipattern</li> <li>Pamatysime skirtumus tarp gcc ir clang elgesio!</li> </ul> <p>\ud83d\udcda Terminologija: Apra\u0161as vs Apibr\u0117\u017eimas</p> <p>C kalboje kriti\u0161kai svarbu skirti du dalykus:</p> <p>Apra\u0161as (Declaration) - \"sakome kompiliatoriui\" kad ka\u017ekas egzistuoja:</p> <ul> <li><code>int add(int a, int b);</code> \u2190 funkcijos prototipas (tai ir yra apra\u0161as!)</li> <li><code>extern int counter;</code> \u2190 kintamojo apra\u0161as</li> <li>Kompiliatorius \u017eino vard\u0105 ir tip\u0105, bet ne kaip veikia ar kur saugoma</li> <li>Gali b\u016bti daug apra\u0161\u0173 (\u012fvairiuose failuose)</li> </ul> <p>Apibr\u0117\u017eimas (Definition) - \"pasakome kompiliatoriui\" K\u0104 daryti ir KUR saugoti:</p> <ul> <li><code>int add(int a, int b) { return a + b; }</code> \u2190 funkcijos apibr\u0117\u017eimas</li> <li><code>int counter = 0;</code> \u2190 kintamojo apibr\u0117\u017eimas  </li> <li>Kompiliatorius \u017eino visk\u0105 - sugeneruoja kod\u0105/alokuoja atmint\u012f</li> <li>Gali b\u016bti tik VIENAS apibr\u0117\u017eimas (vienoje vietoje)</li> </ul> <p>Aukso taisykl\u0117: </p> <ul> <li>Apra\u0161\u0173 (declarations) \u2192 daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) \u2192 tik vienas \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c/\u26a0\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> \u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror <p><pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\n</code></pre> <pre><code>user.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> \u26a0\ufe0f gcc leid\u017eia su persp\u0117jimais (implicit declaration)</p> <p><pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\n</code></pre> <pre><code>user.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre> \u274c clang grie\u017etesnis - i\u0161kart klaidos!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nesikompiliuoja-clang-perspejimai-gcc","title":"\u274c Nesikompiliuoja (clang) / \u26a0\ufe0f Persp\u0117jimai (gcc)","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bkstamos funkcij\u0173 deklaracijos (apra\u0161ai) <p>Problema: Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, kok\u012f veiksm\u0105 jis atstovauja.</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Kokio tipo? Ne\u017einau!\npush(c);    // \u274c Kas yra push? Kokio tipo? Ne\u017einau!\n</code></pre></p> <p>Skirtumas gcc vs clang:</p> <ul> <li>gcc (traditional): Leid\u017eia su warning - \"sp\u0117ja\" <code>int funkcija()</code> (implicit declaration)</li> <li>clang (strict): I\u0161kart error - ISO C99+ draud\u017eia implicit declarations</li> <li>Gali veikti su gcc, bet dangerous - sp\u0117jimas gali b\u016bti neteisingas!</li> </ul> <p>Monolitas vs atskiri failai:</p> <ul> <li>Monolite: Kompiliatorius mato vis\u0105 fail\u0105 - funkcij\u0173 apibr\u0117\u017eimai ten pat</li> <li>Failuose: Kiekvienas <code>.c</code> atskiras kompiliavimo vienetas - reikia funkcij\u0173 apra\u0161\u0173 (prototip\u0173/deklaracij\u0173)</li> </ul> <p>Sprendimas: Prid\u0117ti funkcij\u0173 prototipus (apra\u0161us) <code>user.c</code> prad\u017eioje arba...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai (multiple definitions) <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia vis\u0105 turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (funkcijos ir kintamieji) po kompiliavimo yra abiejuose <code>.o</code> failuose!</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor'iaus:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u012fterpiamas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n</code></pre></p> <p>Linkerio problema:</p> <ul> <li>Linkeris turi sulinkinti vard\u0173 kreipinius su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du - vienas <code>stack.o</code>, kitas <code>user.o</code>!</li> <li>Kur\u012f pasirinkti? Pagal kok\u012f kriterij\u0173?</li> <li>Jei abu skirtingi - kuris teisingas?</li> </ul> <p>Linkeris deleguoja sprendim\u0105: Grie\u017etai informuoja apie \"multiple definition\" - autorius privalo pataisyti!</p> <p>Prisiminkite terminologij\u0105:</p> <ul> <li>Apra\u0161\u0173 (declarations) gali b\u016bti daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) gali b\u016bti tik VIENAS \u2705</li> </ul> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams (su apra\u0161ais), ne <code>.c</code> (su apibr\u0117\u017eimais)!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito - viskas v\u0117l viename kompiliavimo vienete</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 C konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105 kai kompiliuojam <code>user.c</code></li> <li>Priklausomyb\u0117s - pakeitus <code>stack.c</code> reikia perkompiliuoti <code>user.c</code></li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>) su apra\u0161ais (prototipais)!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Apra\u0161ai vs Apibr\u0117\u017eimai - Kod\u0117l svarbu?</p> <p>K\u0105 i\u0161mokome:</p> <ul> <li>Apra\u0161ai (declarations): Funkcij\u0173 prototipai - \"sakome kad egzistuoja\"</li> <li>Apibr\u0117\u017eimai (definitions): Funkcij\u0173 realizacijos - \"sakome kaip veikia\"</li> <li>Apra\u0161\u0173 gali b\u016bti daug (\u012fvairiuose failuose) \u2705</li> <li>Apibr\u0117\u017eim\u0173 gali b\u016bti tik vienas \u2705</li> </ul> <p>Kompiliavimo vs linkavimo klaidos:</p> <ul> <li>Kompiliavimo: Tr\u016bksta apra\u0161\u0173 - implicit declaration</li> <li>Linkavimo: Daug apibr\u0117\u017eim\u0173 - multiple definition</li> </ul> <p>gcc vs clang skirtumai:</p> <ul> <li>gcc: Laisvesnis - leid\u017eia implicit declarations su warning</li> <li>clang: Grie\u017etesnis - error pagal ISO C99+</li> </ul> <p>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais (apra\u0161ais)!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-07-hiding-udt-information","title":"Etapas 07: HIDING UDT Information","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#opaque-pointer-forward-declaration","title":"Opaque pointer - forward declaration","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-1-incomplete-type-01_nc","title":"\u017dingsnis 1: Incomplete type (01_NC)","text":"stack.h 07_HIDING_UDT_Information/01_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack st;  // \u274c Incomplete type\n</code></pre> Kompiliatorius ne\u017eino sizeof(Stack)</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-2-bandymas-su-malloc-02_nc","title":"\u017dingsnis 2: Bandymas su malloc (02_NC)","text":"stack.h 07_HIDING_UDT_Information/02_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Linkavimo klaida <p>Grei\u010diausiai problema su funkcij\u0173 deklaracijomis</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#zingsnis-3-neininicializuotos-rodykles-03_rt","title":"\u017dingsnis 3: Neininicializuotos rodykl\u0117s (03_RT)","text":"stack.huser.c 07_HIDING_UDT_Information/03_RT/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 07_HIDING_UDT_Information/03_RT/user.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> Segmentation fault <p><pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos!\ninit(pst1);  // \ud83d\udca5 Crash\n</code></pre> Sprendimas \u2192 Etapas 08: Factory pattern</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-08-acquiring-resources","title":"Etapas 08: Acquiring RESOURCES","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#factory-pattern-create-destroy","title":"Factory pattern - create() / destroy()","text":"stack.hstack.cuser.c 08_Acquiring_RESOURCES/02_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 08_Acquiring_RESOURCES/02_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 08_Acquiring_RESOURCES/02_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> Factory pattern veikia! <pre><code>struct Stack *pst1 = create();\n// ... naudojimas ...\ndestroy(pst1);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#etapas-09-completing-lifecycle","title":"Etapas 09: Completing LIFECYCLE","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pilnas-lifecycle-valdymas","title":"Pilnas lifecycle valdymas","text":"stack.hstack.cuser.c 09_Completing_LIFECYCLE/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 09_Completing_LIFECYCLE/01_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 09_Completing_LIFECYCLE/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> Pilnas C ADT! <ul> <li>\u2705 Information hiding (opaque pointer)</li> <li>\u2705 Lifecycle management (create/destroy)</li> <li>\u2705 Multiple instances</li> <li>\u2705 Factory pattern</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai \u017dingsni\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#suolis-i-c","title":"\u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\ndestroy(s);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius\ns.push('a');          // Metodas\n// Destruktorius automati\u0161kai\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#evoliucijos-santrauka_1","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#9-etapu-kelias_1","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#suolis-i-c_1","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#c-adt-etapas-09_1","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_COMPLETE_FINAL/#c-class_1","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#i-oji-dalis-nuo-monolito-iki-pilno-adt-c-kalboje","title":"I-oji dalis: Nuo Monolito iki Pilno ADT C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l Stack? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - suvokiame per reik\u0161mi\u0173 aib\u0119: - <code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ... - <code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ... - <code>float</code> \u2192 3.14, -2.71, ...</p> <p>ADT - suvokiame per operacijas, o ne per reik\u0161mes: - <code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code> - Mums ner\u016bpi kaip stekas atmintyje atrodo - Mums svarbu tik k\u0105 galime su juo daryti!</p> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>Kelion\u0117s \u017eem\u0117lapis</p> <p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code> linkage)</p> <p>05-06: User-Defined Type (struct + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnas ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> <li>Pamatysime kod\u0117l reikia evoliucijos</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - stack.c ir user.c</li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bkstamos deklaracijos</li> <li>Susidursime su linkavimo klaidomis - multiple definition</li> <li>I\u0161moksime kad <code>#include \"file.c\"</code> yra antipattern</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:5:5: warning: implicit declaration of function 'init'\nuser.c:6:5: warning: implicit declaration of function 'push'\nuser.c:11:15: warning: implicit declaration of function 'pop'\n</code></pre> \u26a0\ufe0f implicit declaration warnings</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#kompiliuojasi-su-perspejimais","title":"\u26a0\ufe0f Kompiliuojasi su persp\u0117jimais","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bkstamos funkcij\u0173 deklaracijos <p>Problema: Kompiliatorius ne\u017eino <code>init()</code>, <code>push()</code>, <code>pop()</code> funkcij\u0173!</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Ne\u017einau!\npush(...);  // \u274c Kas yra push? Ne\u017einau!\n</code></pre></p> <ul> <li>Kompiliatorius neturi funkcij\u0173 deklaracij\u0173 (prototip\u0173)</li> <li>Implicit declaration - kompiliatorius \"sp\u0117ja\" <code>int funkcija()</code></li> <li>Gali veikti bet tik atsitiktinai - dangerous!</li> </ul> <p>Sprendimas: Prid\u0117ti funkcij\u0173 prototipus <code>user.c</code> prad\u017eioje arba...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-include-stackc","title":"2 sprendimas: <code>#include \"stack.c\"</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Prid\u0117siu <code>#include \"stack.c\"</code> - taip user.c \"pamatys\" visas funkcijas!</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (kintamieji ir funkcijos) po kompiliavimo yra abiejuose <code>.o</code> failuose.</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top\n</code></pre></p> <ul> <li>Linkeris turi sulinkinti <code>.o</code> failuose esan\u010dius kreipinius \u012f vardus su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du per abu failus!</li> <li>Linkeris ne\u017eino kur\u012f pasirinkti \u2192 klaida \"multiple definition\"</li> </ul> <p>Kod\u0117l negalima automati\u0161kai pasirinkti? Jei du skirtingi apibr\u0117\u017eimai - kuris teisingas? Linkeris \u0161\u012f sprendim\u0105 deleguoja autoriui.</p> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams, ne <code>.c</code>!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito ir jo ribotumo/netinkamumo</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105</li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>)!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Veikiantis Kodas \u2260 Geras Kodas</p> <ul> <li>Kompiliavimo klaidos moko funkcij\u0173 deklaracij\u0173</li> <li>Linkavimo klaidos moko multiple definition problemos</li> <li><code>#include \"file.c\"</code> - antipattern, nors ir veikia</li> <li>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-07-hiding-udt-information","title":"Etapas 07: HIDING UDT Information","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#opaque-pointer-forward-declaration","title":"Opaque pointer - forward declaration","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-1-incomplete-type-01_nc","title":"\u017dingsnis 1: Incomplete type (01_NC)","text":"stack.h 07_HIDING_UDT_Information/01_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack st;  // \u274c Incomplete type\n</code></pre> Kompiliatorius ne\u017eino sizeof(Stack)</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-2-bandymas-su-malloc-02_nc","title":"\u017dingsnis 2: Bandymas su malloc (02_NC)","text":"stack.h 07_HIDING_UDT_Information/02_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Linkavimo klaida <p>Grei\u010diausiai problema su funkcij\u0173 deklaracijomis</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#zingsnis-3-neininicializuotos-rodykles-03_rt","title":"\u017dingsnis 3: Neininicializuotos rodykl\u0117s (03_RT)","text":"stack.huser.c 07_HIDING_UDT_Information/03_RT/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 07_HIDING_UDT_Information/03_RT/user.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> Segmentation fault <p><pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos!\ninit(pst1);  // \ud83d\udca5 Crash\n</code></pre> Sprendimas \u2192 Etapas 08: Factory pattern</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-08-acquiring-resources","title":"Etapas 08: Acquiring RESOURCES","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#factory-pattern-create-destroy","title":"Factory pattern - create() / destroy()","text":"stack.hstack.cuser.c 08_Acquiring_RESOURCES/02_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 08_Acquiring_RESOURCES/02_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 08_Acquiring_RESOURCES/02_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> Factory pattern veikia! <pre><code>struct Stack *pst1 = create();\n// ... naudojimas ...\ndestroy(pst1);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#etapas-09-completing-lifecycle","title":"Etapas 09: Completing LIFECYCLE","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pilnas-lifecycle-valdymas","title":"Pilnas lifecycle valdymas","text":"stack.hstack.cuser.c 09_Completing_LIFECYCLE/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 09_Completing_LIFECYCLE/01_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 09_Completing_LIFECYCLE/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> Pilnas C ADT! <ul> <li>\u2705 Information hiding (opaque pointer)</li> <li>\u2705 Lifecycle management (create/destroy)</li> <li>\u2705 Multiple instances</li> <li>\u2705 Factory pattern</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai \u017dingsni\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#suolis-i-c","title":"\u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\ndestroy(s);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius\ns.push('a');          // Metodas\n// Destruktorius automati\u0161kai\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#evoliucijos-santrauka_1","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#9-etapu-kelias_1","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#suolis-i-c_1","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#c-adt-etapas-09_1","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_SU_PREAMBULE/#c-class_1","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#i-oji-dalis-nuo-monolito-iki-pilno-adt-c-kalboje","title":"I-oji dalis: Nuo Monolito iki Pilno ADT C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l Stack? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - suvokiame per reik\u0161mi\u0173 aib\u0119: - <code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ... - <code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ... - <code>float</code> \u2192 3.14, -2.71, ...</p> <p>ADT - suvokiame per operacijas, o ne per reik\u0161mes: - <code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code> - Mums ner\u016bpi kaip stekas atmintyje atrodo - Mums svarbu tik k\u0105 galime su juo daryti!</p> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>Kelion\u0117s \u017eem\u0117lapis</p> <p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code> linkage)</p> <p>05-06: User-Defined Type (struct + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnas ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> <li>Pamatysime kod\u0117l reikia evoliucijos</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - stack.c ir user.c</li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bkstamos deklaracijos</li> <li>Susidursime su linkavimo klaidomis - multiple definition</li> <li>I\u0161moksime kad <code>#include \"file.c\"</code> yra antipattern</li> <li>Pamatysime skirtumus tarp gcc ir clang elgesio!</li> </ul> <p>\ud83d\udcda Terminologija: Apra\u0161as vs Apibr\u0117\u017eimas</p> <p>C kalboje kriti\u0161kai svarbu skirti du dalykus:</p> <p>Apra\u0161as (Declaration) - \"sakome kompiliatoriui\" kad ka\u017ekas egzistuoja:</p> <ul> <li><code>int add(int a, int b);</code> \u2190 funkcijos prototipas (tai ir yra apra\u0161as!)</li> <li><code>extern int counter;</code> \u2190 kintamojo apra\u0161as</li> <li>Kompiliatorius \u017eino vard\u0105 ir tip\u0105, bet ne kaip veikia ar kur saugoma</li> <li>Gali b\u016bti daug apra\u0161\u0173 (\u012fvairiuose failuose)</li> </ul> <p>Apibr\u0117\u017eimas (Definition) - \"pasakome kompiliatoriui\" K\u0104 daryti ir KUR saugoti:</p> <ul> <li><code>int add(int a, int b) { return a + b; }</code> \u2190 funkcijos apibr\u0117\u017eimas</li> <li><code>int counter = 0;</code> \u2190 kintamojo apibr\u0117\u017eimas  </li> <li>Kompiliatorius \u017eino visk\u0105 - sugeneruoja kod\u0105/alokuoja atmint\u012f</li> <li>Gali b\u016bti tik VIENAS apibr\u0117\u017eimas (vienoje vietoje)</li> </ul> <p>Aukso taisykl\u0117: </p> <ul> <li>Apra\u0161\u0173 (declarations) \u2192 daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) \u2192 tik vienas \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c/\u26a0\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> \u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror <p><pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\n</code></pre> <pre><code>user.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> \u26a0\ufe0f gcc leid\u017eia su persp\u0117jimais (implicit declaration)</p> <p><pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\n</code></pre> <pre><code>user.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre> \u274c clang grie\u017etesnis - i\u0161kart klaidos!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nesikompiliuoja-clang-perspejimai-gcc","title":"\u274c Nesikompiliuoja (clang) / \u26a0\ufe0f Persp\u0117jimai (gcc)","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bkstamos funkcij\u0173 deklaracijos (apra\u0161ai) <p>Problema: Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, kok\u012f veiksm\u0105 jis atstovauja.</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Kokio tipo? Ne\u017einau!\npush(c);    // \u274c Kas yra push? Kokio tipo? Ne\u017einau!\n</code></pre></p> <p>Skirtumas gcc vs clang:</p> <ul> <li>gcc (traditional): Leid\u017eia su warning - \"sp\u0117ja\" <code>int funkcija()</code> (implicit declaration)</li> <li>clang (strict): I\u0161kart error - ISO C99+ draud\u017eia implicit declarations</li> <li>Gali veikti su gcc, bet dangerous - sp\u0117jimas gali b\u016bti neteisingas!</li> </ul> <p>Monolitas vs atskiri failai:</p> <ul> <li>Monolite: Kompiliatorius mato vis\u0105 fail\u0105 - funkcij\u0173 apibr\u0117\u017eimai ten pat</li> <li>Failuose: Kiekvienas <code>.c</code> atskiras kompiliavimo vienetas - reikia funkcij\u0173 apra\u0161\u0173 (prototip\u0173/deklaracij\u0173)</li> </ul> <p>Sprendimas: Prid\u0117ti funkcij\u0173 prototipus (apra\u0161us) <code>user.c</code> prad\u017eioje arba...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai (multiple definitions) <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia vis\u0105 turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (funkcijos ir kintamieji) po kompiliavimo yra abiejuose <code>.o</code> failuose!</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor'iaus:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u012fterpiamas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n</code></pre></p> <p>Linkerio problema:</p> <ul> <li>Linkeris turi sulinkinti vard\u0173 kreipinius su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du - vienas <code>stack.o</code>, kitas <code>user.o</code>!</li> <li>Kur\u012f pasirinkti? Pagal kok\u012f kriterij\u0173?</li> <li>Jei abu skirtingi - kuris teisingas?</li> </ul> <p>Linkeris deleguoja sprendim\u0105: Grie\u017etai informuoja apie \"multiple definition\" - autorius privalo pataisyti!</p> <p>Prisiminkite terminologij\u0105:</p> <ul> <li>Apra\u0161\u0173 (declarations) gali b\u016bti daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) gali b\u016bti tik VIENAS \u2705</li> </ul> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams (su apra\u0161ais), ne <code>.c</code> (su apibr\u0117\u017eimais)!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito - viskas v\u0117l viename kompiliavimo vienete</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 C konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105 kai kompiliuojam <code>user.c</code></li> <li>Priklausomyb\u0117s - pakeitus <code>stack.c</code> reikia perkompiliuoti <code>user.c</code></li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>) su apra\u0161ais (prototipais)!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Apra\u0161ai vs Apibr\u0117\u017eimai - Kod\u0117l svarbu?</p> <p>K\u0105 i\u0161mokome:</p> <ul> <li>Apra\u0161ai (declarations): Funkcij\u0173 prototipai - \"sakome kad egzistuoja\"</li> <li>Apibr\u0117\u017eimai (definitions): Funkcij\u0173 realizacijos - \"sakome kaip veikia\"</li> <li>Apra\u0161\u0173 gali b\u016bti daug (\u012fvairiuose failuose) \u2705</li> <li>Apibr\u0117\u017eim\u0173 gali b\u016bti tik vienas \u2705</li> </ul> <p>Kompiliavimo vs linkavimo klaidos:</p> <ul> <li>Kompiliavimo: Tr\u016bksta apra\u0161\u0173 - implicit declaration</li> <li>Linkavimo: Daug apibr\u0117\u017eim\u0173 - multiple definition</li> </ul> <p>gcc vs clang skirtumai:</p> <ul> <li>gcc: Laisvesnis - leid\u017eia implicit declarations su warning</li> <li>clang: Grie\u017etesnis - error pagal ISO C99+</li> </ul> <p>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais (apra\u0161ais)!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#evoliucijos-santrauka","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#suolis-i-c","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_FINAL_VERSION/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>\u0160ios kelion\u0117s tikslas</p> <p>Susipa\u017einti su Abstraktaus duomen\u0173 tipo (toliau - ADT) \"Stekas\", (angl. Abstract Data Type Stack) evoliucija C kalboje: nuo papras\u010diausio monolito iki pilnai realizuoto ADT su jo egzemoliori\u0173 gyvavimo ciklo (lifecycle) valdymu.</p> <p>Kiekvienas etapas (paprastai) sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173, gilindamas teorinies \u017einias ir praktikius \u012fg\u016bd\u017eius. </p> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis!</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>Kontekstas</p> <p>\"Monolitin\u0117\" programa - viskas viename faile.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive/</code></p> <p>Pradedame nuo papras\u010diausio sprendimo - vienas failas: ir visa logika, ir visa \"fizika\" kartu.</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>$gcc usestack.c -o app\n./app\n</code></pre> arba (win) <pre><code>&gt;gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas</li> <li>Paprastas build: Viena komanda</li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173</li> <li>Pakartotinis naudojimas: Kaip kitas projektas naudot\u0173?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>Kontekstas</p> <p>Lyg ir logi\u0161kas fizinis padalijimas \u012f failus: paslauga (<code>stack.c</code>) + vartotojas (<code>user.c</code>).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC/</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinau kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja.</p> stack.cuser.c\u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\nuser.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> <pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\nuser.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#nesikompiliuoja","title":"\u274c Nesikompiliuoja","text":"Kompiliavimo klaida! <p>Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, k\u0105 ar kok\u012f veiksm\u0105 jis \"atstovauja\".</p> Monolitas vs atskiri failai <p>Monolite: kompiliatorius mato vis\u0105 fail\u0105: jeigu kreipiam\u0117s vardu (\u012f kintam\u0105j\u012f ar kvie\u010diame funkcij\u0105), j\u0173 apibr\u0117\u017eimai (definition) yra jame.</p> <p>Failuose: kiekvienas <code>.c</code> yra atskiras kompiliavimo vienetas: vard\u0173 apibr\u0117\u017et\u0173 kitame faile nemato - reikia (bent) j\u0173 apra\u0161\u0173/deklaracij\u0173 (declaration).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> user.cstack.c\u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#nesilinkina","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p><code>#include \"stack.c\"</code> \u012fterpia turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (kintamieji ir funkcijos) po kompiliavimo yra abiejuose <code>.o</code> failuose.</p> <p>Kad pagaminti vykdantij\u012f fail\u0105 (program\u0105) linkeris turi sulinkinti <code>.o</code> failuoses esan\u010dius kreipinius \u012f vardus su j\u0173 apibr\u0117\u017eimais/realizacijomis (vieninteliais!), bet j\u0173 po du per abu. K\u0105 daryti? Linkeris lyg ir gal\u0117t\u0173 pasirinkti, bet... pagal kok\u012f kriterij\u0173? Jis \u0161\u012f sprendim\u0105 grie\u017etai deleguoja autoriui,informuodamas apie \"daugybinio apibr\u0117\u017eimo\" klaid\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojan\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> ir nebelinkinsiu su juo.</p> stack.cuser.c\ud83d\udd28\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app\napp  # \u2705 VEIKIA!\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"Kod\u0117l BLOGAI (antipattern)? <ul> <li>Gr\u012f\u017eome prie monolito ir jo ribotumo/netinkamumo</li> <li>Negalimas pakartotinis naudojimas...</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Veikiantis Kodas \u2260 Geras Kodas</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering C MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> stack.hstack.cuser.c\u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#_1","title":"+++","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-2-i-h-su-extern","title":"\u017dingsnis 2:  \u012f <code>.h</code> su <code>extern</code>","text":"stack.hstack.cuser.c 03_Discovering_C_MODULE/03_NL/stack.h<pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> 03_Discovering_C_MODULE/03_NL/stack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/03_NL/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> Dar viena NL klaida <p>Kitas bandymas, kita linkavimo problema</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-3-teisingas-modulis-04_ok","title":"\u017dingsnis 3: Teisingas modulis (04_OK)","text":"stack.hstack.cuser.c 03_Discovering_C_MODULE/04_OK/stack.h<pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> 03_Discovering_C_MODULE/04_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/04_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-4-ataka-pavyksta-05_ok_attack","title":"\u017dingsnis 4: Ataka pavyksta (05_OK_Attack)","text":"stack.hstack.cattacker.c 03_Discovering_C_MODULE/05_OK_Attack/stack.h<pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> 03_Discovering_C_MODULE/05_OK_Attack/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> Global\u016bs kintamieji vie\u0161i <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-07-hiding-udt-information","title":"Etapas 07: HIDING UDT Information","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#opaque-pointer-forward-declaration","title":"Opaque pointer - forward declaration","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-1-incomplete-type-01_nc","title":"\u017dingsnis 1: Incomplete type (01_NC)","text":"stack.h 07_HIDING_UDT_Information/01_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack st;  // \u274c Incomplete type\n</code></pre> Kompiliatorius ne\u017eino sizeof(Stack)</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-2-bandymas-su-malloc-02_nc","title":"\u017dingsnis 2: Bandymas su malloc (02_NC)","text":"stack.h 07_HIDING_UDT_Information/02_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Linkavimo klaida <p>Grei\u010diausiai problema su funkcij\u0173 deklaracijomis</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#zingsnis-3-neininicializuotos-rodykles-03_rt","title":"\u017dingsnis 3: Neininicializuotos rodykl\u0117s (03_RT)","text":"stack.huser.c 07_HIDING_UDT_Information/03_RT/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 07_HIDING_UDT_Information/03_RT/user.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> Segmentation fault <p><pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos!\ninit(pst1);  // \ud83d\udca5 Crash\n</code></pre> Sprendimas \u2192 Etapas 08: Factory pattern</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-08-acquiring-resources","title":"Etapas 08: Acquiring RESOURCES","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#factory-pattern-create-destroy","title":"Factory pattern - create() / destroy()","text":"stack.hstack.cuser.c 08_Acquiring_RESOURCES/02_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 08_Acquiring_RESOURCES/02_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 08_Acquiring_RESOURCES/02_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> Factory pattern veikia! <pre><code>struct Stack *pst1 = create();\n// ... naudojimas ...\ndestroy(pst1);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#etapas-09-completing-lifecycle","title":"Etapas 09: Completing LIFECYCLE","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#pilnas-lifecycle-valdymas","title":"Pilnas lifecycle valdymas","text":"stack.hstack.cuser.c 09_Completing_LIFECYCLE/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 09_Completing_LIFECYCLE/01_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 09_Completing_LIFECYCLE/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> Pilnas C ADT! <ul> <li>\u2705 Information hiding (opaque pointer)</li> <li>\u2705 Lifecycle management (create/destroy)</li> <li>\u2705 Multiple instances</li> <li>\u2705 Factory pattern</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai \u017dingsni\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#suolis-i-c","title":"\u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\ndestroy(s);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius\ns.push('a');          // Metodas\n// Destruktorius automati\u0161kai\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>\u0160ios kelion\u0117s tikslas</p> <p>Susipa\u017einti su Abstraktaus duomen\u0173 tipo (toliau - ADT) \"Stekas\", (angl. Abstract Data Type Stack) evoliucija C kalboje: nuo papras\u010diausio monolito iki pilnai realizuoto ADT su jo egzemoliori\u0173 gyvavimo ciklo (lifecycle) valdymu.</p> <p>Kiekvienas etapas (paprastai) sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173, gilindamas teorinies \u017einias ir praktikius \u012fg\u016bd\u017eius. </p> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis!</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>Kontekstas</p> <p>\"Monolitin\u0117\" programa - viskas viename faile.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive/</code></p> <p>Pradedame nuo papras\u010diausio sprendimo - vienas failas: ir visa logika, ir visa \"fizika\" kartu.</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>$gcc usestack.c -o app\n./app\n</code></pre> arba (win) <pre><code>&gt;gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas</li> <li>Paprastas build: Viena komanda</li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173</li> <li>Pakartotinis naudojimas: Kaip kitas projektas naudot\u0173?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>Kontekstas</p> <p>Lyg ir logi\u0161kas fizinis padalijimas \u012f failus: paslauga (<code>stack.c</code>) + vartotojas (<code>user.c</code>).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC/</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinau kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja.</p> stack.cuser.c\u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\nuser.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> <pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\nuser.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#nesikompiliuoja","title":"\u274c Nesikompiliuoja","text":"Kompiliavimo klaida! <p>Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, k\u0105 ar kok\u012f veiksm\u0105 jis \"atstovauja\".</p> Monolitas vs atskiri failai <p>Monolite: kompiliatorius mato vis\u0105 fail\u0105: jeigu kreipiam\u0117s vardu (\u012f kintam\u0105j\u012f ar kvie\u010diame funkcij\u0105), j\u0173 apibr\u0117\u017eimai (definition) yra jame.</p> <p>Failuose: kiekvienas <code>.c</code> yra atskiras kompiliavimo vienetas: vard\u0173 apibr\u0117\u017et\u0173 kitame faile nemato - reikia (bent) j\u0173 apra\u0161\u0173/deklaracij\u0173 (declaration).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> user.cstack.c\u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#nesilinkina","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p><code>#include \"stack.c\"</code> \u012fterpia turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (kintamieji ir funkcijos) po kompiliavimo yra abiejuose <code>.o</code> failuose.</p> <p>Kad pagaminti vykdantij\u012f fail\u0105 (program\u0105) linkeris turi sulinkinti <code>.o</code> failuoses esan\u010dius kreipinius \u012f vardus su j\u0173 apibr\u0117\u017eimais/realizacijomis (vieninteliais!), bet j\u0173 po du per abu. K\u0105 daryti? Linkeris lyg ir gal\u0117t\u0173 pasirinkti, bet... pagal kok\u012f kriterij\u0173? Jis \u0161\u012f sprendim\u0105 grie\u017etai deleguoja autoriui,informuodamas apie \"daugybinio apibr\u0117\u017eimo\" klaid\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojan\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> ir nebelinkinsiu su juo.</p> stack.cuser.c\ud83d\udd28\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app\napp  # \u2705 VEIKIA!\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"Kod\u0117l BLOGAI (antipattern)? <ul> <li>Gr\u012f\u017eome prie monolito ir jo ribotumo/netinkamumo</li> <li>Negalimas pakartotinis naudojimas...</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Veikiantis Kodas \u2260 Geras Kodas</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-07-hiding-udt-information","title":"Etapas 07: HIDING UDT Information","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#opaque-pointer-forward-declaration","title":"Opaque pointer - forward declaration","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-1-incomplete-type-01_nc","title":"\u017dingsnis 1: Incomplete type (01_NC)","text":"stack.h 07_HIDING_UDT_Information/01_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack st;  // \u274c Incomplete type\n</code></pre> Kompiliatorius ne\u017eino sizeof(Stack)</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-2-bandymas-su-malloc-02_nc","title":"\u017dingsnis 2: Bandymas su malloc (02_NC)","text":"stack.h 07_HIDING_UDT_Information/02_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Linkavimo klaida <p>Grei\u010diausiai problema su funkcij\u0173 deklaracijomis</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#zingsnis-3-neininicializuotos-rodykles-03_rt","title":"\u017dingsnis 3: Neininicializuotos rodykl\u0117s (03_RT)","text":"stack.huser.c 07_HIDING_UDT_Information/03_RT/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 07_HIDING_UDT_Information/03_RT/user.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> Segmentation fault <p><pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos!\ninit(pst1);  // \ud83d\udca5 Crash\n</code></pre> Sprendimas \u2192 Etapas 08: Factory pattern</p>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-08-acquiring-resources","title":"Etapas 08: Acquiring RESOURCES","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#factory-pattern-create-destroy","title":"Factory pattern - create() / destroy()","text":"stack.hstack.cuser.c 08_Acquiring_RESOURCES/02_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 08_Acquiring_RESOURCES/02_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 08_Acquiring_RESOURCES/02_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> Factory pattern veikia! <pre><code>struct Stack *pst1 = create();\n// ... naudojimas ...\ndestroy(pst1);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#etapas-09-completing-lifecycle","title":"Etapas 09: Completing LIFECYCLE","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#pilnas-lifecycle-valdymas","title":"Pilnas lifecycle valdymas","text":"stack.hstack.cuser.c 09_Completing_LIFECYCLE/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 09_Completing_LIFECYCLE/01_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 09_Completing_LIFECYCLE/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> Pilnas C ADT! <ul> <li>\u2705 Information hiding (opaque pointer)</li> <li>\u2705 Lifecycle management (create/destroy)</li> <li>\u2705 Multiple instances</li> <li>\u2705 Factory pattern</li> </ul>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai \u017dingsni\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#suolis-i-c","title":"\u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\ndestroy(s);\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_From_C_To_CPP_03_ETAPAS_REFORMATTED/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius\ns.push('a');          // Metodas\n// Destruktorius automati\u0161kai\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>\u0160ios kelion\u0117s tikslas</p> <p>Susipa\u017einti su Abstraktaus duomen\u0173 tipo (toliau - ADT) \"Stekas\", (angl. Abstract Data Type Stack) evoliucija C kalboje: nuo papras\u010diausio monolito iki pilnai realizuoto ADT su jo egzemoliori\u0173 gyvavimo ciklo (lifecycle) valdymu.</p> <p>Kiekvienas etapas (paprastai) sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173, gilindamas teorinies \u017einias ir praktikius \u012fg\u016bd\u017eius. </p> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis!</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>Kontekstas</p> <p>\"Monolitin\u0117\" programa - viskas viename faile.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive/</code></p> <p>Pradedame nuo papras\u010diausio sprendimo - vienas failas: ir visa logika, ir visa \"fizika\" kartu.</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>$gcc usestack.c -o app\n./app\n</code></pre> arba (win) <pre><code>&gt;gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas</li> <li>Paprastas build: Viena komanda</li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173</li> <li>Pakartotinis naudojimas: Kaip kitas projektas naudot\u0173?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>Kontekstas</p> <p>Lyg ir logi\u0161kas fizinis padalijimas \u012f failus: paslauga (<code>stack.c</code>) + vartotojas (<code>user.c</code>).</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC/</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinau kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja.</p> stack.cuser.c\u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\nuser.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> <pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\nuser.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nesikompiliuoja","title":"\u274c Nesikompiliuoja","text":"Kompiliavimo klaida! <p>Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, k\u0105 ar kok\u012f veiksm\u0105 jis \"atstovauja\".</p> Monolitas vs atskiri failai <p>Monolite: kompiliatorius mato vis\u0105 fail\u0105: jeigu kreipiam\u0117s vardu (\u012f kintam\u0105j\u012f ar kvie\u010diame funkcij\u0105), j\u0173 apibr\u0117\u017eimai (definition) yra jame.</p> <p>Failuose: kiekvienas <code>.c</code> yra atskiras kompiliavimo vienetas: vard\u0173 apibr\u0117\u017et\u0173 kitame faile nemato - reikia (bent) j\u0173 apra\u0161\u0173/deklaracij\u0173 (declaration).</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> user.cstack.c\u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nesilinkina","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p><code>#include \"stack.c\"</code> \u012fterpia turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (kintamieji ir funkcijos) po kompiliavimo yra abiejuose <code>.o</code> failuose.</p> <p>Kad pagaminti vykdantij\u012f fail\u0105 (program\u0105) linkeris turi sulinkinti <code>.o</code> failuoses esan\u010dius kreipinius \u012f vardus su j\u0173 apibr\u0117\u017eimais/realizacijomis (vieninteliais!), bet j\u0173 po du per abu. K\u0105 daryti? Linkeris lyg ir gal\u0117t\u0173 pasirinkti, bet... pagal kok\u012f kriterij\u0173? Jis \u0161\u012f sprendim\u0105 grie\u017etai deleguoja autoriui,informuodamas apie \"daugybinio apibr\u0117\u017eimo\" klaid\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong/</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojan\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> ir nebelinkinsiu su juo.</p> stack.cuser.c\ud83d\udd28\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app\napp  # \u2705 VEIKIA!\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"Kod\u0117l BLOGAI (antipattern)? <ul> <li>Gr\u012f\u017eome prie monolito ir jo ribotumo/netinkamumo</li> <li>Negalimas pakartotinis naudojimas...</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Veikiantis Kodas \u2260 Geras Kodas</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#evoliucijos-santrauka","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#suolis-i-c","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_PILNAI_PERFORMATUOTA/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#i-oji-dalis-nuo-monolito-iki-pilno-adt-c-kalboje","title":"I-oji dalis: Nuo Monolito iki Pilno ADT C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l Stack? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - suvokiame per reik\u0161mi\u0173 aib\u0119: - <code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ... - <code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ... - <code>float</code> \u2192 3.14, -2.71, ...</p> <p>ADT - suvokiame per operacijas, o ne per reik\u0161mes: - <code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code> - Mums ner\u016bpi kaip stekas atmintyje atrodo - Mums svarbu tik k\u0105 galime su juo daryti!</p> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>Kelion\u0117s \u017eem\u0117lapis</p> <p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code> linkage)</p> <p>05-06: User-Defined Type (struct + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnas ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> <li>Pamatysime kod\u0117l reikia evoliucijos</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - stack.c ir user.c</li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bkstamos deklaracijos</li> <li>Susidursime su linkavimo klaidomis - multiple definition</li> <li>I\u0161moksime kad <code>#include \"file.c\"</code> yra antipattern</li> <li>Pamatysime skirtumus tarp gcc ir clang elgesio!</li> </ul> <p>\ud83d\udcda Terminologija: Apra\u0161as vs Apibr\u0117\u017eimas</p> <p>C kalboje kriti\u0161kai svarbu skirti du dalykus:</p> <p>Apra\u0161as (Declaration) - \"sakome kompiliatoriui\" kad ka\u017ekas egzistuoja:</p> <ul> <li><code>int add(int a, int b);</code> \u2190 funkcijos prototipas (tai ir yra apra\u0161as!)</li> <li><code>extern int counter;</code> \u2190 kintamojo apra\u0161as</li> <li>Kompiliatorius \u017eino vard\u0105 ir tip\u0105, bet ne kaip veikia ar kur saugoma</li> <li>Gali b\u016bti daug apra\u0161\u0173 (\u012fvairiuose failuose)</li> </ul> <p>Apibr\u0117\u017eimas (Definition) - \"pasakome kompiliatoriui\" K\u0104 daryti ir KUR saugoti:</p> <ul> <li><code>int add(int a, int b) { return a + b; }</code> \u2190 funkcijos apibr\u0117\u017eimas</li> <li><code>int counter = 0;</code> \u2190 kintamojo apibr\u0117\u017eimas  </li> <li>Kompiliatorius \u017eino visk\u0105 - sugeneruoja kod\u0105/alokuoja atmint\u012f</li> <li>Gali b\u016bti tik VIENAS apibr\u0117\u017eimas (vienoje vietoje)</li> </ul> <p>Aukso taisykl\u0117: </p> <ul> <li>Apra\u0161\u0173 (declarations) \u2192 daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) \u2192 tik vienas \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c/\u26a0\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> \u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror <p><pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\n</code></pre> <pre><code>user.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> \u26a0\ufe0f gcc leid\u017eia su persp\u0117jimais (implicit declaration)</p> <p><pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\n</code></pre> <pre><code>user.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre> \u274c clang grie\u017etesnis - i\u0161kart klaidos!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nesikompiliuoja-clang-perspejimai-gcc","title":"\u274c Nesikompiliuoja (clang) / \u26a0\ufe0f Persp\u0117jimai (gcc)","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bkstamos funkcij\u0173 deklaracijos (apra\u0161ai) <p>Problema: Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, kok\u012f veiksm\u0105 jis atstovauja.</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Kokio tipo? Ne\u017einau!\npush(c);    // \u274c Kas yra push? Kokio tipo? Ne\u017einau!\n</code></pre></p> <p>Skirtumas gcc vs clang:</p> <ul> <li>gcc (traditional): Leid\u017eia su warning - \"sp\u0117ja\" <code>int funkcija()</code> (implicit declaration)</li> <li>clang (strict): I\u0161kart error - ISO C99+ draud\u017eia implicit declarations</li> <li>Gali veikti su gcc, bet dangerous - sp\u0117jimas gali b\u016bti neteisingas!</li> </ul> <p>Monolitas vs atskiri failai:</p> <ul> <li>Monolite: Kompiliatorius mato vis\u0105 fail\u0105 - funkcij\u0173 apibr\u0117\u017eimai ten pat</li> <li>Failuose: Kiekvienas <code>.c</code> atskiras kompiliavimo vienetas - reikia funkcij\u0173 apra\u0161\u0173 (prototip\u0173/deklaracij\u0173)</li> </ul> <p>Sprendimas: Prid\u0117ti funkcij\u0173 prototipus (apra\u0161us) <code>user.c</code> prad\u017eioje arba...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai (multiple definitions) <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia vis\u0105 turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (funkcijos ir kintamieji) po kompiliavimo yra abiejuose <code>.o</code> failuose!</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor'iaus:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u012fterpiamas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n</code></pre></p> <p>Linkerio problema:</p> <ul> <li>Linkeris turi sulinkinti vard\u0173 kreipinius su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du - vienas <code>stack.o</code>, kitas <code>user.o</code>!</li> <li>Kur\u012f pasirinkti? Pagal kok\u012f kriterij\u0173?</li> <li>Jei abu skirtingi - kuris teisingas?</li> </ul> <p>Linkeris deleguoja sprendim\u0105: Grie\u017etai informuoja apie \"multiple definition\" - autorius privalo pataisyti!</p> <p>Prisiminkite terminologij\u0105:</p> <ul> <li>Apra\u0161\u0173 (declarations) gali b\u016bti daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) gali b\u016bti tik VIENAS \u2705</li> </ul> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams (su apra\u0161ais), ne <code>.c</code> (su apibr\u0117\u017eimais)!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito - viskas v\u0117l viename kompiliavimo vienete</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 C konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105 kai kompiliuojam <code>user.c</code></li> <li>Priklausomyb\u0117s - pakeitus <code>stack.c</code> reikia perkompiliuoti <code>user.c</code></li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>) su apra\u0161ais (prototipais)!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Apra\u0161ai vs Apibr\u0117\u017eimai - Kod\u0117l svarbu?</p> <p>K\u0105 i\u0161mokome:</p> <ul> <li>Apra\u0161ai (declarations): Funkcij\u0173 prototipai - \"sakome kad egzistuoja\"</li> <li>Apibr\u0117\u017eimai (definitions): Funkcij\u0173 realizacijos - \"sakome kaip veikia\"</li> <li>Apra\u0161\u0173 gali b\u016bti daug (\u012fvairiuose failuose) \u2705</li> <li>Apibr\u0117\u017eim\u0173 gali b\u016bti tik vienas \u2705</li> </ul> <p>Kompiliavimo vs linkavimo klaidos:</p> <ul> <li>Kompiliavimo: Tr\u016bksta apra\u0161\u0173 - implicit declaration</li> <li>Linkavimo: Daug apibr\u0117\u017eim\u0173 - multiple definition</li> </ul> <p>gcc vs clang skirtumai:</p> <ul> <li>gcc: Laisvesnis - leid\u017eia implicit declarations su warning</li> <li>clang: Grie\u017etesnis - error pagal ISO C99+</li> </ul> <p>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais (apra\u0161ais)!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#evoliucijos-santrauka","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#suolis-i-c","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TIKRAI_FINAL/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#i-oji-dalis-nuo-monolito-iki-pilno-adt-c-kalboje","title":"I-oji dalis: Nuo Monolito iki Pilno ADT C kalboje","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#kodel-stack-kodel-evoliucija","title":"\ud83c\udfaf Kod\u0117l Stack? Kod\u0117l evoliucija?","text":"<p>ADT vs Primityv\u016bs Tipai</p> <p>Abstraktus Duomen\u0173 Tipas (ADT) fundamentaliai skiriasi nuo \"mokyklini\u0173\" primityvi\u0173 tip\u0173 (<code>int</code>, <code>char</code>, <code>float</code>).</p> <p>Primityv\u016bs tipai - suvokiame per reik\u0161mi\u0173 aib\u0119: - <code>int</code> \u2192 ..., -2, -1, 0, 1, 2, 3, ... - <code>char</code> \u2192 'a', 'b', 'c', ..., 'z', ... - <code>float</code> \u2192 3.14, -2.71, ...</p> <p>ADT - suvokiame per operacijas, o ne per reik\u0161mes: - <code>Stack</code> \u2192 <code>push()</code>, <code>pop()</code>, <code>isEmpty()</code>, <code>isFull()</code> - Mums ner\u016bpi kaip stekas atmintyje atrodo - Mums svarbu tik k\u0105 galime su juo daryti!</p> <p>Kod\u0117l pasirinktas Stack?</p> <p>Stack (Stekas) - idealus ADT mokymosi pavyzdys:</p> <p>\u2705 Paprasta semantika: LIFO (Last In, First Out) - \"paskutinis \u012f\u0117jo, pirmas i\u0161\u0117jo\"</p> <p>\u2705 Minimalios operacijos: Tik 2 pagrindin\u0117s - <code>push()</code> ir <code>pop()</code></p> <p>\u2705 Ai\u0161ki teisingo/blogo elgesio riba: Lengva demonstruoti klaidas</p> <p>\u2705 Universalus: Naudojamas visur - funkcij\u0173 i\u0161kvietim\u0173 stekas, expression evaluation, undo mechanizmai</p> <p>\u2705 Evolucionuoja \u012f C++ klas\u0119: Puikus tiltas tarp C ir C++</p> <p>Evoliucijos metodologija</p> <p>\u0160ioje kelion\u0117je kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamasis i\u0161 bandym\u0173 ir klaid\u0173:</p> <ul> <li>Kompiliavimo klaidos \u2192 mokome extern/static</li> <li>Linkavimo klaidos \u2192 suprantame multiple definition</li> <li>Runtime klaidos \u2192 i\u0161mokstame pass-by-pointer</li> <li>Saugumo problemos \u2192 atrandame information hiding</li> </ul> <p>Kompiliavimo ir linkavimo klaidos ir persp\u0117jimai yra mokymosi \u012frankis, o ne kli\u016btis!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>Kelion\u0117s \u017eem\u0117lapis</p> <p>01-03: Modulio gimimas (C modulis su header failais)</p> <p>04: Information hiding (<code>static</code> linkage)</p> <p>05-06: User-Defined Type (struct + modulis)</p> <p>07: Opaque pointer (forward declaration)</p> <p>08-09: Pilnas ADT (factory pattern, lifecycle)</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1etapas-stekas-programa","title":"1\ufe0f\u20e3Etapas: \"Stekas-Programa\"","text":"<p><code>01_Running_PROGRAM</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti papras\u010diausi\u0105 veikian\u010di\u0105 steko realizacij\u0105 - prad\u0117ti nuo monolitin\u0117s programos.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Para\u0161ysime vis\u0105 kod\u0105 viename faile - monolitas</li> <li>Naudosime globalius kintamuosius steko duomenims</li> <li>Suprasime monolito privalumus ir ribotumus</li> <li>Pamatysime kod\u0117l reikia evoliucijos</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-naivus","title":"1 sprendimas: \"Naivus\"","text":"<p><code>01_Running_PROGRAM/01_OK_Naive</code></p> <p>sumanymas/ketinimas</p> <p>Papras\u010diausia \u012fmanoma realizacija - viskas viename faile: duomenys, funkcijos, <code>main()</code>. Greitas prototipavimas!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 01_Running_PROGRAM/01_OK_naive/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc usestack.c -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet","title":"\u2705 Veikia! Bet...","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas - visk\u0105 \"mato\"</li> <li>Paprastas build: Viena komanda <code>gcc usestack.c -o app</code></li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur - jokios apsaugos</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173 stek\u0173 vienu metu</li> <li>Pakartotinis naudojimas: Kaip kitas projektas panaudot\u0173 \u0161\u012f kod\u0105?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile \u2192 sunku orientuotis</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos","title":"\ud83d\udca1 Pamokos","text":"<p>Monolitin\u0117 programa</p> <ul> <li>Papras\u010diausia prad\u017eia - viskas viename faile</li> <li>Global\u016bs duomenys - prieinami be apsaugos</li> <li>Ribojimas - tik vienas steko egzempliorius</li> <li>Sprendimas \u2192 Etapas 02: Padalinti \u012f failus</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2etapas-stekas-failas","title":"2\ufe0f\u20e3Etapas: \"Stekas-Failas\"","text":"<p><code>02_Decomposing_to_UNITS</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti fizinio padalijimo \u012f failus - atskirti paslaug\u0105 (<code>stack.c</code>) nuo vartotojo (<code>user.c</code>).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Padalinsime kod\u0105 \u012f du failus - stack.c ir user.c</li> <li>Susidursime su kompiliavimo klaidomis - tr\u016bkstamos deklaracijos</li> <li>Susidursime su linkavimo klaidomis - multiple definition</li> <li>I\u0161moksime kad <code>#include \"file.c\"</code> yra antipattern</li> <li>Pamatysime skirtumus tarp gcc ir clang elgesio!</li> </ul> <p>\ud83d\udcda Terminologija: Apra\u0161as vs Apibr\u0117\u017eimas</p> <p>C kalboje kriti\u0161kai svarbu skirti du dalykus:</p> <p>Apra\u0161as (Declaration) - \"sakome kompiliatoriui\" kad ka\u017ekas egzistuoja:</p> <ul> <li><code>int add(int a, int b);</code> \u2190 funkcijos prototipas (tai ir yra apra\u0161as!)</li> <li><code>extern int counter;</code> \u2190 kintamojo apra\u0161as</li> <li>Kompiliatorius \u017eino vard\u0105 ir tip\u0105, bet ne kaip veikia ar kur saugoma</li> <li>Gali b\u016bti daug apra\u0161\u0173 (\u012fvairiuose failuose)</li> </ul> <p>Apibr\u0117\u017eimas (Definition) - \"pasakome kompiliatoriui\" K\u0104 daryti ir KUR saugoti:</p> <ul> <li><code>int add(int a, int b) { return a + b; }</code> \u2190 funkcijos apibr\u0117\u017eimas</li> <li><code>int counter = 0;</code> \u2190 kintamojo apibr\u0117\u017eimas  </li> <li>Kompiliatorius \u017eino visk\u0105 - sugeneruoja kod\u0105/alokuoja atmint\u012f</li> <li>Gali b\u016bti tik VIENAS apibr\u0117\u017eimas (vienoje vietoje)</li> </ul> <p>Aukso taisykl\u0117: </p> <ul> <li>Apra\u0161\u0173 (declarations) \u2192 daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) \u2192 tik vienas \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-kodo-padalijimas","title":"1 sprendimas: Kodo padalijimas","text":"<p><code>02_Decomposing_to_UNITS/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Tiesiog padalinsiu kod\u0105 \u012f du failus ir kompiliuoju atskirai, kaip man\u0119s ir reikalauja \"proper\" C.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c/\u26a0\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/01_NC/user.c <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> \u2699\ufe0fgcc \u2192 \u26a0\ufe0fwarning\u2699\ufe0fclang \u2192 \u274cerror <p><pre><code>gcc -c stack.c # \u2705\ngcc -c user.c  # \u26a0\ufe0f\n</code></pre> <pre><code>user.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init' [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^~~~\nuser.c:7:37: warning: implicit declaration of function 'push' [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^~~~\nuser.c:8:13: warning: implicit declaration of function 'isEmpty' [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^~~~~~~\nuser.c:8:32: warning: implicit declaration of function 'pop'; did you mean 'popen'? [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^~~\n    |                                popen\n</code></pre> \u26a0\ufe0f gcc leid\u017eia su persp\u0117jimais (implicit declaration)</p> <p><pre><code>clang -c stack.c # \u2705\nclang -c user.c  # \u274c\n</code></pre> <pre><code>user.c:6:5: error: call to undeclared function 'init'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    6 |     init();\n    |     ^\nuser.c:7:37: error: call to undeclared function 'push'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    7 |     while ('\\n' != (c = getchar())) push(c);\n    |                                     ^\nuser.c:8:13: error: call to undeclared function 'isEmpty'; ISO C99 and later do not support implicit function\n    declarations [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |             ^\nuser.c:8:32: error: call to undeclared function 'pop'; ISO C99 and later do not support implicit function declarations\n    [-Wimplicit-function-declaration]\n    8 |     while (!isEmpty()) putchar(pop());\n    |                                ^\n4 errors generated.\n</code></pre> \u274c clang grie\u017etesnis - i\u0161kart klaidos!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nesikompiliuoja-clang-perspejimai-gcc","title":"\u274c Nesikompiliuoja (clang) / \u26a0\ufe0f Persp\u0117jimai (gcc)","text":"\ud83d\udd0d Diagnoz\u0117: Tr\u016bkstamos funkcij\u0173 deklaracijos (apra\u0161ai) <p>Problema: Kreipiam\u0117s \u012f neapra\u0161yt\u0105 funkcij\u0105 - kompiliatorius \"ne\u017eino\" kas tai per vardas, kok\u012f veiksm\u0105 jis atstovauja.</p> <p>Kod\u0117l: <pre><code>// user.c kompiliuojant:\ninit();     // \u274c Kas yra init? Kokio tipo? Ne\u017einau!\npush(c);    // \u274c Kas yra push? Kokio tipo? Ne\u017einau!\n</code></pre></p> <p>Skirtumas gcc vs clang:</p> <ul> <li>gcc (traditional): Leid\u017eia su warning - \"sp\u0117ja\" <code>int funkcija()</code> (implicit declaration)</li> <li>clang (strict): I\u0161kart error - ISO C99+ draud\u017eia implicit declarations</li> <li>Gali veikti su gcc, bet dangerous - sp\u0117jimas gali b\u016bti neteisingas!</li> </ul> <p>Monolitas vs atskiri failai:</p> <ul> <li>Monolite: Kompiliatorius mato vis\u0105 fail\u0105 - funkcij\u0173 apibr\u0117\u017eimai ten pat</li> <li>Failuose: Kiekvienas <code>.c</code> atskiras kompiliavimo vienetas - reikia funkcij\u0173 apra\u0161\u0173 (prototip\u0173/deklaracij\u0173)</li> </ul> <p>Sprendimas: Prid\u0117ti funkcij\u0173 prototipus (apra\u0161us) <code>user.c</code> prad\u017eioje arba...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-c-failo-include","title":"2 sprendimas: <code>.c</code> failo <code>#include</code>","text":"<p><code>02_Decomposing_to_UNITS/02_NL</code></p> <p>sumanymas/ketinimas</p> <p>Jei nemato vard\u0173, o yra <code>#include</code>, tai j\u012f ir panaudosiu - tada matys (kitur veikia pvz. <code>import</code>).</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2192 \ud83d\udd17gcc \u2192 \u274cerror\u2699\ufe0fclang \u2192 \ud83d\udd17clang \u2192 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.text+0x0): multiple definition of `init'; stack.o:stack.c:(.text+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x11): multiple definition of `isEmpty'; stack.o:stack.c:(.text+0x11): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x25): multiple definition of `isFull'; stack.o:stack.c:(.text+0x25): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x3a): multiple definition of `push'; stack.o:stack.c:(.text+0x3a): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.text+0x76): multiple definition of `pop'; stack.o:stack.c:(.text+0x76): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x8): multiple definition of `top'; stack.o:stack.c:(.bss+0x8): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nesilinkina","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Daugybiniai apibr\u0117\u017eimai (multiple definitions) <p>Problema: <code>#include \"stack.c\"</code> \u012fterpia vis\u0105 turin\u012f \u2192 visi <code>stack.c</code> apibr\u0117\u017eimai (funkcijos ir kintamieji) po kompiliavimo yra abiejuose <code>.o</code> failuose!</p> <p>Kod\u0117l: <pre><code>// user.c po preprocessor'iaus:\n#include \"stack.c\"  \u2192 [visas stack.c kodas \u012fterpiamas \u010dia]\n\n// Rezultatas:\n// stack.o turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n// user.o TAIP PAT turi: init(), push(), pop(), stack[], top  \u2190 apibr\u0117\u017eimai\n</code></pre></p> <p>Linkerio problema:</p> <ul> <li>Linkeris turi sulinkinti vard\u0173 kreipinius su j\u0173 apibr\u0117\u017eimais</li> <li>Bet apibr\u0117\u017eim\u0173 po du - vienas <code>stack.o</code>, kitas <code>user.o</code>!</li> <li>Kur\u012f pasirinkti? Pagal kok\u012f kriterij\u0173?</li> <li>Jei abu skirtingi - kuris teisingas?</li> </ul> <p>Linkeris deleguoja sprendim\u0105: Grie\u017etai informuoja apie \"multiple definition\" - autorius privalo pataisyti!</p> <p>Prisiminkite terminologij\u0105:</p> <ul> <li>Apra\u0161\u0173 (declarations) gali b\u016bti daug \u2705</li> <li>Apibr\u0117\u017eim\u0173 (definitions) gali b\u016bti tik VIENAS \u2705</li> </ul> <p>Sprendimas: <code>#include</code> skirtas <code>.h</code> failams (su apra\u0161ais), ne <code>.c</code> (su apibr\u0117\u017eimais)!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#3-sprendimas-c-failo-include-be-galvos-skausmo","title":"3 sprendimas: <code>.c</code> failo <code>#include</code> be \"galvos skausmo\"","text":"<p><code>02_Decomposing_to_UNITS/03_OK_Wrong</code></p> <p>sumanymas/ketinimas</p> <p>Jei nesilinkina d\u0117l pasikartojani\u010di\u0173 apibr\u0117\u017eim\u0173, tai paliksiu <code>#include \"stack.c\"</code> bet nebelinkinsiu su <code>stack.o</code>.</p> stack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 02_Decomposing_to_UNITS/03_OK_Wrong/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet_1","title":"\u2705 Veikia! Bet...","text":"\ud83d\udd0d Kod\u0117l BLOGAI (antipattern)? <p>Veikia, bet gr\u012f\u017eome prie monolito problemos:</p> <ul> <li>Gr\u012f\u017eome prie monolito - viskas v\u0117l viename kompiliavimo vienete</li> <li>Negalimas pakartotinis naudojimas - kaip kitas projektas panaudos?</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code> - prie\u0161 C konvencij\u0105</li> <li>Kompiliavimo laikas - <code>stack.c</code> kompiliuojamas kiekvien\u0105 kart\u0105 kai kompiliuojam <code>user.c</code></li> <li>Priklausomyb\u0117s - pakeitus <code>stack.c</code> reikia perkompiliuoti <code>user.c</code></li> </ul> <p>Teisingas kelias: Reikia header fail\u0173 (<code>.h</code>) su apra\u0161ais (prototipais)!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_1","title":"\ud83d\udca1 Pamokos","text":"<p>Apra\u0161ai vs Apibr\u0117\u017eimai - Kod\u0117l svarbu?</p> <p>K\u0105 i\u0161mokome:</p> <ul> <li>Apra\u0161ai (declarations): Funkcij\u0173 prototipai - \"sakome kad egzistuoja\"</li> <li>Apibr\u0117\u017eimai (definitions): Funkcij\u0173 realizacijos - \"sakome kaip veikia\"</li> <li>Apra\u0161\u0173 gali b\u016bti daug (\u012fvairiuose failuose) \u2705</li> <li>Apibr\u0117\u017eim\u0173 gali b\u016bti tik vienas \u2705</li> </ul> <p>Kompiliavimo vs linkavimo klaidos:</p> <ul> <li>Kompiliavimo: Tr\u016bksta apra\u0161\u0173 - implicit declaration</li> <li>Linkavimo: Daug apibr\u0117\u017eim\u0173 - multiple definition</li> </ul> <p>gcc vs clang skirtumai:</p> <ul> <li>gcc: Laisvesnis - leid\u017eia implicit declarations su warning</li> <li>clang: Grie\u017etesnis - error pagal ISO C99+</li> </ul> <p>Sprendimas \u2192 Etapas 03: Tikras C modulis su <code>.h</code> failais (apra\u0161ais)!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#3etapas-stekas-modulis","title":"3\ufe0f\u20e3Etapas: \"Stekas-Modulis\"","text":"<p><code>03_Discovering_C_MODULE</code></p> <p>Kontekstas</p> <p>Tikras C modulis su header failu.</p> <p>Modulis = Interfeisas + Realizacija = Antra\u0161t\u0117 (antra\u0161t\u0117s failas) + Kodas (i\u0161eities failas)</p> <p>Modulis = <code>.h</code> + <code>.c</code></p> <p>4 sprendimai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-i-h-be-extern","title":"1 sprendimas: \u012f <code>.h</code> be <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/02_NL/</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu tikr\u0105 C modul\u012f: <code>.h</code> su deklaracijomis, <code>.c</code> su apibr\u0117\u017eimais. Tiesiog perkelsiu funkcij\u0173 prototipus ir kintam\u0173j\u0173 deklaracijas \u012f header fail\u0105.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.h <pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/02_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `top'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x10): multiple definition of `stack'; stack.o:stack.c:(.bss+0x10): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nesilinkina_1","title":"\u274c Nesilinkina","text":"Linkinimo klaida! <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas. Tas pats kaip buvo, bet tik kintamiesiems. Reikia \"apra\u0161o formos\" kintamiesiems. Pasitelkiam <code>extern</code>.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-i-h-su-extern","title":"2 sprendimas: \u012f <code>.h</code> su <code>extern</code>","text":"<p><code>03_Discovering_C_MODULE/03_NL/</code></p> <p>sumanymas/ketinimas</p> <p>I\u0161mokau, kad header'yje reikia <code>extern</code> kintamiesiems! Prid\u0117siu <code>extern</code> prie <code>stack[]</code> ir <code>top</code> deklaracij\u0173.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.h <pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/stack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/03_NL/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x0): multiple definition of `stack'; user.o:user.c:(.bss+0x0): first defined here\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: stack.o:stack.c:(.bss+0x64): multiple definition of `top'; user.o:user.c:(.bss+0x64): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre> \u274c multiple definition of ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user.c -o user.o    # \u2705\nclang stack.o user.o -o app  # \u274c\n</code></pre> <pre><code>C:/mingw64/bin/ld: user.o:user.c:(.bss+0x0): multiple definition of `stack'; stack.o:stack.c:(.bss+0x0): first defined here\nC:/mingw64/bin/ld: user.o:user.c:(.bss+0x64): multiple definition of `top'; stack.o:stack.c:(.bss+0x64): first defined here\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre> \u274c multiple definition of ...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nesilinkina_2","title":"\u274c Nesilinkina","text":"Dar viena NL klaida! <p><code>extern</code> header'yje gerai, bet <code>stack.c</code> TAIP PAT turi kintam\u0173j\u0173 apibr\u0117\u017eimus! Dabar abu <code>.c</code> failai sukuria apibr\u0117\u017eimus. Header'yje turi b\u016bti TIK <code>extern</code> deklaracijos, o apibr\u0117\u017eimas \u2013 TIKTAI viename <code>.c</code> faile.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#3-sprendimas-teisingas-modulis","title":"3 sprendimas: Teisingas modulis","text":"<p><code>03_Discovering_C_MODULE/04_OK/</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Header'yje \u2013 <code>extern</code> deklaracijos, o apibr\u0117\u017eimas tik <code>stack.c</code> faile (be <code>extern</code>). User.c tik naudoja, bet neapibr\u0117\u017eia.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/04_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet_2","title":"\u2705 Veikia! Bet...","text":"Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul> Problemos, pavojai... <ul> <li>Global\u016bs kintamieji vie\u0161ai prieinami: Kas nors gali ra\u0161yti <code>extern int top;</code> savo kode ir manipuliuoti!</li> <li>N\u0117ra apsaugos: Bet kas gali sugadinti <code>top</code> ar <code>stack[]</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#4-sprendimas-ataka-pavyksta","title":"4 sprendimas: Ataka pavyksta","text":"<p><code>03_Discovering_C_MODULE/05_OK_Attack/</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruoju, kad net ir \"teisingas\" modulis su <code>extern</code> n\u0117ra saugus \u2013 \"attacker\" gali prid\u0117ti <code>extern int top;</code> ir keisti steko b\u016bsen\u0105.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.h <pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\napp\n</code></pre></p> <pre><code>HACKED: -1\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet-blogai","title":"\u2705 Veikia, bet BLOGAI!","text":"Global\u016bs kintamieji vie\u0161ai prieinami <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Vartotojas gali tiesiogiai pasiekti ir sugadinti vidin\u0119 ste\u043a\u043e b\u016bsen\u0105!</p> <p>Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_2","title":"\ud83d\udca1 Pamokos","text":"<p>C Modulio Anatomija</p> <ul> <li>Header (<code>.h</code>): <code>extern</code> deklaracijos globali\u0173 kintam\u0173j\u0173 + funkcij\u0173 prototipai</li> <li>Source (<code>.c</code>): Kintam\u0173j\u0173 apibr\u0117\u017eimai (be <code>extern</code>) + funkcij\u0173 realizacijos</li> <li>Problem: Global\u016bs kintamieji su <code>extern</code> yra prieinami bet kam!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#4etapas-apsaugota-implementacija","title":"4\ufe0f\u20e3Etapas: \"Apsaugota Implementacija\"","text":"<p><code>04_Protecting_IMPLEMENTATION</code></p> <p>\ud83c\udfaf Tikslas</p> <p>I\u0161mokti information hiding technik\u0105 naudojant <code>static</code> linkage - pasl\u0117pti vidin\u0119 implementacij\u0105 nuo i\u0161orinio pasaulio.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Bandysime atakuoti modul\u012f prid\u0117dami <code>extern</code> su <code>static</code></li> <li>Suprasime kaip <code>static</code> saugo duomenis</li> <li>Pamatysime likusi\u0105 problem\u0105 - tik vienas stekas</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-ataka-su-static","title":"1 sprendimas: Ataka su static","text":"<p><code>04_Protecting_IMPLEMENTATION/01_NL_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu atakuoti modul\u012f - prid\u0117siu <code>static</code> prie kintam\u0173j\u0173 <code>stack.c</code>, bet palikusiu <code>extern</code> deklaracijas <code>stack.h</code>.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\u274c \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/01_NL_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data  // +\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    reset();\n    return 0;\n}\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;gcc stack.c user_attack.c -o user_attack\n\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.text+0x7d): undefined reference to `reset'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\ccuqV69P.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\n\\04_hiding_Implementation\\01_nl_z&gt;clang stack.c user_attack.c -o user_attack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.text+0xc1): undefined reference to `reset'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/user_attack-4b596d.o:user_attack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> \u2699\ufe0fgcc \u2794 \ud83d\udd17gcc \u2794 \u274cerror\u2699\ufe0fclang \u2794 \ud83d\udd17clang \u2794 \u274cerror <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user_attack.c -o user_attack.o  # \u2705\ngcc stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\ncollect2: error: ld returned 1 exit status\n</code></pre> \u274c undefined reference to ...</p> <p><pre><code>clang -c stack.c -o stack.o  # \u2705\nclang -c user_attack.c -o user_attack.o  # \u2705\nclang stack.o user_attack.o -o app  # \u274c\n</code></pre> <pre><code>/usr/bin/ld: user_attack.o: in function `main':\nuser_attack.c:(.text+0x7): undefined reference to `top'\nclang: error: linker command failed with exit code 1\n</code></pre> \u274c undefined reference to ...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nesilinkina_3","title":"\u274c Nesilinkina","text":"\ud83d\udd0d Diagnoz\u0117: Konfliktas tarp extern ir static <p>Problema: Header'yje deklaruojame <code>extern int top;</code>, bet <code>stack.c</code> apibr\u0117\u017eia <code>static int top = 0;</code></p> <p>Kod\u0117l nevyksta: - <code>extern</code> sako \"ie\u0161koti i\u0161or\u0117je, matomas kitose kompiliavimo vieneto\" - <code>static</code> sako \"matomas tik \u0161iame faile\" - Linkeris negali rasti <code>top</code>, nes jis internal linkage!</p> <p>Sprendimas: Pa\u0161alinti <code>extern</code> i\u0161 header'o - palikti tik funkcij\u0173 prototipus.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-tikras-information-hiding","title":"2 sprendimas: Tikras information hiding","text":"<p><code>04_Protecting_IMPLEMENTATION/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Supratau! Pa\u0161alinsiu <code>extern</code> deklaracijas i\u0161 header'o. Header'yje - tik funkcij\u0173 prototipai, o kintamieji su <code>static</code> lieka tik <code>stack.c</code> viduje.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.h <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/stack.c <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 04_Protecting_IMPLEMENTATION/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n\nint main(void) {\n    char c;\n\n    init();\n\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> arba (win) <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\napp\n</code></pre></p> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet_3","title":"\u2705 Veikia! Bet...","text":"<code>static</code> linkage saugo! <p><pre><code>static char stack[STACK_SIZE];  // Internal linkage\nstatic int top = 0;              // Nematomas i\u0161or\u0117je\n</code></pre> - Ataka dabar neveiks - negalima <code>extern int top;</code> - Duomenys apsaugoti nuo i\u0161orinio manipuliavimo - Information hiding pasiektas!</p> Problemos, pavojai... <ul> <li>Tik vienas stekas: <code>static</code> kintamieji global\u016bs viduje modulio</li> <li>Negalima keliems egzemplioriams: Reikia strukt\u016bros!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_3","title":"\ud83d\udca1 Pamokos","text":"<p>Static Linkage</p> <ul> <li><code>static</code> kintamieji - internal linkage (matomi tik tame faile)</li> <li>Information hiding: Vartotojas negali pasiekti <code>top</code> ar <code>stack[]</code></li> <li>Ribojimas: Tik vienas stekas - reikia user-defined type (struct)!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#5etapas-stekas-tipas","title":"5\ufe0f\u20e3Etapas: \"Stekas-Tipas\"","text":"<p><code>05_Defining_USER_TYPE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Sukurti user-defined type (struct) - leisti keliems stek\u0173 egzemplioriams egzistuoti vienu metu.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Gr\u012f\u0161ime prie monolito, bet su struct</li> <li>I\u0161moksime <code>static</code> draudim\u0105 strukt\u016brose</li> <li>Suprasime pass-by-value vs pass-by-pointer skirtumus</li> <li>Sukursime kelis stek\u0173 egzempliorius!</li> </ul> <p>Koncepcija: 'Greitas entry point'</p> <p>Tarsi \u012fdarbinimo pokalbio \"quick solution\" - gr\u012f\u017etame prie monolito, bet su strukt\u016bra.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-static-strukturoje","title":"1 sprendimas: static strukt\u016broje","text":"<p><code>05_Defining_USER_TYPE/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu struct su <code>static</code> nariais - taip i\u0161laikysiu <code>static</code> apsaug\u0105 i\u0161 etapo 04!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 05_Defining_USER_TYPE/01_NC/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> <p><pre><code>gcc usestack.c -o app  # \u274c\n</code></pre> <pre><code>usestack.c:7:5: error: storage class specified for 'stack'\nusestack.c:8:5: error: storage class specified for 'top'\n</code></pre> \u274c storage class specified for ...</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nekompiliuojasi","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: static draud\u017eiamas strukt\u016brose <p>Problema: C neleid\u017eia <code>static</code> storage class specifiers strukt\u016br\u0173 nariams!</p> <p>Kod\u0117l: <pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n    static int top;           // \u274c Neleid\u017eiama!\n};\n</code></pre></p> <ul> <li><code>static</code> yra storage class, ne type qualifier</li> <li>Struct nariai turi b\u016bti instance data, ne class data</li> <li>C++ leid\u017eia <code>static</code> narius klas\u0117se, bet ne C!</li> </ul> <p>Sprendimas: Pa\u0161alinti <code>static</code> - naudoti \u012fprastus narius.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-pass-by-value","title":"2 sprendimas: Pass-by-value","text":"<p><code>05_Defining_USER_TYPE/02_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pa\u0161alinsiu <code>static</code> ir perduosiu strukt\u016br\u0105 funkcijoms pagal reik\u0161m\u0119 (pass-by-value).</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/02_RT/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>(tu\u0161\u010dia)\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#kompiliuojasi-bet-blogai-veikia","title":"\u2705 Kompiliuojasi, bet BLOGAI veikia!","text":"\ud83d\udd0d Diagnoz\u0117: Pass-by-value kopijuoja strukt\u016br\u0105 <p>Problema: Runtime error - <code>pop()</code> negra\u017eina nieko!</p> <p>Kod\u0117l: <pre><code>void init(struct Stack st) {    // Kopija!\n    st.top = 0;                 // Kei\u010dia KOPIJ\u0104\n}                               // Kopija sunaikinama\n\nvoid push(struct Stack st, char c) {  // Kopija!\n    st.stack[st.top++] = c;           // Kei\u010dia KOPIJ\u0104\n}                                     // Kopija sunaikinama\n</code></pre></p> <ul> <li>Pass-by-value - funkcija gauna kopij\u0105 strukt\u016bros</li> <li>Visi pakeitimai vyksta kopijoje</li> <li>Originalas <code>main()</code> funkcijoje nepasikeis!</li> </ul> <p>Sprendimas: Naudoti pass-by-pointer - perduoti adres\u0105.</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#3-sprendimas-pass-by-pointer","title":"3 sprendimas: Pass-by-pointer","text":"<p><code>05_Defining_USER_TYPE/03_OK</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius - funkcijos gaus strukt\u016bros adres\u0105, gal\u0117s keisti original\u0105!</p> usestack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 05_Defining_USER_TYPE/03_OK/usestack.c <pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> <pre><code>gcc usestack.c -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia","title":"\u2705 Veikia!","text":"Pass-by-pointer sprend\u017eia problem\u0105! <p><pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia ORIGINAL\u0104\n}\n\nstruct Stack st1, st2;  // Du stekai!\ninit(&amp;st1);\ninit(&amp;st2);\n</code></pre> - Pass-by-pointer - funkcija gauna adres\u0105 - Visi pakeitimai vyksta originale - Galime tur\u0117ti kelis egzempliorius!</p> Problemos, pavojai... <ul> <li>Strukt\u016bra vie\u0161a: Vartotojas mato <code>struct Stack { char stack[100]; int top; };</code></li> <li>Nariai prieinami: Gali ra\u0161yti <code>st1.top = 999;</code> - sugadinti b\u016bsen\u0105</li> <li>N\u0117ra information hiding: Reikia encapsulation + modulio!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_4","title":"\ud83d\udca1 Pamokos","text":"<p>User-Defined Type</p> <ul> <li>Struct leid\u017eia kurti naujus tipus</li> <li><code>static</code> draud\u017eiamas strukt\u016br\u0173 nariuose C kalboje</li> <li>Pass-by-value kopijuoja \u2192 pakeitimai nei\u0161lieka</li> <li>Pass-by-pointer \u2192 galima keisti original\u0105</li> <li>Keli egzemplioriai: <code>struct Stack st1, st2;</code> \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#6etapas-stekas-kapsule","title":"6\ufe0f\u20e3Etapas: \"Stekas-Kapsul\u0117\"","text":"<p><code>06_ENCAPSULATING_UDT_in_Module</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Encapsulation - apjungti duomenis ir funkcijas modulyje. Sukurti struct + modulis kombinacij\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Apjungsime id\u0117jas: 05 etapas (struct) + 03 etapas (modulis)</li> <li>Sukursime modulin\u012f user-defined type</li> <li>Pamatysime kad encapsulation \u2260 information hiding</li> </ul> <p>Koncepcija: Apjungimas id\u0117j\u0173</p> <p>Struct i\u0161 05 + Modulis i\u0161 03 = Strukt\u016brizuotas modulis</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-modulinis-udt","title":"1 sprendimas: Modulinis UDT","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu struct apibr\u0117\u017eim\u0105 \u012f modul\u012f - tur\u0117siu stack.h su strukt\u016bros deklaracija ir funkcij\u0173 prototipais, stack.c su realizacija.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet_4","title":"\u2705 Veikia! Bet...","text":"Modulinis UDT veikia! <ul> <li>\u2705 Struct modulyje</li> <li>\u2705 Keli egzemplioriai</li> <li>\u2705 Funkcijos dirba su pointer'iais</li> <li>\u2705 Pakartotinis naudojimas</li> </ul> Problemos, pavojai... <ul> <li>Strukt\u016bros nariai VIE\u0160I: Header'yje matoma visa strukt\u016bros anatomija</li> <li>Galima tiesiogin\u0117 manipuliacija: <code>st.top = 999;</code></li> <li>Encapsulation \u2260 Information hiding!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-ataka-pavyksta","title":"2 sprendimas: Ataka pavyksta","text":"<p><code>06_ENCAPSULATING_UDT_in_Module/02_OK_Attack</code></p> <p>sumanymas/ketinimas</p> <p>Pademonstruosiu, kad net ir modulinis UDT n\u0117ra saugus - \"attacker\" gali tiesiogiai keisti strukt\u016bros narius.</p> stack.hstack.cuser_attack.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.h <pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/stack.c <pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user_attack.c -o user_attack.o\ngcc stack.o user_attack.o -o app\n./app  # \u2705 bet rezultatas BLOGAS!\n</code></pre> <pre><code>HACKED!\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia-bet-blogai_1","title":"\u2705 Veikia, bet BLOGAI!","text":"Strukt\u016bros nariai prieinami <pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima manipuliuoti!\nst.stack[0] = 'X';  // \u2190 Galima keisti!\n</code></pre> <p>Encapsulation \u2260 Information hiding: - Encapsulation - duomenys + funkcijos kartu modulyje \u2705 - Information hiding - duomen\u0173 strukt\u016bra pasl\u0117pta \u274c</p> <p>Sprendimas \u2192 Etapas 07: Opaque pointer (forward declaration)</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_5","title":"\ud83d\udca1 Pamokos","text":"<p>Encapsulation vs Information Hiding</p> <ul> <li>Encapsulation: Duomenys + funkcijos kartu (struct + modulis)</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos nuo vartotojo</li> <li>Problema: Header'yje matoma <code>struct Stack { ... };</code> - nariai prieinami!</li> <li>Reikia: Opaque pointer - tik deklaracija, ne apibr\u0117\u017eimas!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#7etapas-stekas-paslaptis","title":"7\ufe0f\u20e3Etapas: \"Stekas-Paslaptis\"","text":"<p><code>07_HIDING_UDT_Information</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Information hiding - pasl\u0117pti strukt\u016bros detales nuo vartotojo. Naudoti opaque pointer (forward declaration).</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Panaudosime incomplete type - <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Suprasime forward declaration koncepcij\u0105</li> <li>I\u0161siai\u0161kinsime kod\u0117l reikalingi pointer'iai</li> <li>Pamatysime uninicializuot\u0173 pointer'i\u0173 problem\u0105</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-incomplete-type","title":"1 sprendimas: Incomplete type","text":"<p><code>07_HIDING_UDT_Information/01_NC</code></p> <p>sumanymas/ketinimas</p> <p>Perkelsiu strukt\u016bros apibr\u0117\u017eim\u0105 \u012f <code>stack.c</code>, o header'yje palikusiu tik deklaracij\u0105 - <code>struct Stack;</code> (forward declaration).</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/01_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;gcc stack.c user_attack.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\02_OK_Attack&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654\n2nd Stack is empty\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:7:19: error: storage size of 'st1' isn't known\nuser.c:7:25: error: storage size of 'st2' isn't known\n</code></pre> \u274c storage size isn't known</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nekompiliuojasi_1","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: Incomplete type - ne\u017einomas dydis <p>Problema: <code>user.c</code> bando sukurti <code>struct Stack st1, st2;</code> bet kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;  // Forward declaration - \"incomplete type\"\n\n// Bando sukurti:\nstruct Stack st1;  // \u274c sizeof(Stack) ne\u017einomas!\n</code></pre></p> <ul> <li>Incomplete type - kompiliatorius \u017eino kad tipas egzistuoja, bet ne\u017eino jo strukt\u016bros</li> <li>Negalima alokuoti stack'e - <code>sizeof()</code> ne\u017einomas</li> <li>Galima tik pointer'iai - <code>sizeof(pointer)</code> visada \u017einomas!</li> </ul> <p>Sprendimas: Naudoti pointer'ius - <code>struct Stack *pst1, *pst2;</code></p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#2-sprendimas-bandymas-su-malloc","title":"2 sprendimas: Bandymas su malloc","text":"<p><code>07_HIDING_UDT_Information/02_NC</code></p> <p>sumanymas/ketinimas</p> <p>Naudosiu pointer'ius ir <code>malloc()</code> - alokuosiu dinami\u0161kai, nes <code>sizeof()</code> ne\u017einomas kompiliavimo metu.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\u274c \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/02_NC/user_attack.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    //// ATTACK!\n    pst2-&gt;stack[pst2-&gt;top++] = '!';\n    ////\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\ngcc -c user_attack.c\n\nuser_attack.c: In function 'main':\nuser_attack.c:20:9: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |         ^~\nuser_attack.c:20:21: error: invalid use of undefined type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                     ^~\n*/\n\n/*\nclang -c user_attack.c\nuser_attack.c:20:9: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |     ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:20:21: error: incomplete definition of type 'struct Stack'\n   20 |     pst2-&gt;stack[pst2-&gt;top++] = '!';\n      |                 ~~~~^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u274c\n</code></pre> <pre><code>user.c:8:24: error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre> \u274c sizeof to incomplete type</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#nekompiliuojasi_2","title":"\u274c Nekompiliuojasi","text":"\ud83d\udd0d Diagnoz\u0117: sizeof() incomplete type <p>Problema: <code>user.c</code> bando <code>malloc(sizeof(struct Stack))</code> bet <code>sizeof()</code> reikia pilno tipo!</p> <p>Kod\u0117l: <pre><code>// user.c mato tik:\nstruct Stack;\n\n// Bando:\nmalloc(sizeof(struct Stack));  // \u274c sizeof ne\u017einomas!\n</code></pre></p> <ul> <li><code>malloc()</code> reikia dyd\u017eio - kiek bait\u0173 alokuoti</li> <li><code>sizeof()</code> reikia pilno tipo - incomplete type nepakanka</li> <li>Vartotojas negali alokuoti pats!</li> </ul> <p>Sprendimas: Reikia factory funkcijos modulyje - <code>create()</code> kuris \u017eino <code>sizeof()</code></p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#3-sprendimas-neininicializuotos-rodykles","title":"3 sprendimas: Neininicializuotos rodykl\u0117s","text":"<p><code>07_HIDING_UDT_Information/03_RT</code></p> <p>sumanymas/ketinimas</p> <p>Pabandysiu su pointer'iais be alokavimo - gal veiks?</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\udca5 \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/stack.c <pre><code>#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 07_HIDING_UDT_Information/03_RT/user.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> <p><pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app  # \ud83d\udca5\n</code></pre> <pre><code>Segmentation fault (core dumped)\n</code></pre> \ud83d\udca5 Runtime crash!</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#kompiliuojasi-ir-linkuojasi-bet-crash","title":"\u2705 Kompiliuojasi ir linkuojasi, bet CRASH!","text":"\ud83d\udd0d Diagnoz\u0117: Uninitialized pointers <p>Problema: Runtime crash - segmentation fault!</p> <p>Kod\u0117l: <pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos rodykl\u0117s!\ninit(pst1);  // \ud83d\udca5 pst1 rodo \u012f niekur (garbage value)\n</code></pre></p> <ul> <li>Pointer'iai neininicializuoti - turi atsitiktines reik\u0161mes</li> <li>Dereferencing random adreso \u2192 segmentation fault</li> <li>N\u0117ra atminties - pointer'ius turi rodyti \u012f galiojan\u010di\u0105 atmint\u012f!</li> </ul> <p>Sprendimas \u2192 Etapas 08: Factory pattern - <code>create()</code> funkcija, kuri: - Alokuoja atmint\u012f su <code>malloc()</code> - Inicializuoja strukt\u016br\u0105 - Gr\u0105\u017eina valid\u0173 pointer'\u012f</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_6","title":"\ud83d\udca1 Pamokos","text":"<p>Opaque Pointer Pattern</p> <ul> <li>Forward declaration: <code>struct Stack;</code> be apibr\u0117\u017eimo</li> <li>Incomplete type: Kompiliatorius \u017eino vard\u0105, bet ne strukt\u016br\u0105</li> <li>Negalima: <code>struct Stack st;</code> - ne\u017einomas <code>sizeof()</code></li> <li>Galima: <code>struct Stack *pst;</code> - pointer'io dydis \u017einomas</li> <li>Problema: Vartotojas negali alokuoti - reikia factory!</li> <li>Information hiding: Strukt\u016bros detal\u0117s pasl\u0117ptos \u2705</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#8etapas-stekas-fabrikas","title":"8\ufe0f\u20e3Etapas: \"Stekas-Fabrikas\"","text":"<p><code>08_Acquiring_RESOURCES</code></p> <p>\ud83c\udfaf Tikslas</p> <p>Factory pattern - sukurti <code>create()</code> ir <code>destroy()</code> funkcijas, kurios valdo objekt\u0173 lifecycle - k\u016brim\u0105 ir naikinim\u0105.</p> <p>\ud83d\udd0d K\u0105 darysime</p> <ul> <li>Sukursime <code>create()</code> - alokuoja ir inicializuoja</li> <li>Sukursime <code>destroy()</code> - atlaisvina atmint\u012f</li> <li>Suprasime resource acquisition ir cleanup svarb\u0105</li> <li>Pamatysime manual lifecycle management C kalboje</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-factory-pattern","title":"1 sprendimas: Factory pattern","text":"<p><code>08_Acquiring_RESOURCES/02_OK</code></p> <p>sumanymas/ketinimas</p> <p>Sukursiu factory funkcijas modulyje: <code>create()</code> alokuos ir inicializuos, <code>destroy()</code> atlaisvins atmint\u012f. Vartotojas tur\u0117s validius pointer'ius!</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 08_Acquiring_RESOURCES/02_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#veikia_1","title":"\u2705 Veikia!","text":"Factory pattern veikia! <pre><code>// K\u016brimas (acquisition)\nstruct Stack *pst1 = create();\n\n// Naudojimas\npush(pst1, '1');\nchar c = pop(pst1);\n\n// Naikinimas (cleanup)\ndestroy(pst1);\n</code></pre> <p>Privalumai: - \u2705 Dinamin\u0117 alokacija - <code>malloc()</code> modulyje - \u2705 Inicializacija - <code>create()</code> u\u017etikrina teising\u0105 b\u016bsen\u0105 - \u2705 Cleanup - <code>destroy()</code> atlaisvina atmint\u012f - \u2705 Keli egzemplioriai - kiek tik reikia! - \u2705 Information hiding - strukt\u016bra pasl\u0117pta</p> Problemos, pavojai... <ul> <li>Manual lifecycle: Vartotojas turi prisiminti <code>destroy()</code></li> <li>Memory leak: U\u017emir\u0161us <code>destroy()</code> - memory leak</li> <li>Dangling pointer: Po <code>destroy()</code> pointer'is invalid</li> <li>Double free: Du kartus <code>destroy()</code> - undefined behavior</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_7","title":"\ud83d\udca1 Pamokos","text":"<p>Factory Pattern &amp; Resource Management</p> <ul> <li><code>create()</code> - alokuoja + inicializuoja \u2192 acquisition</li> <li><code>destroy()</code> - atlaisvina \u2192 cleanup</li> <li>Manual lifecycle: Vartotojas atsakingas u\u017e <code>destroy()</code></li> <li>C++ evoliucija: Konstruktorius + destruktorius automati\u0161kai!</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#9etapas-pilnas-adt","title":"9\ufe0f\u20e3Etapas: \"Pilnas ADT\"","text":"<p><code>09_Completing_LIFECYCLE</code></p> <p>\ud83c\udfaf Tikslas</p> <p>U\u017ebaigti piln\u0105 ADT C kalboje - prid\u0117ti visas lifecycle funkcijas, error handling, ir pasiekti maksimal\u0173 abstrakcijos lyg\u012f.</p> <p>\ud83d\udd0d K\u0105 pasiek\u0117me</p> <ul> <li>\u2705 Information hiding - opaque pointer</li> <li>\u2705 Encapsulation - duomenys + funkcijos modulyje</li> <li>\u2705 Multiple instances - kiek tik reikia stek\u0173</li> <li>\u2705 Factory pattern - <code>create()</code> / <code>destroy()</code></li> <li>\u2705 Pilnas lifecycle - acquisition \u2192 usage \u2192 cleanup</li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#1-sprendimas-pilnas-c-adt","title":"1 sprendimas: Pilnas C ADT","text":"<p><code>09_Completing_LIFECYCLE/01_OK</code></p> <p>sumanymas/ketinimas</p> <p>Apibendrinsiu visk\u0105 - prid\u0117siu visas reikalingas funkcijas pilnam ADT funkcionavimui.</p> stack.hstack.cuser.c\ud83d\udd28 = \u2699\ufe0f\u2794\ud83d\udd17\u2794\ud83d\ude80\u2328\ufe0f\u2794\ud83d\udda5\ufe0f \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.h <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/stack.c <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> \ud83d\udcc4 09_Completing_LIFECYCLE/01_OK/user.c <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> <pre><code>gcc -c stack.c -o stack.o  # \u2705\ngcc -c user.c -o user.o    # \u2705\ngcc stack.o user.o -o app  # \u2705\n./app\n</code></pre> <pre><code>123\n321\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pilnas-c-adt","title":"\u2705 Pilnas C ADT!","text":"Visi ADT reikalavimai \u012fvykdyti! <p>ADT principai C kalboje:</p> <ol> <li>\u2705 Information hiding - strukt\u016bra pasl\u0117pta (opaque pointer)</li> <li>\u2705 Encapsulation - duomenys + operacijos modulyje</li> <li>\u2705 Multiple instances - <code>struct Stack *pst1, *pst2, ...;</code></li> <li>\u2705 Lifecycle management - <code>create()</code> \u2192 use \u2192 <code>destroy()</code></li> <li>\u2705 Factory pattern - kontroliuota k\u016brimas/naikinimas</li> </ol> <p>Pilnas ADT API: <pre><code>struct Stack *create();        // Acquisition\nvoid init(struct Stack *pst);  // Initialization\nvoid push(struct Stack *pst, char c);\nchar pop(struct Stack *pst);\nint isEmpty(struct Stack *pst);\nint isFull(struct Stack *pst);\nvoid destroy(struct Stack *pst);  // Cleanup\n</code></pre></p> C kalbos ribotumai <ul> <li>Manual lifecycle: Reikia prisiminti <code>destroy()</code></li> <li>No automatic cleanup: U\u017emir\u0161us - memory leak</li> <li>Syntax: <code>push(pst, 'a')</code> vietoj <code>pst-&gt;push('a')</code></li> <li>No operator overloading: Negalima <code>pst1 = pst2;</code></li> </ul>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#pamokos_8","title":"\ud83d\udca1 Pamokos","text":"<p>C ADT \u2192 C++ Class Evolution</p> <p>C kalboje pasiek\u0117me: - \u2705 Information hiding - \u2705 Encapsulation - \u2705 Factory pattern - \u2705 Manual lifecycle management</p> <p>C++ prideda: - \ud83d\ude80 Konstruktorius - automatic <code>create()</code> - \ud83d\ude80 Destruktorius - automatic <code>destroy()</code> - \ud83d\ude80 Method syntax - <code>s.push('a')</code> - \ud83d\ude80 Operator overloading - <code>s1 = s2;</code> - \ud83d\ude80 RAII - Resource Acquisition Is Initialization</p>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#evoliucijos-santrauka","title":"\ud83c\udfaf Evoliucijos santrauka","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai Sprendim\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis + extern 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> linkage 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#suolis-i-c","title":"\ud83d\ude80 \u0160uolis \u012f C++","text":""},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\nchar c = pop(s);\ndestroy(s);  // \u2190 Reikia prisiminti!\n</code></pre>"},{"location":"Paskaitos/01_Paskaita_TRULY_FINAL/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius (automatic create)\ns.push('a');          // Method syntax\nchar c = s.pop();\n// Destruktorius automati\u0161kai (automatic destroy)\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Paskaitos/lecture_02_decomposing/","title":"Etapas 02: Decomposing to UNITS","text":""},{"location":"Paskaitos/lecture_02_decomposing/#nuo-monolito-iki-fizinio-padalijimo","title":"Nuo monolito iki fizinio padalijimo","text":"<p>\u0160io etapo tikslas</p> <p>I\u0161mokti fizi\u0161kai atskirti program\u0105 \u012f kompiliavimo vienetus, suprasti <code>#include</code> mechanizm\u0105 ir patirti tipines kompiliavimo/linkavimo klaidas kaip mokymosi \u012frank\u012f. Studentai patiria \"per nagus\", kod\u0117l reikia header fail\u0173.</p>"},{"location":"Paskaitos/lecture_02_decomposing/#problema-kuria-sprendziame","title":"Problema, kuri\u0105 sprend\u017eiame","text":"<p>Etape 01 tur\u0117jome monolitin\u012f fail\u0105 - visa logika vienoje vietoje. Tai veik\u0117 ir net tur\u0117jo privalum\u0173: gal\u0117jome ra\u0161yti <code>main()</code> funkcij\u0173 prie\u0161 stack funkcijas, nes kompiliatorius mat\u0117 visk\u0105 i\u0161 karto. Bet kai projektas auga, monolitas tampa neprie\u017ei\u016brimu.</p> <p>D\u0117stytojas papra\u0161o: \"Atskirkit stack logik\u0105 \u012f atskir\u0105 fail\u0105, kad gal\u0117tum\u0117te naudoti keliuose projektuose!\"</p> <p>Student\u0173 kelion\u0117: Trys bandymai, trys skirtingos klaidos, viena pamoka.</p>"},{"location":"Paskaitos/lecture_02_decomposing/#struktura","title":"Strukt\u016bra","text":"<pre><code>02_Decomposing_to_UNITS/\n\u251c\u2500\u2500 01_NC/              # Not Compiling - implicit declarations\n\u2502   \u251c\u2500\u2500 stack.c         \n\u2502   \u2514\u2500\u2500 user.c          \n\u251c\u2500\u2500 02_NL/              # Not Linking - multiple definition\n\u2502   \u251c\u2500\u2500 stack.c         \n\u2502   \u2514\u2500\u2500 user.c          \n\u2514\u2500\u2500 03_OK_Wrong/        # Veikia, bet antipattern\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#zingsnis-1-naivus-atskyrimas-01_nc","title":"\u017dingsnis 1: Naivus atskyrimas (01_NC)","text":"<p>Studentas tiesiog \"supjaudo\" monolit\u0105 \u012f du failus ir bando kompiliuoti atskirai, kaip d\u0117stytojas pra\u0161\u0117.</p> stack.cuser.cBandymas kompiliuoti stack.c<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> user.c<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <pre><code>gcc -c stack.c    # \u2705 Veikia\ngcc -c user.c     # \u2753 Kas nutiks?\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#kas-nutinka","title":"Kas nutinka?","text":"<p>Priklausomai nuo kompiliatoriaus:</p> GCC (Warning)Clang (Error) <pre><code>$ gcc -c user.c\nuser.c: In function 'main':\nuser.c:6:5: warning: implicit declaration of function 'init'\nuser.c:7:37: warning: implicit declaration of function 'push'\nuser.c:8:13: warning: implicit declaration of function 'isEmpty'\nuser.c:8:32: warning: implicit declaration of function 'pop'\n</code></pre> <p>\u26a0\ufe0f Kompiliuojasi su \u012fsp\u0117jimais - GCC \"atleid\u017eia\" studentui</p> <pre><code>$ clang -c user.c\nuser.c:6:5: error: call to undeclared function 'init'; \nISO C99 and later do not support implicit function declarations\nuser.c:7:37: error: call to undeclared function 'push'\nuser.c:8:13: error: call to undeclared function 'isEmpty'\nuser.c:8:32: error: call to undeclared function 'pop'\n4 errors generated.\n</code></pre> <p>\u274c Kompiliavimas nepavyksta!</p> Diagnoz\u0117: Monolito vs moduli\u0173 skirtumas <p>Monolite (01 etapas): <pre><code>// Viskas viename faile - kompiliatorius mato VISK\u0104\nint main(void) {\n    push('a');  // \u2705 Kompiliatorius \u017eino, kad push() bus \u017eemiau\n}\n\nvoid push(char c) { ... }  // Apibr\u0117\u017eimas \u017eemiau\n</code></pre></p> <p>Moduliuose (dabar): <pre><code>// user.c - kompiliatorius mato TIK \u0160\u012e fail\u0105!\nint main(void) {\n    push('a');  // \u274c Kas tas push? Niekur nedeklaruotas!\n}\n// stack.c yra KITAME faile - kompiliatorius nemato!\n</code></pre></p> <p>Pamoka: Kiekvienas <code>.c</code> failas kompiliuojamas atskirai. Funkcijos turi b\u016bti deklaruotos prie\u0161 naudojim\u0105 (arba apibr\u0117\u017etos auk\u0161\u010diau faile).</p> Kod\u0117l GCC leid\u017eia, o Clang - ne? <p>C89/C90 standartas: Leido implicit function declarations - jei funkcija nedeklaruota, kompiliatorius priskirdavo default signat\u016br\u0105 <code>int func()</code>.</p> <p>C99+ standartas: Nebeleid\u017eia implicit declarations - b\u016btina ai\u0161ki deklaracija.</p> <ul> <li>GCC: D\u0117l backward compatibility default re\u017eimas toleruoja (warning)</li> <li>Clang: Grie\u017etai laikosi modernaus standarto (error)</li> </ul> <p>I\u0161vada: Visada ra\u0161ykite prototipus! Naudokite <code>gcc -std=c11 -Werror</code> arba testuokite su Clang.</p>"},{"location":"Paskaitos/lecture_02_decomposing/#zingsnis-2-logiska-ideja-include-stackc-02_nl","title":"\u017dingsnis 2: \"Logi\u0161ka\" id\u0117ja - #include \"stack.c\" (02_NL)","text":"<p>Studentas pam\u0105sto: \"Aha! Monolite viskas veik\u0117, nes buvo kartu. Tai tiesiog sujungsiu failus su <code>#include</code>!\"</p> <p>Ir vis tiek kompiliuoja atskirai, kaip d\u0117stytojas mok\u0117:</p> stack.cuser.cKompiliavimas stack.c (nepakeistas)<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> user.c (su #include)<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <p>\ud83d\udca1 Studentas m\u0105sto: \"Dabar <code>user.c</code> \u017einos apie stack funkcijas!\"</p> <pre><code>gcc -c stack.c -o stack.o   # \u2705 Sukuria stack.o\ngcc -c user.c -o user.o     # \u2705 Sukuria user.o (su stack.c viduje!)\ngcc stack.o user.o -o app   # \u2753 Linkavimas...\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#kas-nutinka_1","title":"Kas nutinka?","text":"<p>Linkavimo klaida (NL):</p> <pre><code>/usr/bin/ld: user.o: in function `push':\nuser.c:(.text+0x0): multiple definition of `push'; \nstack.o:stack.c:(.text+0x0): first defined here\n\n/usr/bin/ld: user.o: in function `pop':\nuser.c:(.text+0x10): multiple definition of `pop'; \nstack.o:stack.c:(.text+0x10): first defined here\n\n... (ir t.t. visoms funkcijoms)\n</code></pre> Diagnoz\u0117: Dviguba kompiliacija <p>Kas \u012fvyko:</p> <ol> <li><code>gcc -c stack.c</code> \u2192 sukuria <code>stack.o</code> su push(), pop(), ...</li> <li><code>gcc -c user.c</code> \u2192 preprocesoras \u012fklijuoja stack.c turin\u012f \u2192 sukuria <code>user.o</code> IRGI su push(), pop(), ...</li> <li>Linkavimas: 2 objektiniai failai, abiejuose tos pa\u010dios funkcijos \u2192 multiple definition!</li> </ol> <p>Vizualizacija: <pre><code>stack.o:  push() pop() init() isEmpty()\nuser.o:   push() pop() init() isEmpty() main()  \u2190 Dubliavimasis!\n          ^^^^^ ^^^^^ ^^^^^^ ^^^^^^^^^\n</code></pre></p> <p>Pamoka: <code>#include \"*.c\"</code> dubliuoja kod\u0105. Preprocesoras tiesiog copy-paste daro!</p> Kod\u0117l monolite veik\u0117? <p>Monolite buvo vienas kompiliavimo vienetas: <pre><code>gcc stack_monolith.c -o app  # Vienas .c \u2192 vienas .o \u2192 vienas binary\n</code></pre></p> <p>Dabar yra du kompiliavimo vienetai, kurie linkuojami kartu: <pre><code>gcc -c stack.c    # Pirmas .o\ngcc -c user.c     # Antras .o (su stack.c viduje!)\ngcc *.o           # Abu jungiami \u2192 conflict!\n</code></pre></p> stack.cuser.cKompiliavimas stack.c<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#kas-nutinka_2","title":"Kas nutinka?","text":"<pre><code>/usr/bin/ld: user.o:(.bss+0x0): multiple definition of `stack'; \nstack.o:(.bss+0x0): first defined here\n/usr/bin/ld: user.o:(.bss+0x0): multiple definition of `top'; \nstack.o:(.bss+0x0): first defined here\n</code></pre> <p>Linkavimo klaida (NL)! Kod\u0117l?</p> Diagnoz\u0117: Funkcij\u0173 deklaracijos prototipai \u2260 kintam\u0173j\u0173 deklaracijos <p>Funkcijoms: <pre><code>void push(char c);  // \u2705 Deklaracija (prototipas)\n</code></pre></p> <p>Kintamiesiems globaliam apimties lygyje: <pre><code>char stack[STACK_SIZE];  // \u274c Apibr\u0117\u017eimas (definition)!\nint  top = 0;            // \u274c Apibr\u0117\u017eimas!\n</code></pre></p> <p>Problema: Kintamieji abiejuose failuose tampa apibr\u0117\u017eimais, tod\u0117l linkeris mato dubliavim\u0105si (multiple definition).</p>"},{"location":"Paskaitos/lecture_02_decomposing/#zingsnis-3-antipattern-su-include-03_ok_wrong","title":"\u017dingsnis 3: Antipattern su #include (03_OK_Wrong)","text":"<p>Studentai da\u017enai bando \"i\u0161spr\u0119sti\" tiesiog \u012ftraukdami <code>stack.c</code> \u012f <code>user.c</code>:</p>"},{"location":"Paskaitos/lecture_02_decomposing/#zingsnis-3-zingsnis-atgal-tik-userc-03_ok_wrong","title":"\u017dingsnis 3: \"\u017dingsnis atgal\" - tik user.c (03_OK_Wrong)","text":"<p>Studentas sumi\u0161\u0119s: \"Per daug sud\u0117tinga... Gal u\u017etenka kompiliuoti tik <code>user.c</code>?\"</p> stack.cuser.cKompiliavimas stack.c (tas pats)<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> user.c (su #include)<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705 VEIKIA!\n./app\n12345\n54321\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#kodel-veikia","title":"Kod\u0117l veikia?","text":"<p>Dabar <code>gcc user.c</code> sukuria vien\u0105 objektin\u012f fail\u0105 su viskuo: - Preprocesoras \u012fklijuoja <code>stack.c</code> turin\u012f \u012f <code>user.c</code> - Kompiliuojamas vienas didelis failas - N\u0117ra linkavimo \u2192 n\u0117ra konflikt\u0173!</p> Kas i\u0161 tikr\u0173j\u0173 kompiliuojama <p>Preprocesoriaus i\u0161vestis (<code>gcc -E user.c</code>): <pre><code>// ... stdio.h turinys ...\n\n// \u2193 \u010cia \u012fklijuotas stack.c\n#define STACK_SIZE 10\nchar stack[STACK_SIZE];\nint top = 0;\nvoid init(void) { top = 0; }\nvoid push(char c) { ... }\nchar pop(void) { ... }\nint isEmpty(void) { ... }\n\n// \u2193 Originalus user.c\nint main(void) {\n    init();\n    // ...\n}\n</code></pre></p> <p>Vienas failas \u2192 vienas .o \u2192 veikia!</p>"},{"location":"Paskaitos/lecture_02_decomposing/#kodel-tai-blogai-antipattern","title":"Kod\u0117l tai BLOGAI (antipattern)?","text":"<p>1. N\u0117ra tikro padalijimo</p> <p>Gr\u012f\u017eome prie monolito, tik per <code>#include</code> triuk\u0105.</p> <p>2. Negalima pakartotinio naudojimo</p> <p>Kas jei norime stack keliuose projektuose?</p> <pre><code>// project1/user1.c\n#include \"stack.c\"  // OK\n\n// project2/user2.c  \n#include \"stack.c\"  // OK\n\n// project3/main.c su user1.c IR user2.c?\n// user1.c: #include \"stack.c\"\n// user2.c: #include \"stack.c\"\n// \u2192 Multiple definition! \ud83d\udca5\n</code></pre> <p>3. Kompiliavimo laikas</p> <p>Kas kart\u0105 modifikavus <code>user.c</code> perkompiliuojamas ir stack.c, nors jis nepasikeit\u0117.</p> <p>4. Prie\u0161tarauja C filosofijai</p> <p><code>#include</code> skirtas deklaracijoms (.h), ne implementacijai (.c)!</p> Taisykl\u0117 <p>NIEKADA nera\u0161ykite: <pre><code>#include \"*.c\"  // \u274c BLOGAI\n</code></pre></p> <p>Visada ra\u0161ykite: <pre><code>#include \"*.h\"  // \u2705 GERAI\n</code></pre></p>"},{"location":"Paskaitos/lecture_02_decomposing/#kodel-reikalingi-h-failai","title":"Kod\u0117l reikalingi .h failai?","text":""},{"location":"Paskaitos/lecture_02_decomposing/#problema-kuria-patyreme","title":"Problema, kuri\u0105 patyr\u0117me","text":"<pre><code>01_NC \u2192 Kompiliatorius nemato funkcij\u0173 (tr\u016bksta deklaracij\u0173)\n02_NL \u2192 #include \"stack.c\" dubliuoja visk\u0105 (multiple definition)\n03_OK_Wrong \u2192 Veikia, bet negalima pakartotinai naudoti\n</code></pre>"},{"location":"Paskaitos/lecture_02_decomposing/#klausimas-kuris-turetu-kilti","title":"Klausimas, kuris tur\u0117t\u0173 kilti","text":"<p>Kaip pakartotinai naudoti stack keliuose projektuose?</p> <p>Tarkime, turime 3 projektus, visi nori stack:</p> <pre><code>project1/\n\u251c\u2500\u2500 user1.c     # Nori stack\n\u2514\u2500\u2500 stack.c\n\nproject2/\n\u251c\u2500\u2500 user2.c     # Nori stack  \n\u2514\u2500\u2500 stack.c     # \u2190 Kopija!\n\nproject3/\n\u251c\u2500\u2500 main.c      # Nori stack\n\u251c\u2500\u2500 helper.c    # Ir \u010dia nori!\n\u2514\u2500\u2500 stack.c     # \u2190 Dar viena kopija!\n</code></pre> <p>Problemos: - Kopijuojame stack.c \u2192 pri\u017ei\u016br\u0117jimo ko\u0161maras (bug fix reikia 3 vietose) - Arba <code>#include \"stack.c\"</code> \u2192 02_NL klaida, jei keli failai linkuojami - Prototipus kopijuojame rankiniu b\u016bdu \u2192 pakeit\u0117 signat\u016br\u0105? Taisyk visur!</p>"},{"location":"Paskaitos/lecture_02_decomposing/#sprendimas-atskirkime-ka-nuo-kaip","title":"Sprendimas: Atskirkime \"K\u0104\" nuo \"KAIP\"","text":"<p>Esm\u0117: Reikia atskirti interface (k\u0105 galima daryti) nuo implementation (kaip tai padaryta).</p> Analogija: Restoranas <p>Meniu (= .h failas): - Parodo k\u0105 galima u\u017esisakyti - Klientas (user.c) mato tik meniu - Lengvai kopijuojamas (daug kopij\u0173 nesukelia problem\u0173)</p> <p>Virtuv\u0117 (= .c failas): - \u017dino kaip pagaminti patiekalus - Klientas nemato virykl\u0117s detali\u0173 - Viena virtuv\u0117 aptarnauja daug klient\u0173</p> <p>Blogai b\u016bt\u0173: - Kiekvienas klientas turi savo virtuv\u0119 (03_OK_Wrong su <code>#include \"stack.c\"</code>) - Klientas turi \u017einoti receptus (01_NC be deklaracij\u0173)</p>"},{"location":"Paskaitos/lecture_02_decomposing/#prototipu-dubliavimosi-problema","title":"Prototip\u0173 dubliavimosi problema","text":"<p>Be .h failo (dabar):</p> <pre><code>// user1.c\nvoid push(char);  // \u2190 Copy-paste\nchar pop(void);   // \u2190 Copy-paste\n\n// user2.c  \nvoid push(char);  // \u2190 Copy-paste\nchar pop(void);   // \u2190 Copy-paste\n\n// stack.c\nvoid push(char c) { ... }  // Tikras apibr\u0117\u017eimas\nchar pop(void) { ... }\n</code></pre> <p>Pakeit\u0117te <code>push(char c)</code> \u2192 <code>push(int c)</code>? Taisyti reikia 4 vietose: stack.c + user1.c + user2.c + user3.c!</p> <p>Su .h failu (Etapas 03):</p> <pre><code>// stack.h (header)\nvoid push(int);   // \u2190 Viena vieta!\nchar pop(void);\n\n// user1.c, user2.c, user3.c\n#include \"stack.h\"  // Automati\u0161kai gauna naujausi\u0105 versij\u0105\n\n// stack.c\n#include \"stack.h\"  // Ir implementacija naudoja t\u0105 pat\u012f\nvoid push(int c) { ... }\n</code></pre> <p>Pakeit\u0117te signat\u016br\u0105? Taisote 1 viet\u0105 (stack.h)!</p>"},{"location":"Paskaitos/lecture_02_decomposing/#nuo-ko-pradeti-mokytis-h","title":"Nuo ko prad\u0117ti mokytis .h?","text":"<p>Header failas n\u0117ra baisus!</p> <p>Kas bus header faile? Papras\u010diausiai tai, k\u0105 jau ra\u0161\u0117me:</p> <pre><code>// stack.h - tai tik prototipai!\nvoid push(char);\nchar pop(void);\nint isEmpty(void);\n</code></pre> <p>Vienintelis skirtumas: Dabar tai atskirame faile, kur\u012f galima <code>#include</code> daug kart\u0173.</p> <p>Bonus: Prid\u0117sime \"apsaugas\" (<code>#ifndef</code>), kad neb\u016bt\u0173 dubliavimo, jei failas \u012ftraukiamas kelis kartus.</p>"},{"location":"Paskaitos/lecture_02_decomposing/#teisingas-kelias-etapas-03","title":"Teisingas kelias \u2192 Etapas 03","text":"<p>Etape 03: Discovering C MODULE i\u0161moksime sukurti tikr\u0105 C modul\u012f su header failu, ir pamir\u0161kite baim\u0119 - header failas yra papras\u010diau nei atrodo!</p>"},{"location":"Paskaitos/lecture_02_decomposing/#mokymosi-rezultatai","title":"Mokymosi rezultatai","text":"<p>Po \u0161io etapo studentai:</p> <p>Techni\u0161kai supranta: - Kompiliavimo vieneto (translation unit) koncepcij\u0105 - Skirtum\u0105 tarp monolito ir moduli\u0173 (funkcij\u0173 eili\u0161kumas) - Kompiliatori\u0173 skirtumus (GCC vs Clang, implicit declarations) - Linkavimo proceso esm\u0119 (kas yra multiple definition) - Preprocesoriaus darb\u0105 (<code>#include</code> = copy-paste)</p> <p>\"Per nagus\" patyr\u0117: - 01_NC \u2192 Implicit declarations (GCC toleruoja, Clang - ne) - 02_NL \u2192 Dubliavim\u0105si (<code>#include \"*.c\"</code> + atskira kompiliacija) - 03_OK_Wrong \u2192 Antipattern, kuris veikia (bet nei\u0161sprend\u017eia problemos)</p> <p>Suvokia poreik\u012f: - Header fail\u0173 (.h) - ne i\u0161 teorijos, o i\u0161 praktikos - Interface/Implementation atskyrimo - Pakartotinio kodo naudojimo mechanizm\u0173</p> <p>Pamokos: - Kompiliavimo klaidos = mokymosi \u012frankis - <code>#include \"*.c\"</code> yra antipattern - Vieno kompiliatoriaus nepakanka (testuokite su GCC ir Clang) - Prototip\u0173 dubliavimas yra pri\u017ei\u016br\u0117jimo ko\u0161maras</p> Pedagoginis principas <p>Studentai neturi bijoti header fail\u0173, nes:</p> <ol> <li>Jau ra\u0161\u0117 prototipus (01_NC bandyme)</li> <li>Mato j\u0173 tr\u016bkumo problem\u0105 (02_NL dubliavim\u0105si)  </li> <li>Supranta pakartotinio naudojimo poreik\u012f (03_OK_Wrong ribotum\u0105)</li> </ol> <p>Header failas yra tiesiog atsakymas \u012f problemas, kurias patyr\u0117.</p> <p>Ne \"nauja magija\", o \"protingas sprendimas\".</p>"},{"location":"Paskaitos/lecture_02_decomposing/#kitas-zingsnis","title":"Kitas \u017eingsnis","text":"<p>Etape 03: Discovering C MODULE i\u0161moksime sukurti header fail\u0105 (<code>stack.h</code>), naudoti <code>extern</code> raktinius \u017eod\u017eius, header guards (<code>#ifndef</code>), tikr\u0105 C modulio strukt\u016br\u0105.</p> README failai su detaliais paai\u0161kinimais <ul> <li>01_NC README</li> <li>02_NL README</li> <li>03_OK_Wrong README</li> </ul>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/","title":"Stack ADT Evoliucija C kalboje","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#9-etapu-kelione-nuo-monolito-iki-pilno-adt","title":"9 Etap\u0173 Kelion\u0117: Nuo Monolito iki Pilno ADT","text":"<p>\u0160ios kelion\u0117s tikslas</p> <p>Patirti nat\u016brali\u0105 Stack Abstract Data Type evoliucij\u0105 nuo papras\u010diausio monolito iki pilnai realizuoto ADT su lifecycle valdymu. Kiekvienas etapas sprend\u017eia ankstesnio problem\u0105, mokydamas \"per nagus\" - ne i\u0161 teorijos, o i\u0161 praktikos. Kompiliavimo ir linkavimo klaidos yra mokymosi \u012frankis, ne problema kuri\u0105 reikia sl\u0117pti.</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-01-running-program","title":"Etapas 01: Running PROGRAM","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#monolitas-viskas-viename-faile","title":"Monolitas - viskas viename faile","text":"<p>Pradedame nuo papras\u010diausio sprendimo - vienas failas, visa logika kartu.</p> usestack.cKompiliavimas 01_Running_PROGRAM/01_OK_naive/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <pre><code>gcc usestack.c -o usestack\n./usestack\n</code></pre> <p>I\u0161vestis: <pre><code>123\n321\n</code></pre></p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#monolito-privalumai-ir-problemos","title":"Monolito privalumai ir problemos","text":"Privalumai <ul> <li>Funkcij\u0173 eili\u0161kumas nesvarbus: <code>main()</code> gali b\u016bti vir\u0161uje</li> <li>Kompiliatorius mato visk\u0105: Vienas kompiliavimo vienetas</li> <li>Paprastas build: Viena komanda</li> <li>Greitas prototipavimas: \u012edarbinimo pokalbio \"quick solution\"</li> </ul> Problemos <ul> <li>Global\u016bs kintamieji: <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas: Negalima tur\u0117ti keli\u0173</li> <li>Pakartotinis naudojimas: Kaip kitas projektas naudot\u0173?</li> <li>Pri\u017ei\u016br\u0117jimas: 1000+ eilu\u010di\u0173 viename faile</li> </ul>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-02-decomposing-to-units","title":"Etapas 02: Decomposing to UNITS","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#fizinis-padalijimas-per-nagus-mokymasis","title":"Fizinis padalijimas - \"per nagus\" mokymasis","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-naivus-atskyrimas-01_nc","title":"\u017dingsnis 1: Naivus atskyrimas (01_NC)","text":"<p>Student\u0173 mintis: \"Tiesiog supjaus\u010diau \u012f du failus!\"</p> stack.cuser.cGCC (warning)Clang (error) 02_Decomposing_to_UNITS/01_NC/stack.c<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 02_Decomposing_to_UNITS/01_NC/user.c<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n\n    init();\n    while ('\\n' != (c = getchar())) push(c);\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n\n// gcc -c stack.c\n// gcc -c user.c\n// gcc stack.o user.o -o app\n</code></pre> <p><pre><code>$ gcc -c user.c\nwarning: implicit declaration of function 'init'\nwarning: implicit declaration of function 'push'\n</code></pre> \u26a0\ufe0f Kompiliuojasi su warnings</p> <p><pre><code>$ clang -c user.c\nerror: call to undeclared function 'init'\n4 errors generated.\n</code></pre> \u274c Nepavyksta!</p> Monolito vs moduli\u0173 skirtumas <p>Monolite: kompiliatorius mato vis\u0105 fail\u0105 Moduliuose: kiekvienas <code>.c</code> = atskiras vienetas, reikia deklaracij\u0173</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-2-logiska-ideja-02_nl","title":"\u017dingsnis 2: \"Logi\u0161ka\" id\u0117ja (02_NL)","text":"<p>Student\u0173 mintis: \"Sujungsiu su <code>#include \"stack.c\"</code>!\"</p> stack.cuser.cLinkavimo klaida 02_Decomposing_to_UNITS/02_NL/stack.c<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 02_Decomposing_to_UNITS/02_NL/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\ngcc stack.o user.o -o app\n</code></pre> <p><pre><code>multiple definition of `push'\nmultiple definition of `pop'\n</code></pre> \ud83d\udca5 Dubliavimasis!</p> Preprocesoriaus copy-paste <p><code>#include \"stack.c\"</code> \u012fklijuoja turin\u012f \u2192 abi funkcijos abiejuose <code>.o</code> failuose</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-3-zingsnis-atgal-03_ok_wrong","title":"\u017dingsnis 3: \"\u017dingsnis atgal\" (03_OK_Wrong)","text":"<p>Student\u0173 mintis: \"Gal u\u017etenka tik user.c?\"</p> stack.cuser.cKompiliavimas 02_Decomposing_to_UNITS/03_OK_Wrong/stack.c<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 02_Decomposing_to_UNITS/03_OK_Wrong/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Patobuliname: Tik jei stekas neu\u017epildytas, skaitome simbolius iki '\\n' */\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> <pre><code>gcc user.c -o app  # \u2705 VEIKIA!\n</code></pre> Kod\u0117l BLOGAI (antipattern)? <ul> <li>Gr\u012f\u017eome prie monolito</li> <li>Negalimas pakartotinis naudojimas (keli failai \u2192 klaida)</li> <li><code>#include</code> skirtas <code>.h</code>, ne <code>.c</code></li> </ul>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-03-discovering-c-module","title":"Etapas 03: Discovering C MODULE","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#tikras-c-modulis-su-header-failu","title":"Tikras C modulis su header failu","text":"<p>Strukt\u016bra: 4 \u017eingsniai (prasideda nuo 02_NL).</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-header-be-extern-02_nl","title":"\u017dingsnis 1: Header be extern (02_NL)","text":"stack.hstack.cuser.c 03_Discovering_C_MODULE/02_NL/stack.h<pre><code>#define SIZE 100\n\nchar stack[SIZE];\nint top=0;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 03_Discovering_C_MODULE/02_NL/stack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\n// char stack[SIZE];\n// int top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/02_NL/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre> Linkavimo klaida: multiple definition <p>Kintamieji apibr\u0117\u017eti header'yje \u2192 abu failai sukuria kopijas</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-3-dar-viena-linkavimo-klaida-03_nl","title":"\u017dingsnis 3: Dar viena linkavimo klaida (03_NL)","text":"stack.hstack.cuser.c 03_Discovering_C_MODULE/03_NL/stack.h<pre><code>#define SIZE 100 // ?\n\nextern char stack[SIZE];\nextern int top;\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre> 03_Discovering_C_MODULE/03_NL/stack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/03_NL/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;gcc stack.c user.c -o use_stack\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/13.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:\\Users\\vikto\\AppData\\Local\\Temp\\cc51uPmo.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\03_nl_c&gt;clang stack.c user.c -o use_stack\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.stack[.refptr.stack]+0x0): undefined reference to `stack'\nC:/mingw64/bin/ld: C:/Users/vikto/AppData/Local/Temp/stack-5551ba.o:stack.c:(.rdata$.refptr.top[.refptr.top]+0x0): undefined reference to `top'\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n*/\n</code></pre> Dar viena NL klaida <p>Kitas bandymas, kita linkavimo problema</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-4-teisingas-modulis-04_ok","title":"\u017dingsnis 4: Teisingas modulis (04_OK)","text":"stack.hstack.cuser.c 03_Discovering_C_MODULE/04_OK/stack.h<pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> 03_Discovering_C_MODULE/04_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/04_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n    while (!isEmpty()) putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\04_ok&gt;use_stack.exe             \n123456\n54321\n*/\n</code></pre> Dabar teisingai! <ul> <li><code>extern</code> deklaracijos header'yje</li> <li>Apibr\u0117\u017eimai stack.c</li> <li>Tikras C modulis</li> </ul>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-5-ataka-pavyksta-05_ok_attack","title":"\u017dingsnis 5: Ataka pavyksta (05_OK_Attack)","text":"stack.hstack.cattacker.c 03_Discovering_C_MODULE/05_OK_Attack/stack.h<pre><code>// #define SIZE 100\n\n/* extern */ void init(void);\n/* extern */ int isEmpty(void);\n/* extern */ int isFull(void);\n/* extern */ void push(char c);\n/* extern */ char pop(void);\n</code></pre> 03_Discovering_C_MODULE/05_OK_Attack/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> 03_Discovering_C_MODULE/05_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[]; // +\nextern int top;      // +\n\nint main(void) {\n    char c;\n\n    init();\n    while ( (!isFull()) &amp;&amp; ('\\n' != (c = getchar())) ) push(c);\n\n    stack[top++] = '!'; // attack non-hiiden data\n\n    while (!isEmpty()) putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;gcc stack.c user.c -o use_stack\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\src\\evolution\\stack-2026\\03_header_mistakes\\05_ok_z&gt;use_stack.exe\n123456\n!54321\n*/\n</code></pre> Global\u016bs kintamieji vie\u0161i <p><pre><code>extern int top;\ntop = -1;  // \u2190 Galima manipuliuoti!\n</code></pre> Sprendimas \u2192 Etapas 04: <code>static</code> linkage</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-04-protecting-implementation","title":"Etapas 04: Protecting IMPLEMENTATION","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#information-hiding-su-static","title":"Information hiding su <code>static</code>","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-ataka-su-static-01_nl_attack","title":"\u017dingsnis 1: Ataka su static (01_NL_Attack)","text":"stack.h 04_Protecting_IMPLEMENTATION/01_NL_Attack/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> Problema: <code>extern</code> vis dar header'yje <p>Jei header'yje <code>extern</code>, bet <code>.c</code> faile <code>static</code> \u2192 konfliktas</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-2-tikras-information-hiding-02_ok","title":"\u017dingsnis 2: Tikras information hiding (02_OK)","text":"stack.hstack.c 04_Protecting_IMPLEMENTATION/02_OK/stack.h<pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre> 04_Protecting_IMPLEMENTATION/02_OK/stack.c<pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // !\nstatic int top;             // !\n\nstatic void reset(void) {   // !\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre> <code>static</code> linkage veikia! <p><pre><code>static char stack[STACK_SIZE];\nstatic int top = 0;\n</code></pre> Ataka dabar neveiks! Bet... tik vienas stekas.</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-05-defining-user-type","title":"Etapas 05: Defining USER TYPE","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#struct-monolite-greitas-entry-point","title":"Struct monolite - \"greitas entry point\"","text":"<p>Koncepcija: Gr\u012f\u017etame \u012f monolit\u0105, bet su struct - tarsi \u012fdarbinimo pokalbio \"quick solution\".</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-static-strukturoje-01_nc","title":"\u017dingsnis 1: static strukt\u016broje (01_NC)","text":"usestack.c 05_Defining_USER_TYPE/01_NC/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  static char stack[SIZE];\n  static int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc 05_nx_usestack.c -o 05_nx_usestack\n*/\n\n/*\n05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n*/\n\n/*\n\"expected specifier-qualifier-list\" yra sintaksin\u0117s analiz\u0117s klaida, kai kompiliatorius netik\u0117tai sutinka static strukt\u016bros nario deklaracijoje.\n\nC kalba draud\u017eia bet kokius storage-class specifikatorius (static, extern, auto, register) strukt\u016bros nariams.\n*/\n\n/*\nclang 05_nx_usestack.c -o 05_nx_usestack\n05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n05_nx_usestack.c:8:3: error: type name does not allow storage class to be specified\n    8 |   static int top;\n      |   ^\n2 errors generated.\n\n*/\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Neleid\u017eiama!\n};\n</code></pre> C draud\u017eia storage-class specifiers strukt\u016broje</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-2-pass-by-value-02_rt","title":"\u017dingsnis 2: Pass-by-value (02_RT)","text":"usestack.c 05_Defining_USER_TYPE/02_RT/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack st) {\n    st.top = 0;\n}\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    init(st1);\n\n    while ( (!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(st1,c);\n\n    while (!isEmpty(st1)) putchar(pop(st1));\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/*\ngcc usestack.c -o usestack\n*/\n\n/*\nusestack.exe\n123\n\n*/\n</code></pre> Runtime problema <pre><code>void init(struct Stack st) {  // Kopija!\n    st.top = 0;  // Kei\u010dia kopij\u0105, ne original\u0105\n}\n</code></pre>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-3-pass-by-pointer-03_ok","title":"\u017dingsnis 3: Pass-by-pointer (03_OK)","text":"usestack.c 05_Defining_USER_TYPE/03_OK/usestack.c<pre><code>#include &lt;stdio.h&gt;\n\n// ===&gt; stack dalis\n#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\n// ===&gt; user dalis\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n\n/*\ngcc 05_n_usestack.c -o 05_n_usestack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n*/\n</code></pre> Dabar veikia! <pre><code>void init(struct Stack *pst) {\n    pst-&gt;top = 0;  // Kei\u010dia original\u0105\n}\n\nstruct Stack st1, st2;  // Du stekai!\n</code></pre>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-06-encapsulating-udt-in-module","title":"Etapas 06: ENCAPSULATING UDT in Module","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#struct-modulis-apjungimas-ideju","title":"Struct + modulis = apjungimas id\u0117j\u0173","text":"<p>Koncepcija: Dabar struct modulyje - apjungiame 05 (struct) + 03 (modulis).</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-modulinis-udt-01_ok","title":"\u017dingsnis 1: Modulinis UDT (01_OK)","text":"stack.hstack.cuser.c 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/stack.c<pre><code>#include \"stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 06_ENCAPSULATING_UDT_in_Module/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n\n/*\n06_Encapsulating_UDT_in_MODULE\\01_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\06_Encapsulating_UDT_in_MODULE\\01_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-2-ataka-pavyksta-02_ok_attack","title":"\u017dingsnis 2: Ataka pavyksta (02_OK_Attack)","text":"user_attack.c 06_ENCAPSULATING_UDT_in_Module/02_OK_Attack/user_attack.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ( (!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st1,c);\n    while (!isEmpty(&amp;st1)) putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ( (!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(&amp;st2,c);\n    //// ATTACK!\n    st2.stack[st2.top++] = '!';\n    ////\n    while (!isEmpty(&amp;st2)) putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;gcc stack.c user_attack.c -o app\nuser_attack.c: In function 'main':\nuser_attack.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\nuser_attack.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n*/\n\n//// !!!!\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\07_HIDING_UDT_Information\\01_NC&gt;clang stack.c user_attack.c -o app\nuser_attack.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\nuser_attack.c:7:23: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                       ^\n./stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n2 errors generated.\n*/\n</code></pre> Strukt\u016bros nariai vie\u0161i <p><pre><code>struct Stack st;\nst.top = 999;  // \u2190 Galima!\n</code></pre> Encapsulation \u2260 Information hiding</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-07-hiding-udt-information","title":"Etapas 07: HIDING UDT Information","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#opaque-pointer-forward-declaration","title":"Opaque pointer - forward declaration","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-1-incomplete-type-01_nc","title":"\u017dingsnis 1: Incomplete type (01_NC)","text":"stack.h 07_HIDING_UDT_Information/01_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack; // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Kompiliavimo klaida <p><pre><code>struct Stack st;  // \u274c Incomplete type\n</code></pre> Kompiliatorius ne\u017eino sizeof(Stack)</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-2-bandymas-su-malloc-02_nc","title":"\u017dingsnis 2: Bandymas su malloc (02_NC)","text":"stack.h 07_HIDING_UDT_Information/02_NC/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> Linkavimo klaida <p>Grei\u010diausiai problema su funkcij\u0173 deklaracijomis</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#zingsnis-3-neininicializuotos-rodykles-03_rt","title":"\u017dingsnis 3: Neininicializuotos rodykl\u0117s (03_RT)","text":"stack.huser.c 07_HIDING_UDT_Information/03_RT/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 07_HIDING_UDT_Information/03_RT/user.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2; // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\n*/\n</code></pre> Segmentation fault <p><pre><code>struct Stack *pst1, *pst2;  // Neininicializuotos!\ninit(pst1);  // \ud83d\udca5 Crash\n</code></pre> Sprendimas \u2192 Etapas 08: Factory pattern</p>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-08-acquiring-resources","title":"Etapas 08: Acquiring RESOURCES","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#factory-pattern-create-destroy","title":"Factory pattern - create() / destroy()","text":"stack.hstack.cuser.c 08_Acquiring_RESOURCES/02_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\nstruct Stack* create(void); // !\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 08_Acquiring_RESOURCES/02_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) { //// !!!!\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 08_Acquiring_RESOURCES/02_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1, *pst2;\n\n    pst1 = create();\n    pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    return 0;\n}\n\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;gcc stack.c user.c -o app\n\nC:\\Repos\\Github\\ViktorasGolubevas\\cpp2026-test\\code\\evolution\\stack-2026\\08_Acquiring_RESOURCES\\02_OK&gt;app.exe\nInput 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n*/\n</code></pre> Factory pattern veikia! <pre><code>struct Stack *pst1 = create();\n// ... naudojimas ...\ndestroy(pst1);\n</code></pre>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#etapas-09-completing-lifecycle","title":"Etapas 09: Completing LIFECYCLE","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#pilnas-lifecycle-valdymas","title":"Pilnas lifecycle valdymas","text":"stack.hstack.cuser.c 09_Completing_LIFECYCLE/01_OK/stack.h<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid init(struct Stack *);\nvoid destroy(struct Stack *); // !\n\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre> 09_Completing_LIFECYCLE/01_OK/stack.c<pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack{\n  char stack[SIZE];\n  int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) { // !\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre> 09_Completing_LIFECYCLE/01_OK/user.c<pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    struct Stack *pst1=NULL, *pst2=NULL; // !\n\n    pst1 = create(); // !\n    pst2 = create(); // !\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ( (!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst1,c);\n    while (!isEmpty(pst1)) putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ( (!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar())) ) push(pst2,c);\n    while (!isEmpty(pst2)) putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");   \n\n    destroy(pst1); // !\n    destroy(pst2); // !\n\n    return 0;\n}\n\n\n/*\ngcc 077_stack.c 077_user.c -o 077_use_stack\n*/\n\n/*\nC:\\Repos\\Github\\ViktorasGolubevas\\desktop-tutorial\\src\\evolution\\stackext&gt;077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n*/\n</code></pre> Pilnas C ADT! <ul> <li>\u2705 Information hiding (opaque pointer)</li> <li>\u2705 Lifecycle management (create/destroy)</li> <li>\u2705 Multiple instances</li> <li>\u2705 Factory pattern</li> </ul>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#9-etapu-kelias","title":"9 etap\u0173 kelias","text":"Nr Etapas Failai \u017dingsni\u0173 Info Hiding? Lifecycle? Esm\u0117 01 Running_PROGRAM <code>usestack.c</code> 1 \u274c \u274c Monolitas 02 Decomposing_to_UNITS <code>stack.c, user.c</code> 3 \u274c \u274c NL klaidos 03 Discovering_C_MODULE <code>stack.h/c, user.c</code> 4 \u274c \u274c Modulis 04 Protecting_IMPLEMENTATION <code>stack.h/c, user.c</code> 2 \u2705 (1 stekas) \u274c <code>static</code> 05 Defining_USER_TYPE <code>usestack.c</code> 3 \u274c \u274c Struct monolite 06 ENCAPSULATING_UDT <code>stack.h/c, user.c</code> 2 \u274c \u274c Struct + modulis 07 HIDING_UDT_Information <code>stack.h/c, user.c</code> 3 \u2705 \u274c Opaque pointer 08 Acquiring_RESOURCES <code>stack.h/c, user.c</code> 1 \u2705 \u2705 (manual) Factory 09 Completing_LIFECYCLE <code>stack.h/c, user.c</code> 1 \u2705 \u2705 Pilnas ADT"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#suolis-i-c","title":"\u0160uolis \u012f C++","text":""},{"location":"Paskaitos/stack_C_evolution_CORRECT/#c-adt-etapas-09","title":"C ADT (Etapas 09):","text":"<pre><code>struct Stack *s = create();\npush(s, 'a');\ndestroy(s);\n</code></pre>"},{"location":"Paskaitos/stack_C_evolution_CORRECT/#c-class","title":"C++ Class:","text":"<pre><code>Stack s;               // Konstruktorius\ns.push('a');          // Metodas\n// Destruktorius automati\u0161kai\n</code></pre> <p>Kitas \u017eingsnis: C++ Stack evoliucija! \ud83d\ude80</p>"},{"location":"Pratybos/U1/","title":"U1: C++ Primityvai ir Funkcij\u0173 Moduliai","text":"<p>Savait\u0117s: 1-2 Svoris: 1 balas Terminas: Savait\u0117s 2 pabaiga</p>"},{"location":"Pratybos/U1/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>SVARBU: Jei dar nesuk\u016br\u0117te GitLab projekto, pirmiausia perskaitykite: \ud83d\udc49 U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas</p> <p>Ten rasite: - GitLab projekto suk\u016brimo instrukcijas - Projekto strukt\u016br\u0105 - Git workflow gaires - README.md \u0161ablonus - Pateikimo \u012f Moodle proces\u0105</p>"},{"location":"Pratybos/U1/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>\u012esiva\u017eiuoti su C++ sintakse, i\u0161mokti dirbti su masyvais, konteineriais ir funkcijomis. Suprasti modulin\u0119 program\u0173 strukt\u016br\u0105.</p>"},{"location":"Pratybos/U1/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Naudoti C++ \u012fvesties/i\u0161vesties srautus (<code>cin</code>, <code>cout</code>)</li> <li>\u2705 Dirbti su masyvais ir <code>vector</code> konteineriais</li> <li>\u2705 Ra\u0161yti ir kviesti funkcijas</li> <li>\u2705 Organizuoti kod\u0105 \u012f keli\u0173 fail\u0173 strukt\u016br\u0105 (<code>.h</code>/<code>.cpp</code>)</li> <li>\u2705 Kompiliuoti program\u0105 i\u0161 keli\u0173 fail\u0173</li> </ul>"},{"location":"Pratybos/U1/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/U1/#1-zingsnis-hello-c-ir-masyvu-ivestis","title":"1 \u017eingsnis. \"Hello C++\" ir masyv\u0173 \u012fvestis","text":"<p>Reikalavimai: 1. Para\u0161ykite program\u0105, kuri:    - I\u0161veda \"Hello, C++!\" \u012f konsol\u0119    - Leid\u017eia vartotojui \u012fvesti sveikus skai\u010dius    - Talpina skai\u010dius \u012f fiksuoto dyd\u017eio masyv\u0105 (pvz., 100 element\u0173)    - Baigia \u012fvedim\u0105, kai vartotojas \u012fveda <code>0</code>    - Atspausdina visus \u012fvestus skai\u010dius</p> <p>Technikos: - Naudokite <code>cout</code> i\u0161vedimui - Naudokite <code>cin</code> \u012fvedimui - Naudokite <code>int</code> tipo masyv\u0105: <code>int skaiciai[100];</code> - Saugokite \u012fvest\u0173 skai\u010di\u0173 kiek\u012f atskirame kintamajame</p> <p>Pavyzdys: <pre><code>Hello, C++!\n\u012eveskite sveikus skai\u010dius (0 - baigti):\n42\n17\n99\n0\n\u012evesti skai\u010diai: 42 17 99\n</code></pre></p>"},{"location":"Pratybos/U1/#2-zingsnis-bubble-sort-funkcija","title":"2 \u017eingsnis. Bubble sort funkcija","text":"<p>Reikalavimai: 1. Para\u0161ykite funkcij\u0105 <code>rusiuotiMasyva()</code>, kuri:    - Priima masyv\u0105 ir jo dyd\u012f    - Sur\u016b\u0161iuoja masyvo elementus nuo ma\u017eiausio iki did\u017eiausio    - Naudoja Bubble sort algoritm\u0105</p> <ol> <li>Programos <code>main()</code> funkcijoje:</li> <li>I\u0161kvieskite r\u016b\u0161iavimo funkcij\u0105</li> <li>Atspausdinkite sur\u016b\u0161iuotus skai\u010dius</li> </ol> <p>Technikos: - Funkcijos deklaracija: <code>void rusiuotiMasyva(int masyvas[], int dydis);</code> - Bubble sort: lyginkite gretimus elementus ir keiskite vietomis</p> <p>Pavyzdys: <pre><code>\u012evesti skai\u010diai: 42 17 99\nSur\u016b\u0161iuoti skai\u010diai: 17 42 99\n</code></pre></p>"},{"location":"Pratybos/U1/#3-zingsnis-moduline-struktura-h-cpp","title":"3 \u017eingsnis. Modulin\u0117 strukt\u016bra (.h + .cpp)","text":"<p>Reikalavimai: 1. Sukurkite 3 failus direktorijoje <code>U1/03/</code>:    - <code>main.cpp</code> - pagrindin\u0117 programa (tik <code>main()</code> funkcija)    - <code>rusiavimas.h</code> - funkcij\u0173 deklaracijos    - <code>rusiavimas.cpp</code> - funkcij\u0173 implementacijos</p> <ol> <li><code>rusiavimas.h</code> turi tur\u0117ti:</li> <li>Header guard (<code>#ifndef</code>, <code>#define</code>, <code>#endif</code>)</li> <li>Funkcijos <code>rusiuotiMasyva()</code> deklaracij\u0105</li> <li> <p>Funkcijos <code>spausdintiMasyva()</code> deklaracij\u0105 (nauja!)</p> </li> <li> <p><code>rusiavimas.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li> <p>Funkcij\u0173 implementacijas</p> </li> <li> <p><code>main.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li>Tik <code>main()</code> funkcij\u0105</li> </ol> <p>Kompiliacija: <pre><code>cd U1/03/\ng++ -c main.cpp\ng++ -c rusiavimas.cpp\ng++ main.o rusiavimas.o -o programa\n./programa\n</code></pre></p> <p>Arba naudojant Makefile (rekomenduojama).</p>"},{"location":"Pratybos/U1/#4-zingsnis-evoliucija-array-vectorint","title":"4 \u017eingsnis. Evoliucija: array \u2192 vector\\&lt;int&gt;","text":"<p>Reikalavimai: 1. Pakeiskite masyv\u0105 <code>int skaiciai[100]</code> \u012f <code>vector&lt;int&gt; skaiciai</code> 2. Vietoj <code>skaiciai[kiekis++] = x</code> naudokite <code>skaiciai.push_back(x)</code> 3. Vektoriaus dyd\u012f gaukite su <code>skaiciai.size()</code> 4. Adaptuokite r\u016b\u0161iavimo funkcij\u0105 dirbti su <code>vector&lt;int&gt;</code></p> <p>SVARBU:  - U\u017ekomentuokite sen\u0105 kod\u0105 su masyvais, bet palikite j\u012f matytis faile - Tai leis d\u0117stytojui \u012fsitikinti, kad atlikote visus \u017eingsnius</p> <p>Technikos: - <code>#include &lt;vector&gt;</code> - <code>vector&lt;int&gt;</code> vietoj <code>int[]</code> - Funkcija gali b\u016bti: <code>void rusiuotiVektoriu(vector&lt;int&gt;&amp; skaiciai)</code> - Perduokite vektori\u0173 per nuorod\u0105 (<code>&amp;</code>)</p>"},{"location":"Pratybos/U1/#5-zingsnis-evoliucija-vectorint-vectorstring","title":"5 \u017eingsnis. Evoliucija: vector\\&lt;int&gt; \u2192 vector\\&lt;string&gt;","text":"<p>Reikalavimai: 1. Sukurkite nauj\u0105 programos versij\u0105, kuri:    - \u012eveda \u017eod\u017eius (ne skai\u010dius)    - Baigia \u012fvedim\u0105, kai \u012fvedamas <code>-</code>    - R\u016b\u0161iuoja \u017eod\u017eius ab\u0117c\u0117l\u0117s tvarka    - Atspausdina sur\u016b\u0161iuotus \u017eod\u017eius</p> <ol> <li>Naudokite <code>vector&lt;string&gt;</code> konteiner\u012f</li> <li>R\u016b\u0161iavimo funkcija turi veikti su <code>string</code> tipu</li> </ol> <p>SVARBU: - V\u0117l u\u017ekomentuokite sen\u0105 kod\u0105 (su <code>int</code>), bet palikite matytis</p> <p>Technikos: - <code>#include &lt;string&gt;</code> - <code>vector&lt;string&gt;</code> vietoj <code>vector&lt;int&gt;</code> - <code>string</code> tipas palaiko <code>&lt;</code> operatori\u0173 (ab\u0117c\u0117l\u0117s tvarka)</p> <p>Pavyzdys: <pre><code>\u012eveskite \u017eod\u017eius ('-' baigti):\nobuolys\nbananas\ncitrina\n-\nSur\u016b\u0161iuoti \u017eod\u017eiai: bananas citrina obuolys\n</code></pre></p>"},{"location":"Pratybos/U1/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/U1/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md              \u2190 Projekto README (\u017er. UzduotiuGidas.md)\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 U1/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 1 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 02/                \u2190 2 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 03/                \u2190 3 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 4 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 05/                \u2190 5 \u017eingsnis (FINAL)\n        \u251c\u2500\u2500 main.cpp\n        \u251c\u2500\u2500 rusiavimas.h\n        \u251c\u2500\u2500 rusiavimas.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U1/#git-workflow-tariamas","title":"Git workflow (tariamas):","text":"<p>Po kiekvieno \u017eingsnio: <pre><code>cd cpp-2026/U1/01/\n# ... atlikti darb\u0105 ...\n\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre></p>"},{"location":"Pratybos/U1/#moodle-pateikimas-tariamas","title":"Moodle pateikimas (tariamas):","text":"<ol> <li> <p>Sukurti archyv\u0105:    <pre><code>cd cpp-2026\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/ README.md .gitignore\n</code></pre></p> </li> <li> <p>\u012ekelti \u012f Moodle su GitLab URL</p> </li> </ol>"},{"location":"Pratybos/U1/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Perskaitykite U\u017eduo\u010di\u0173 Gidas prie\u0161 pradedant</li> <li>Git workflow:</li> <li>Commit'inkite po kiekvieno \u017eingsnio</li> <li>Push'inkite da\u017enai (backup!)</li> <li>Prad\u0117kite paprastai - pirmiausia paleiskite 1 \u017eingsn\u012f, tada t\u0119skite</li> <li>Kompiliuokite da\u017enai - po kiekvieno \u017eingsnio</li> <li>Testuokite su skirtingais duomenimis - teigiami, neigiami skai\u010diai</li> <li>Klauskite, jei neai\u0161ku - geriau anks\u010diau nei v\u0117liau!</li> </ol>"},{"location":"Pratybos/U1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ vector dokumentacija</li> <li>C++ string dokumentacija</li> <li>Makefile tutorial</li> </ul>"},{"location":"Pratybos/U1/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Ar galiu naudoti <code>std::sort()</code> vietoj Bubble sort? A: Ne, \u0161ioje u\u017eduotyje privaloma implementuoti Bubble sort patys.</p> <p>K: Ar privalau naudoti Makefile? A: Ne, bet rekomenduojama nuo 3 \u017eingsnio. Galite kompiliuoti rankiniu b\u016bdu.</p> <p>K: Kiek test\u0173 reikia README faile? A: Bent 2 - vienas su skai\u010diais, vienas su \u017eod\u017eiais.</p> <p>K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173? A: Taip, bet neprivaloma. Subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/U2-solution/","title":"U2: Sprendimas - OOP Pagrindai. Klas\u0117s ir Objektai","text":"<p>D\u0117stytojui: \u0160is failas skirtas jums - pilnas sprendimas su kodu, paai\u0161kinimais ir \"virtuve\".</p>"},{"location":"Pratybos/U2-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U2/\n\u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 student_struct.cpp\n\u2502   \u2514\u2500\u2500 student_class.cpp\n\u251c\u2500\u2500 02/\n\u2502   \u251c\u2500\u2500 Student.h\n\u2502   \u251c\u2500\u2500 Student.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 03/\n\u2502   \u251c\u2500\u2500 Student.h\n\u2502   \u251c\u2500\u2500 Student.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 04/\n\u2502   \u251c\u2500\u2500 Student.h\n\u2502   \u251c\u2500\u2500 Student.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 05/\n\u2502   \u251c\u2500\u2500 Student.h\n\u2502   \u251c\u2500\u2500 Student.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u2514\u2500\u2500 06-bonus/\n    \u251c\u2500\u2500 Student.h\n    \u251c\u2500\u2500 Student.cpp\n    \u251c\u2500\u2500 main.cpp\n    \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U2-solution/#1-1-zingsnis-struct-class-transformacija","title":"1\ufe0f\u20e3 1 \u017eingsnis: Struct \u2192 Class transformacija","text":""},{"location":"Pratybos/U2-solution/#student_structcpp-c-strukturos-versija","title":"student_struct.cpp (C strukt\u016bros versija):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nstruct Student {\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Jonas\");\n    s1.amzius = 20;\n    s1.pazymys = 8.5;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#kompiliavimas","title":"Kompiliavimas:","text":"<pre><code>g++ student_struct.cpp -o struct_versija\n./struct_versija\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis","title":"I\u0161vestis:","text":"<pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5\n</code></pre>"},{"location":"Pratybos/U2-solution/#student_classcpp-c-klases-versija-su-public","title":"student_class.cpp (C++ klas\u0117s versija su public):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Student {\npublic:  // Visi nariai public (kaip struct)\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Petras\");\n    s1.amzius = 21;\n    s1.pazymys = 9.0;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#kompiliavimas_1","title":"Kompiliavimas:","text":"<pre><code>g++ student_class.cpp -o class_versija\n./class_versija\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis_1","title":"I\u0161vestis:","text":"<pre><code>Studentas: Petras, Am\u017eius: 21, Pa\u017eymys: 9\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Abu failai veikia vienodai - skirtumas tik <code>struct</code> vs <code>class</code> keyword</li> <li>\u2705 <code>struct</code> - nariai public pagal nutyl\u0117jim\u0105</li> <li>\u2705 <code>class</code> su <code>public:</code> - taip pat visi nariai public</li> <li>\ud83d\udca1 Kitas \u017eingsnis: <code>class</code> su <code>private</code> - tikroji enkapsulacija</li> <li>\u26a0\ufe0f Da\u017ena klaida: Pamir\u0161ti <code>;</code> po <code>}</code> klas\u0117s deklaracijoje</li> </ul>"},{"location":"Pratybos/U2-solution/#2-2-zingsnis-konstruktoriai","title":"2\ufe0f\u20e3 2 \u017eingsnis: Konstruktoriai","text":""},{"location":"Pratybos/U2-solution/#studenth","title":"Student.h:","text":"<pre><code>#ifndef STUDENT_H\n#define STUDENT_H\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\npublic:\n    // Konstruktoriai\n    Student();  // Default\n    Student(const char* v, int a, double p);  // Parametrinis\n\n    // Metodai (kol kas tik prototypai)\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/U2-solution/#studentcpp","title":"Student.cpp:","text":"<pre><code>#include \"Student.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// Default konstruktorius\nStudent::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas (default): \" &lt;&lt; vardas &lt;&lt; std::endl;\n}\n\n// Parametrinis konstruktorius\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas: \" &lt;&lt; vardas &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#maincpp","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Student.h\"\nusing namespace std;\n\nint main() {\n    Student s1;  // Default konstruktorius\n    Student s2(\"Jonas\", 20, 8.5);  // Parametrinis\n    Student s3(\"Petras\", 21, 9.0);\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#makefile","title":"Makefile:","text":"<pre><code>CXX = g++\nCXXFLAGS = -Wall -std=c++11\n\nOBJS = main.o Student.o\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\nmain.o: main.cpp Student.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nStudent.o: Student.cpp Student.h\n    $(CXX) $(CXXFLAGS) -c Student.cpp\n\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/U2-solution/#kompiliavimas_2","title":"Kompiliavimas:","text":"<pre><code>make\n./programa\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis_2","title":"I\u0161vestis:","text":"<pre><code>[TEST] Student sukurtas (default): Nezinomas\n[TEST] Student sukurtas: Jonas\n[TEST] Student sukurtas: Petras\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Konstruktorius automati\u0161kai kvie\u010diamas sukuriant objekt\u0105</li> <li>\u2705 Default konstruktorius - be parametr\u0173</li> <li>\u2705 Parametrinis konstruktorius - su parametrais</li> <li>\u2705 <code>strcpy()</code> - C-style string kopijavimas (reikia <code>&lt;cstring&gt;</code>)</li> <li>\ud83d\udca1 Initialization list (pamin\u0117ti kaip alternatyv\u0105 4 \u017eingsnyje)</li> <li>\u26a0\ufe0f Da\u017ena klaida: U\u017emir\u0161ti <code>strcpy()</code>, tiesiog <code>vardas = v</code> (ne veiks!)</li> <li>\u26a0\ufe0f Da\u017ena klaida: Pamir\u0161ti header guard'us <code>Student.h</code> faile</li> </ul>"},{"location":"Pratybos/U2-solution/#3-3-zingsnis-metodai-getters-setters-pagalbiniai","title":"3\ufe0f\u20e3 3 \u017eingsnis: Metodai (getters, setters, pagalbiniai)","text":""},{"location":"Pratybos/U2-solution/#studenth_1","title":"Student.h:","text":"<pre><code>#ifndef STUDENT_H\n#define STUDENT_H\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\npublic:\n    // Konstruktoriai\n    Student();\n    Student(const char* v, int a, double p);\n\n    // Getters (const metodai!)\n    const char* gautiVarda() const;\n    int gautiAmziu() const;\n    double gautiPazymi() const;\n\n    // Setters\n    void nustatytiVarda(const char* v);\n    void nustatytiAmziu(int a);\n    void nustatytiPazymi(double p);\n\n    // Pagalbiniai metodai\n    bool arPilnametis() const;\n    void spausdinti() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/U2-solution/#studentcpp_1","title":"Student.cpp:","text":"<pre><code>#include \"Student.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// Konstruktoriai (tie patys kaip \u017eingsnis 2)\nStudent::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n}\n\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n}\n\n// Getters\nconst char* Student::gautiVarda() const {\n    return vardas;\n}\n\nint Student::gautiAmziu() const {\n    return amzius;\n}\n\ndouble Student::gautiPazymi() const {\n    return pazymys;\n}\n\n// Setters (su patvirtinimu)\nvoid Student::nustatytiVarda(const char* v) {\n    strcpy(vardas, v);\n}\n\nvoid Student::nustatytiAmziu(int a) {\n    if (a &gt; 0 &amp;&amp; a &lt; 120) {  // Patikrinimas\n        amzius = a;\n    }\n}\n\nvoid Student::nustatytiPazymi(double p) {\n    if (p &gt;= 0.0 &amp;&amp; p &lt;= 10.0) {  // Patikrinimas\n        pazymys = p;\n    }\n}\n\n// Pagalbiniai metodai\nbool Student::arPilnametis() const {\n    return amzius &gt;= 18;\n}\n\nvoid Student::spausdinti() const {\n    std::cout &lt;&lt; \"Studentas: \" &lt;&lt; vardas \n              &lt;&lt; \", Am\u017eius: \" &lt;&lt; amzius \n              &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; pazymys;\n\n    if (arPilnametis()) {\n        std::cout &lt;&lt; \" (pilnametis)\";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#maincpp_1","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Student.h\"\nusing namespace std;\n\nint main() {\n    Student s1(\"Jonas\", 20, 8.5);\n    s1.spausdinti();\n\n    s1.nustatytiPazymi(9.0);\n    cout &lt;&lt; \"Naujas pa\u017eymys: \" &lt;&lt; s1.gautiPazymi() &lt;&lt; endl;\n\n    Student s2(\"Petras\", 16, 7.5);\n    s2.spausdinti();\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis_3","title":"I\u0161vestis:","text":"<pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5 (pilnametis)\nNaujas pa\u017eymys: 9\nStudentas: Petras, Am\u017eius: 16, Pa\u017eymys: 7.5\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>const</code> metodai - nekei\u010dia objekto b\u016bsenos (getters, pagalbiniai)</li> <li>\u2705 Getters - tik skaito, setters - modifikuoja</li> <li>\u2705 Patikrinimas setter'iuose - validacija</li> <li>\ud83d\udca1 Enkapsulacija - privat\u016bs duomenys, public metodai</li> <li>\u26a0\ufe0f Da\u017ena klaida: Pamir\u0161ti <code>const</code> getter'iams (kompiliatorius skund\u017eiasi)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>strcpy(vardas, v)</code> setter'yje, o ne <code>vardas = v</code></li> </ul>"},{"location":"Pratybos/U2-solution/#4-4-zingsnis-static-counter-destruktorius","title":"4\ufe0f\u20e3 4 \u017eingsnis: Static counter + destruktorius","text":""},{"location":"Pratybos/U2-solution/#studenth_2","title":"Student.h:","text":"<pre><code>#ifndef STUDENT_H\n#define STUDENT_H\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\n    static int sukurtaStudentu;  // Statinis skaitiklis\n\npublic:\n    // Konstruktoriai\n    Student();\n    Student(const char* v, int a, double p);\n    ~Student();  // Destruktorius\n\n    // Getters\n    const char* gautiVarda() const;\n    int gautiAmziu() const;\n    double gautiPazymi() const;\n\n    // Setters\n    void nustatytiVarda(const char* v);\n    void nustatytiAmziu(int a);\n    void nustatytiPazymi(double p);\n\n    // Pagalbiniai\n    bool arPilnametis() const;\n    void spausdinti() const;\n\n    // Static getter\n    static int gautiSukurtaStudentu();\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/U2-solution/#studentcpp_2","title":"Student.cpp:","text":"<pre><code>#include \"Student.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\n// Statinio nario inicializacija (u\u017e klas\u0117s rib\u0173!)\nint Student::sukurtaStudentu = 0;\n\n// Default konstruktorius\nStudent::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    sukurtaStudentu++;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas (default): \" &lt;&lt; vardas \n              &lt;&lt; \". Viso student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Parametrinis konstruktorius\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    sukurtaStudentu++;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas: \" &lt;&lt; vardas \n              &lt;&lt; \". Viso student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Destruktorius\nStudent::~Student() {\n    sukurtaStudentu--;\n    std::cout &lt;&lt; \"[TEST] Student sunaikintas: \" &lt;&lt; vardas \n              &lt;&lt; \". Liko student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Getters, setters, pagalbiniai (tie patys kaip \u017eingsnis 3)\n// ...\n\n// Static getter\nint Student::gautiSukurtaStudentu() {\n    return sukurtaStudentu;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#maincpp_2","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Student.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    {\n        Student s1(\"Jonas\", 20, 8.5);\n        Student s2(\"Petras\", 21, 9.0);\n        cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 2\n    }  // s1 ir s2 sunaikinami \u010dia\n\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis_4","title":"I\u0161vestis:","text":"<pre><code>Student\u0173: 0\n[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n[TEST] Student sukurtas: Petras. Viso student\u0173: 2\nStudent\u0173: 2\n[TEST] Student sunaikintas: Petras. Liko student\u0173: 1\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\nStudent\u0173: 0\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Static narys - bendras visiems objektams (ne kiekvienas turi savo)</li> <li>\u2705 Inicializacija u\u017e klas\u0117s rib\u0173: <code>int Student::sukurtaStudentu = 0;</code></li> <li>\u2705 Destruktorius - automati\u0161kai kvie\u010diamas i\u0161einant i\u0161 scope</li> <li>\u2705 Static getter - galima kviesti be objekto: <code>Student::gautiSukurtaStudentu()</code></li> <li>\ud83d\udca1 Initialization list alternatyva (pamin\u0117ti studentams):   <pre><code>Student::Student(const char* v, int a, double p) \n    : amzius(a), pazymys(p)  // Initialization list\n{\n    strcpy(vardas, v);  // char[] reikia body'je\n    sukurtaStudentu++;\n}\n</code></pre></li> <li>\u26a0\ufe0f Da\u017ena klaida: Pamir\u0161ti inicializuoti static nar\u012f u\u017e klas\u0117s (<code>int Student::sukurtaStudentu = 0;</code>)</li> <li>\u26a0\ufe0f Da\u017ena klaida: Bandyti inicializuoti static nar\u012f konstruktoriuje (<code>sukurtaStudentu = 0</code> - blogai!)</li> </ul>"},{"location":"Pratybos/U2-solution/#5-5-zingsnis-pazymiu-masyvas","title":"5\ufe0f\u20e3 5 \u017eingsnis: Pa\u017eymi\u0173 masyvas","text":""},{"location":"Pratybos/U2-solution/#studenth_3","title":"Student.h:","text":"<pre><code>#ifndef STUDENT_H\n#define STUDENT_H\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n\n    // Pa\u017eymi\u0173 masyvas\n    static const int MAX_PAZYMIU = 20;\n    double pazymiai[MAX_PAZYMIU];\n    int pazymiuKiekis;\n\n    static int sukurtaStudentu;\n\npublic:\n    // Konstruktoriai (be pa\u017eymio parametro!)\n    Student();\n    Student(const char* v, int a);\n    ~Student();\n\n    // Getters\n    const char* gautiVarda() const;\n    int gautiAmziu() const;\n\n    // Setters\n    void nustatytiVarda(const char* v);\n    void nustatytiAmziu(int a);\n\n    // Pa\u017eymi\u0173 metodai\n    void pridetiPazymi(double p);\n    double skaiciuotiVidurki() const;\n    void spausdintiPazymius() const;\n\n    // Pagalbiniai\n    bool arPilnametis() const;\n    void spausdinti() const;\n\n    // Static\n    static int gautiSukurtaStudentu();\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/U2-solution/#studentcpp_3","title":"Student.cpp:","text":"<pre><code>#include \"Student.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint Student::sukurtaStudentu = 0;\n\n// Default konstruktorius\nStudent::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymiuKiekis = 0;  // Prad\u017eioje 0 pa\u017eymi\u0173\n    sukurtaStudentu++;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas (default): \" &lt;&lt; vardas \n              &lt;&lt; \". Viso student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Parametrinis konstruktorius (be pa\u017eymio!)\nStudent::Student(const char* v, int a) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymiuKiekis = 0;\n    sukurtaStudentu++;\n    std::cout &lt;&lt; \"[TEST] Student sukurtas: \" &lt;&lt; vardas \n              &lt;&lt; \". Viso student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Destruktorius\nStudent::~Student() {\n    sukurtaStudentu--;\n    std::cout &lt;&lt; \"[TEST] Student sunaikintas: \" &lt;&lt; vardas \n              &lt;&lt; \". Liko student\u0173: \" &lt;&lt; sukurtaStudentu &lt;&lt; std::endl;\n}\n\n// Getters, setters (tie patys)\n// ...\n\n// Pa\u017eymi\u0173 metodai\nvoid Student::pridetiPazymi(double p) {\n    if (pazymiuKiekis &lt; MAX_PAZYMIU &amp;&amp; p &gt;= 0.0 &amp;&amp; p &lt;= 10.0) {\n        pazymiai[pazymiuKiekis] = p;\n        pazymiuKiekis++;\n    } else {\n        std::cout &lt;&lt; \"[KLAIDA] Negalima prid\u0117ti pa\u017eymio!\" &lt;&lt; std::endl;\n    }\n}\n\ndouble Student::skaiciuotiVidurki() const {\n    if (pazymiuKiekis == 0) {\n        return 0.0;\n    }\n\n    double suma = 0.0;\n    for (int i = 0; i &lt; pazymiuKiekis; i++) {\n        suma += pazymiai[i];\n    }\n\n    return suma / pazymiuKiekis;\n}\n\nvoid Student::spausdintiPazymius() const {\n    std::cout &lt;&lt; \"Pa\u017eymiai (\" &lt;&lt; pazymiuKiekis &lt;&lt; \"): \";\n    for (int i = 0; i &lt; pazymiuKiekis; i++) {\n        std::cout &lt;&lt; pazymiai[i];\n        if (i &lt; pazymiuKiekis - 1) {\n            std::cout &lt;&lt; \", \";\n        }\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nvoid Student::spausdinti() const {\n    std::cout &lt;&lt; \"Studentas: \" &lt;&lt; vardas \n              &lt;&lt; \", Am\u017eius: \" &lt;&lt; amzius &lt;&lt; std::endl;\n    spausdintiPazymius();\n    std::cout &lt;&lt; \"Vidurkis: \" &lt;&lt; skaiciuotiVidurki() &lt;&lt; std::endl;\n}\n\nint Student::gautiSukurtaStudentu() {\n    return sukurtaStudentu;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#maincpp_3","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Student.h\"\nusing namespace std;\n\nint main() {\n    Student s1(\"Jonas\", 20);\n\n    s1.pridetiPazymi(8.5);\n    s1.pridetiPazymi(9.0);\n    s1.pridetiPazymi(7.5);\n    s1.pridetiPazymi(8.0);\n\n    s1.spausdinti();\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#isvestis_5","title":"I\u0161vestis:","text":"<pre><code>[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\nStudentas: Jonas, Am\u017eius: 20\nPa\u017eymiai (4): 8.5, 9, 7.5, 8\nVidurkis: 8.25\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Masyvas <code>double pazymiai[MAX_PAZYMIU]</code> + <code>int pazymiuKiekis</code> - kaip U1</li> <li>\u2705 Patikrinimas: <code>pazymiuKiekis &lt; MAX_PAZYMIU</code> (ribos)</li> <li>\u2705 Vidurkio skai\u010diavimas - suma / kiekis</li> <li>\ud83d\udca1 Kitas \u017eingsnis - vector (dinaminis, be limit\u0173)</li> <li>\u26a0\ufe0f Da\u017ena klaida: Pamir\u0161ti <code>pazymiuKiekis = 0</code> konstruktoriuje</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>pazymiai[pazymiuKiekis++] = p</code> vietoj dviej\u0173 eilu\u010di\u0173</li> <li>\u26a0\ufe0f Da\u017ena klaida: Off-by-one kableli\u0173 spausdinime (<code>i &lt; pazymiuKiekis - 1</code>)</li> </ul>"},{"location":"Pratybos/U2-solution/#6-bonus-zingsnis-masyvas-vector","title":"6\ufe0f\u20e3 BONUS \u017eingsnis: Masyvas \u2192 vector","text":""},{"location":"Pratybos/U2-solution/#studenth_4","title":"Student.h:","text":"<pre><code>#ifndef STUDENT_H\n#define STUDENT_H\n\n#include &lt;vector&gt;  // SVARBU!\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n\n    // Vector vietoj masyvo\n    std::vector&lt;double&gt; pazymiai;\n\n    static int sukurtaStudentu;\n\npublic:\n    // Konstruktoriai\n    Student();\n    Student(const char* v, int a);\n    ~Student();\n\n    // Getters, setters\n    const char* gautiVarda() const;\n    int gautiAmziu() const;\n    void nustatytiVarda(const char* v);\n    void nustatytiAmziu(int a);\n\n    // Pa\u017eymi\u0173 metodai\n    void pridetiPazymi(double p);\n    double skaiciuotiVidurki() const;\n    void spausdintiPazymius() const;\n\n    // Pagalbiniai\n    bool arPilnametis() const;\n    void spausdinti() const;\n\n    // Static\n    static int gautiSukurtaStudentu();\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/U2-solution/#studentcpp_4","title":"Student.cpp:","text":"<pre><code>#include \"Student.h\"\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nint Student::sukurtaStudentu = 0;\n\n// Konstruktoriai (pazymiai jau tu\u0161\u010dias vector)\nStudent::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    // pazymiai - default konstruktorius (tu\u0161\u010dias vector)\n    sukurtaStudentu++;\n}\n\nStudent::Student(const char* v, int a) {\n    strcpy(vardas, v);\n    amzius = a;\n    // pazymiai - default konstruktorius (tu\u0161\u010dias vector)\n    sukurtaStudentu++;\n}\n\n// Pa\u017eymi\u0173 metodai (atnaujinti su vector)\nvoid Student::pridetiPazymi(double p) {\n    if (p &gt;= 0.0 &amp;&amp; p &lt;= 10.0) {\n        pazymiai.push_back(p);  // Vietoj pazymiai[pazymiuKiekis++]\n    } else {\n        std::cout &lt;&lt; \"[KLAIDA] Netinkamas pa\u017eymys!\" &lt;&lt; std::endl;\n    }\n}\n\ndouble Student::skaiciuotiVidurki() const {\n    if (pazymiai.empty()) {  // Vietoj pazymiuKiekis == 0\n        return 0.0;\n    }\n\n    double suma = 0.0;\n    for (double p : pazymiai) {  // Range-based for loop!\n        suma += p;\n    }\n\n    return suma / pazymiai.size();  // Vietoj pazymiuKiekis\n}\n\nvoid Student::spausdintiPazymius() const {\n    std::cout &lt;&lt; \"Pa\u017eymiai (\" &lt;&lt; pazymiai.size() &lt;&lt; \"): \";\n    for (size_t i = 0; i &lt; pazymiai.size(); i++) {\n        std::cout &lt;&lt; pazymiai[i];\n        if (i &lt; pazymiai.size() - 1) {\n            std::cout &lt;&lt; \", \";\n        }\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\n// Kiti metodai tie patys kaip \u017eingsnis 5\n// ...\n</code></pre>"},{"location":"Pratybos/U2-solution/#maincpp-tas-pats-kaip-zingsnis-5","title":"main.cpp (tas pats kaip \u017eingsnis 5):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Student.h\"\nusing namespace std;\n\nint main() {\n    Student s1(\"Jonas\", 20);\n\n    // Pridedame daugiau nei 20 pa\u017eymi\u0173 - veiks!\n    for (int i = 0; i &lt; 25; i++) {\n        s1.pridetiPazymi(7.0 + i * 0.1);\n    }\n\n    s1.spausdinti();\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-pastabos_5","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Vector dinami\u0161kai ple\u010diasi - ne limit\u0173!</li> <li>\u2705 <code>.push_back(p)</code> - vietoj <code>pazymiai[pazymiuKiekis++] = p</code></li> <li>\u2705 <code>.size()</code> - vietoj <code>pazymiuKiekis</code></li> <li>\u2705 <code>.empty()</code> - vietoj <code>pazymiuKiekis == 0</code></li> <li>\u2705 Range-based for loop: <code>for (double p : pazymiai)</code> - moderni\u0161kas C++</li> <li>\ud83d\udca1 Vector automati\u0161kai valdo atmint\u012f (RAII)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>pazymiai.size()</code> gr\u0105\u017eina <code>size_t</code> (unsigned) - galimi warning'ai</li> </ul>"},{"location":"Pratybos/U2-solution/#readmemd-pavyzdys","title":"\ud83d\udce6 README.md pavyzdys","text":"<pre><code># U2: OOP Pagrindai. Klas\u0117s ir Objektai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-01\n\n---\n\n## \ud83d\udcc1 \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Struct \u2192 Class transformacija |\n| 2 | `02/` | Konstruktoriai (default + parametrinis) |\n| 3 | `03/` | Metodai (getters, setters, pagalbiniai) |\n| 4 | `04/` | Static counter + destruktorius |\n| 5 | `05/` | Pa\u017eymi\u0173 masyvas |\n| 6 | `06-bonus/` | BONUS: array \u2192 vector |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (konstruktoriai)**:\n\n    [TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n    \u2705 VEIKIA\n\n**Testas 2 (pa\u017eymi\u0173 vidurkis)**:\n\n    Pa\u017eymiai (4): 8.5, 9, 7.5, 8\n    Vidurkis: 8.25\n    \u2705 VEIKIA\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Class vs Struct - private vs public\n2. Konstruktoriai inicializuoja objekt\u0105\n3. Static nariai - bendri visiems objektams\n4. Destruktorius - automati\u0161kas cleanup\n5. Masyvas \u2192 vector (lankstesnis!)\n</code></pre>"},{"location":"Pratybos/U2-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/U2-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas Pamir\u0161o <code>;</code> po klas\u0117s deklaracijos \u2b50\u2b50\u2b50\u2b50\u2b50 Kompiliavimo klaida - parodyti <code>vardas = v</code> vietoj <code>strcpy(vardas, v)</code> \u2b50\u2b50\u2b50\u2b50 Paai\u0161kinti C-style strings Pamir\u0161o <code>const</code> getter'iams \u2b50\u2b50\u2b50\u2b50 Kompiliatorius skund\u017eiasi Pamir\u0161o inicializuoti static nar\u012f u\u017e klas\u0117s \u2b50\u2b50\u2b50\u2b50 Linking error Band\u0117 inicializuoti static nar\u012f konstruktoriuje \u2b50\u2b50\u2b50 Logic error - skaitiklis neteisingas Pamir\u0161o header guard'us \u2b50\u2b50\u2b50 Multiple definition error <code>pazymiuKiekis</code> ne inicializuotas \u2b50\u2b50\u2b50 Undefined behavior Off-by-one kableli\u0173 spausdinime \u2b50\u2b50 Estetin\u0117 problema"},{"location":"Pratybos/U2-solution/#galimi-prapletimai-stipriesiems","title":"Galimi prapl\u0117timai stipriesiems:","text":"<ol> <li>Initialization list naudojimas</li> <li> <p>Pademonstruoti efektyvum\u0105 (ne copy)</p> </li> <li> <p>Overload'inti operator&lt;&lt;</p> </li> <li> <p><code>cout &lt;&lt; s1</code> vietoj <code>s1.spausdinti()</code></p> </li> <li> <p>Copy constructor</p> </li> <li> <p>Nors \u010dia dar nereikia (\u017eingsnis 5 vector jau turi default'\u0105)</p> </li> <li> <p>Const correctness</p> </li> <li> <p>Visur kur galima <code>const</code></p> </li> <li> <p>std::string vietoj char[]</p> </li> <li>Modernesnis C++</li> </ol>"},{"location":"Pratybos/U2-solution/#diskusijos-taskai-paskaitoje","title":"\ud83d\udca1 Diskusijos ta\u0161kai paskaitoje","text":"<ol> <li>Struct vs Class</li> <li>Tik keyword'o skirtumas</li> <li> <p>Praktikoje: <code>struct</code> - duomenims, <code>class</code> - objektams su logika</p> </li> <li> <p>Enkapsulacija</p> </li> <li>Kod\u0117l <code>private</code> + getters/setters?</li> <li> <p>Validacija, kontrol\u0117, flexibility</p> </li> <li> <p>Static nariai</p> </li> <li>Kada naudoti? (counter'iai, config, shared state)</li> <li> <p>Kod\u0117l inicializuoti u\u017e klas\u0117s?</p> </li> <li> <p>Destruktorius</p> </li> <li>Kada kvie\u010diamas? (scope)</li> <li> <p>V\u0117liau: dynamic memory cleanup</p> </li> <li> <p>Masyvas vs Vector</p> </li> <li>Trade-off'ai (performance vs flexibility)</li> <li>RAII principas (vector valdo atmint\u012f)</li> </ol> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/U2/","title":"U2: OOP Pagrindai. Klas\u0117s ir Objektai","text":"<p>Savait\u0117s: 3-4 Svoris: 1 balas Terminas: Savait\u0117s 4 pabaiga</p>"},{"location":"Pratybos/U2/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas</p>"},{"location":"Pratybos/U2/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti kurti C++ klases, suprasti enkapsuliacijos princip\u0105, dirbti su konstruktoriais ir destruktoriais. Praktikuoti statinius narius ir masyv\u0173 evoliucij\u0105 objekt\u0173 kontekste.</p>"},{"location":"Pratybos/U2/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Transformuoti C strukt\u016br\u0105 \u012f C++ klas\u0119</li> <li>\u2705 Naudoti <code>private</code> ir <code>public</code> prieigos modifikatorius</li> <li>\u2705 Kurti konstruktorius (default ir parametrinius)</li> <li>\u2705 Kurti ir naudoti getterius/setterius</li> <li>\u2705 Naudoti statinius narius (klas\u0117s lygio duomenys)</li> <li>\u2705 Ra\u0161yti destruktorius su logging</li> <li>\u2705 Dirbti su C-style masyvais klas\u0117je</li> <li>\u2705 (Bonus) Evoliucija nuo masyvo prie <code>vector</code></li> </ul>"},{"location":"Pratybos/U2/#uzduoties-formatas","title":"\ud83d\udcd0 U\u017eduoties formatas","text":"<p>\u017dingsni\u0173 strukt\u016bra: - 5 pagrindiniai \u017eingsniai + 1 bonus \u017eingsnis - \u017dingsniai 1-2: Pilni pavyzd\u017eiai (ap\u0161ilimas) - \u017dingsniai 3-5: J\u016bs\u0173 kodas pagal u\u017eduotis</p> <p>Kodo \u017eym\u0117jimai: - PAVYZDYS \u2014 pilnas veikiantis kodas (galite kopijuoti) - J\u016aS\u0172 KODAS \u2014 turite patys implementuoti - // U\u017dDUOTIS: \u2014 komentarai nurodo, k\u0105 reikia padaryti</p> <p>Pavyzdys: <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar p tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: prid\u0117ti \u012f masyv\u0105\n}\n</code></pre></p> <p>Tai rei\u0161kia \u2014 j\u016bs ra\u0161ote kod\u0105, kuris atlieka tai, kas apra\u0161yta komentaruose.</p>"},{"location":"Pratybos/U2/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/U2/#1-zingsnis-struct-class-transformacija","title":"1 \u017eingsnis: Struct \u2192 Class transformacija","text":"<p>Direktorija: <code>U2/01/</code></p>"},{"location":"Pratybos/U2/#reikalavimai","title":"Reikalavimai:","text":"<p>Sukurkite 2 failus tame pa\u010diame \u017eingsnyje, kad b\u016bt\u0173 matoma transformacija:</p>"},{"location":"Pratybos/U2/#failas-student_structcpp-c-strukturos-versija","title":"Failas <code>student_struct.cpp</code> - C strukt\u016bros versija:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nstruct Student {\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Jonas\");\n    s1.amzius = 20;\n    s1.pazymys = 8.5;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Kompiliavimas: <pre><code>g++ student_struct.cpp -o struct_versija\n./struct_versija\n</code></pre></p>"},{"location":"Pratybos/U2/#failas-student_classcpp-c-klases-versija-su-public-nariais","title":"Failas <code>student_class.cpp</code> - C++ klas\u0117s versija (su public nariais):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Student {\npublic:  // Visi nariai public (kaip struct)\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Petras\");\n    s1.amzius = 21;\n    s1.pazymys = 9.0;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Kompiliavimas: <pre><code>g++ student_class.cpp -o class_versija\n./class_versija\n</code></pre></p> <p>Technikos: - <code>struct</code> - visi nariai public pagal nutyl\u0117jim\u0105 - <code>class</code> - visi nariai private pagal nutyl\u0117jim\u0105 - Parodyti skirtum\u0105 tarp <code>struct</code> (visk\u0105 galima pasiekti) ir <code>class</code> (reikia metod\u0173)</p> <p>Testas: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/01/\n\u251c\u2500\u2500 student_struct.cpp\n\u251c\u2500\u2500 student_class.cpp\n\u2514\u2500\u2500 README.md (neprivalomas)\n</code></pre></p>"},{"location":"Pratybos/U2/#2-zingsnis-konstruktoriai","title":"2 \u017eingsnis: Konstruktoriai","text":"<p>Direktorija: <code>U2/02/</code></p>"},{"location":"Pratybos/U2/#reikalavimai_1","title":"Reikalavimai:","text":"<p>Sukurkite Student klas\u0119 su konstruktoriais:</p>"},{"location":"Pratybos/U2/#student-klase","title":"Student klas\u0117:","text":"<p>Private nariai: - <code>char vardas[50]</code> - studento vardas - <code>int amzius</code> - studento am\u017eius - <code>double pazymys</code> - studento pa\u017eymys (vienas)</p> <p>Public konstruktoriai:</p> <p>1. Default konstruktorius: <pre><code>Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    cout &lt;&lt; \"[TEST] Student sukurtas (default): \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>2. Parametrinis konstruktorius: <pre><code>Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    cout &lt;&lt; \"[TEST] Student sukurtas: \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>Technikos: - Naudokite <code>strcpy()</code> (i\u0161 <code>&lt;cstring&gt;</code>) C-style string'ams - Konstruktoriai inicializuoja objekt\u0105 suk\u016brimo metu - Logging padeda matyti, kada objektai kuriami</p> <p>Testas: <pre><code>int main() {\n    Student s1;  // Default konstruktorius\n    Student s2(\"Jonas\", 20, 8.5);  // Parametrinis\n    Student s3(\"Petras\", 21, 9.0);\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[TEST] Student sukurtas (default): Nezinomas\n[TEST] Student sukurtas: Jonas\n[TEST] Student sukurtas: Petras\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/02/\n\u251c\u2500\u2500 Student.h\n\u251c\u2500\u2500 Student.cpp\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/U2/#3-zingsnis-metodai-getters-setters-utility","title":"3 \u017eingsnis: Metodai (getters, setters, utility)","text":"<p>Direktorija: <code>U2/03/</code></p>"},{"location":"Pratybos/U2/#reikalavimai_2","title":"Reikalavimai:","text":"<p>Prid\u0117kite metodus prie Student klas\u0117s:</p>"},{"location":"Pratybos/U2/#public-metodai","title":"Public metodai:","text":"<p>Getters (const metodai) - PAVYZDYS: <pre><code>const char* gautiVarda() const { \n    return vardas; \n}\n\nint gautiAmziu() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti am\u017ei\u0173\n}\n\ndouble gautiPazymi() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti pa\u017eym\u012f\n}\n</code></pre></p> <p>Setters - J\u016aS\u0172 KODAS: <pre><code>void nustatytiVarda(const char* v) {\n    // U\u017dDUOTIS: nukopijuoti vard\u0105 su strcpy()\n}\n\nvoid nustatytiAmziu(int a) {\n    // U\u017dDUOTIS: patikrinti ar am\u017eius tinkamas (&gt; 0 ir &lt; 120)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n\nvoid nustatytiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n</code></pre></p> <p>Pagalbiniai metodai - J\u016aS\u0172 KODAS: <pre><code>bool arPilnametis() const {\n    // U\u017dDUOTIS: gr\u0105\u017einti true jei amzius &gt;= 18, kitaip false\n}\n\nvoid spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;, Pa\u017eymys: &lt;pazymys&gt;\"\n    // U\u017dDUOTIS: jei pilnametis, prid\u0117ti \" (pilnametis)\"\n}\n</code></pre></p> <p>Technikos: - <code>const</code> metodai - nekei\u010dia objekto b\u016bsenos - Getters - tik skaito duomenis - Setters - modifikuoja duomenis (su patvirtinimu!) - Pagalbiniai metodai - skai\u010diuoja ar tikrina logik\u0105</p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20, 8.5);\n    s1.spausdinti();\n\n    s1.nustatytiPazymi(9.0);\n    cout &lt;&lt; \"Naujas pa\u017eymys: \" &lt;&lt; s1.gautiPazymi() &lt;&lt; endl;\n\n    Student s2(\"Petras\", 16, 7.5);\n    s2.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5 (pilnametis)\nNaujas pa\u017eymys: 9\nStudentas: Petras, Am\u017eius: 16, Pa\u017eymys: 7.5\n</code></pre></p>"},{"location":"Pratybos/U2/#4-zingsnis-static-counter-destruktorius","title":"4 \u017eingsnis: Static counter + destruktorius","text":"<p>Direktorija: <code>U2/04/</code></p>"},{"location":"Pratybos/U2/#reikalavimai_3","title":"Reikalavimai:","text":"<p>Prid\u0117kite statinius narius ir destruktori\u0173:</p>"},{"location":"Pratybos/U2/#studenth","title":"Student.h:","text":"<pre><code>class Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\n    static int sukurtaStudentu;  // Statinis skaitiklis\n\npublic:\n    Student();  // Default konstruktorius\n    Student(const char* v, int a, double p);  // Parametrinis\n    ~Student();  // Destruktorius\n\n    // Getters, setters, utility metodai...\n\n    static int gautiSukurtaStudentu();  // Static getter\n};\n</code></pre>"},{"location":"Pratybos/U2/#studentcpp","title":"Student.cpp:","text":"<p>Statinio nario inicializacija (u\u017e klas\u0117s rib\u0173!): <pre><code>int Student::sukurtaStudentu = 0;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Destruktorius - J\u016aS\u0172 KODAS: <pre><code>Student::~Student() {\n    // U\u017dDUOTIS: suma\u017einti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti [TEST] \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Static getter: <pre><code>int Student::gautiSukurtaStudentu() {\n    return sukurtaStudentu;\n}\n</code></pre></p> <p>Technikos: - Static narys - bendras visiems objektams (ne kiekvienas objektas turi savo kopij\u0105) - Inicializuoti u\u017e klas\u0117s rib\u0173: <code>int Student::sukurtaStudentu = 0;</code> - Destruktorius - automati\u0161kai kvie\u010diamas, kai objektas \"mir\u0161ta\" (i\u0161eina i\u0161 scope) - Alternatyva: Inicializavimo s\u0105ra\u0161as konstruktoriuje (modernesn\u0117 C++ praktika):   <pre><code>Student::Student(const char* v, int a, double p) \n    : amzius(a), pazymys(p)  // Initialization list\n{\n    strcpy(vardas, v);  // char[] reikia body'je\n    sukurtaStudentu++;\n}\n</code></pre></p> <p>Testas: <pre><code>int main() {\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    {\n        Student s1(\"Jonas\", 20, 8.5);\n        Student s2(\"Petras\", 21, 9.0);\n        cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 2\n    }  // s1 ir s2 sunaikinami \u010dia\n\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Student\u0173: 0\n[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n[TEST] Student sukurtas: Petras. Viso student\u0173: 2\nStudent\u0173: 2\n[TEST] Student sunaikintas: Petras. Liko student\u0173: 1\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\nStudent\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U2/#5-zingsnis-pazymiu-masyvas","title":"5 \u017eingsnis: Pa\u017eymi\u0173 masyvas","text":"<p>Direktorija: <code>U2/05/</code></p>"},{"location":"Pratybos/U2/#reikalavimai_4","title":"Reikalavimai:","text":"<p>Pakeiskite klas\u0119 - vietoj vieno pa\u017eymio naudokite pa\u017eymi\u0173 masyv\u0105:</p> <p>Private nariai: <pre><code>private:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: pa\u017eymi\u0173 masyvas\n    static const int MAX_PAZYMIU = 20;\n    double pazymiai[MAX_PAZYMIU];\n    int pazymiuKiekis;\n\n    static int sukurtaStudentu;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymiuKiekis = 0;  // Prad\u017eioje 0 pa\u017eymi\u0173\n    sukurtaStudentu++;\n    // ...\n}\n\nStudent::Student(const char* v, int a) {  // Be pa\u017eymio!\n    strcpy(vardas, v);\n    amzius = a;\n    pazymiuKiekis = 0;\n    sukurtaStudentu++;\n    // ...\n}\n</code></pre></p> <p>Nauji metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pazymiuKiekis &lt; MAX_PAZYMIU\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei viskas OK - prid\u0117ti \u012f masyv\u0105 ir padidinti kiek\u012f\n    // U\u017dDUOTIS: jei ne - i\u0161spausdinti klaidos prane\u0161im\u0105\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: jei pazymiuKiekis == 0, gr\u0105\u017einti 0.0\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 vis\u0173 pa\u017eymi\u0173 (naudoti for cikl\u0105)\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiuKiekis\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;kiekis&gt;): \"\n    // U\u017dDUOTIS: i\u0161spausdinti visus pa\u017eymius atskiriant kableliais\n    // Pavyzdys: \"Pa\u017eymiai (4): 8.5, 9, 7.5, 8\"\n}\n</code></pre> <p>Atnaujinta <code>spausdinti()</code> - J\u016aS\u0172 KODAS: <pre><code>void spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;\"\n    // U\u017dDUOTIS: i\u0161kviesti spausdintiPazymius()\n    // U\u017dDUOTIS: i\u0161spausdinti \"Vidurkis: &lt;vidurkis&gt;\"\n}\n</code></pre></p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20);\n\n    s1.pridetiPazymi(8.5);\n    s1.pridetiPazymi(9.0);\n    s1.pridetiPazymi(7.5);\n    s1.pridetiPazymi(8.0);\n\n    s1.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[TEST] Student sukurtas: Jonas. Viso student\u0173: 1\nStudentas: Jonas, Am\u017eius: 20\nPa\u017eymiai (4): 8.5, 9, 7.5, 8\nVidurkis: 8.25\n[TEST] Student sunaikintas: Jonas. Liko student\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U2/#6-zingsnis-bonus-02-balo-masyvas-vector","title":"6 \u017eingsnis (BONUS +0.2 balo): Masyvas \u2192 vector","text":"<p>Direktorija: <code>U2/06-bonus/</code></p>"},{"location":"Pratybos/U2/#reikalavimai_5","title":"Reikalavimai:","text":"<p>Pakeiskite masyv\u0105 \u012f <code>vector&lt;double&gt;</code> (kaip U1 \u017eingsnis 4):</p> <p>Student.h: <pre><code>#include &lt;vector&gt;  // SVARBU!\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: vector\n    vector&lt;double&gt; pazymiai;\n\n    static int sukurtaStudentu;\n\npublic:\n    // ...\n};\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    // pazymiai jau tu\u0161\u010dias vector (default konstruktorius)\n    sukurtaStudentu++;\n}\n</code></pre></p> <p>Atnaujinti metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar p tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: naudoti pazymiai.push_back(p)\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: patikrinti ar pazymiai.empty()\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 (galite naudoti range-based for: for (double p : pazymiai))\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiai.size()\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;pazymiai.size()&gt;): \"\n    // U\u017dDUOTIS: iteruoti per pazymiai ir spausdinti\n}\n</code></pre> <p>PRIVALUMAI: - \u2705 Dinaminis dydis (ne limitai!) - \u2705 Paprastesnis kodas (<code>push_back()</code>, <code>size()</code>, <code>empty()</code>) - \u2705 Range-based for loop (moderni\u0161kas C++)</p> <p>Testas: tas pats kaip \u017eingsnis 5, bet be limit\u0173.</p>"},{"location":"Pratybos/U2/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/U2/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/\n\u2514\u2500\u2500 U2/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Struct \u2192 Class\n    \u2502   \u251c\u2500\u2500 student_struct.cpp\n    \u2502   \u2514\u2500\u2500 student_class.cpp\n    \u251c\u2500\u2500 02/                \u2190 Konstruktoriai\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 03/                \u2190 Metodai (getters/setters)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 Static + destruktorius\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 05/                \u2190 Pa\u017eymi\u0173 masyvas (FINAL)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 06-bonus/          \u2190 BONUS: vector (neprivalomas)\n        \u251c\u2500\u2500 Student.h\n        \u251c\u2500\u2500 Student.cpp\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U2/#git-workflow","title":"Git workflow:","text":"<pre><code>git add U2/01/\ngit commit -m \"U2: 1 \u017eingsnis - Struct \u2192 Class transformacija\"\ngit push\n\ngit add U2/02/\ngit commit -m \"U2: 2 \u017eingsnis - Konstruktoriai\"\ngit push\n\n# ... ir t.t.\n</code></pre>"},{"location":"Pratybos/U2/#u2readmemd-sablonas","title":"U2/README.md \u0161ablonas:","text":"<pre><code># U2: OOP Pagrindai. Klas\u0117s ir Objektai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-01\n\n---\n\n## \ud83d\udcc1 \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Struct \u2192 Class transformacija |\n| 2 | `02/` | Konstruktoriai (default + parametrinis) |\n| 3 | `03/` | Metodai (getters, setters, pagalbiniai) |\n| 4 | `04/` | Static counter + destruktorius |\n| 5 | `05/` | Pa\u017eymi\u0173 masyvas |\n| 6 | `06-bonus/` | BONUS: array \u2192 vector |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (konstruktoriai)**:\n\n    [TEST] Student sukurtas: Jonas. Viso student\u0173: 1\n    \u2705 VEIKIA\n\n**Testas 2 (pa\u017eymi\u0173 vidurkis)**:\n\n    Pa\u017eymiai (4): 8.5, 9, 7.5, 8\n    Vidurkis: 8.25\n    \u2705 VEIKIA\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Class vs Struct - private vs public\n2. Konstruktoriai inicializuoja objekt\u0105\n3. Static nariai - bendri visiems objektams\n4. Destruktorius - automati\u0161kas cleanup\n5. Masyvas \u2192 vector (lankstesnis!)\n</code></pre>"},{"location":"Pratybos/U2/#moodle-pateikimas","title":"Moodle pateikimas:","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U2_VardasPavarde.zip HEAD U2/ README.md .gitignore\n</code></pre>"},{"location":"Pratybos/U2/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Struct vs Class:</li> <li><code>struct</code> - public pagal nutyl\u0117jim\u0105</li> <li> <p><code>class</code> - private pagal nutyl\u0117jim\u0105</p> </li> <li> <p>Konstruktoriai:</p> </li> <li>Naudokite <code>strcpy()</code> C-style string'ams</li> <li> <p>Inicializuokite visus narius</p> </li> <li> <p>Static nariai:</p> </li> <li>Deklaruoti klas\u0117je: <code>static int sukurtaStudentu;</code></li> <li> <p>Inicializuoti u\u017e klas\u0117s rib\u0173 (<code>.cpp</code>): <code>int Student::sukurtaStudentu = 0;</code></p> </li> <li> <p>Const metodai:</p> </li> <li>Getters visada <code>const</code></li> <li> <p>Pagalbiniai metodai, kurie nekei\u010dia objekto - <code>const</code></p> </li> <li> <p>Patikrinimas:</p> </li> <li>Am\u017eius: <code>&gt; 0 &amp;&amp; &lt; 120</code></li> <li>Pa\u017eymys: <code>&gt;= 0.0 &amp;&amp; &lt;= 10.0</code></li> <li> <p>Masyvo ribos: <code>pazymiuKiekis &lt; MAX_PAZYMIU</code></p> </li> <li> <p>Sen\u0105 kod\u0105 galite i\u0161trinti - Git saugo vis\u0105 istorij\u0105 commit'uose</p> </li> </ol>"},{"location":"Pratybos/U2/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ classes</li> <li>Constructors</li> <li>Destructors</li> <li>Static members</li> <li>Vector container</li> </ul>"},{"location":"Pratybos/U2/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l <code>strcpy()</code> vietoj <code>string</code>? A: Demonstruoti C-style string'us (tradicin\u0117 sintaks\u0117). V\u0117liau (U4+) naudosime <code>std::string</code>.</p> <p>K: Ar privaloma naudoti <code>const</code> metodams? A: Taip, getters ir utility metodai turi b\u016bti <code>const</code> (gera praktika).</p> <p>K: Kod\u0117l static narys inicializuojamas u\u017e klas\u0117s? A: Nes static narys - bendras visiems objektams, ne kiekvieno objekto dalis. Reikia vienos kopijos visai klasei.</p> <p>K: Ar destruktorius visada automatinis? A: Taip, destruktorius automati\u0161kai kvie\u010diamas, kai objektas i\u0161eina i\u0161 scope (arba <code>delete</code> jei dinaminis).</p> <p>K: Ar \u017eingsnis 6 (bonus) privalomas? A: Ne, tai bonus (+0.2 balo). Bet rekomenduojama stipresniems studentams.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/U2_0/","title":"U2: OOP Pagrindai su Student Klase","text":"<p>Savait\u0117s: 3-4 Svoris: 1 balas Terminas: Savait\u0117s 4 pabaiga</p>"},{"location":"Pratybos/U2_0/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas</p>"},{"location":"Pratybos/U2_0/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti kurti C++ klases, suprasti enkapsuliacijos princip\u0105, dirbti su konstruktoriais ir destruktoriais. Praktikuoti statinius narius ir masyv\u0173 evoliucij\u0105 objekt\u0173 kontekste.</p>"},{"location":"Pratybos/U2_0/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Transformuoti C strukt\u016br\u0105 \u012f C++ klas\u0119</li> <li>\u2705 Naudoti <code>private</code> ir <code>public</code> prieigos modifikatorius</li> <li>\u2705 Kurti konstruktorius (default ir parametrinius)</li> <li>\u2705 Kurti ir naudoti getterius/setterius</li> <li>\u2705 Naudoti statinius narius (klas\u0117s lygio duomenys)</li> <li>\u2705 Ra\u0161yti destruktorius su logging</li> <li>\u2705 Dirbti su C-style masyvais klas\u0117je</li> <li>\u2705 (Bonus) Evoliucija nuo masyvo prie <code>vector</code></li> </ul>"},{"location":"Pratybos/U2_0/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/U2_0/#1-zingsnis-struct-class-transformacija","title":"1 \u017eingsnis: Struct \u2192 Class transformacija","text":"<p>Direktorija: <code>U2/01/</code></p> <p>Reikalavimai:</p> <p>Sukurkite 2 failus tame pa\u010diame \u017eingsnyje, kad b\u016bt\u0173 matoma evoliucija:</p>"},{"location":"Pratybos/U2_0/#failas-student_structcpp-c-strukturos-versija","title":"Failas <code>student_struct.cpp</code> - C strukt\u016bros versija:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nstruct Student {\n    char vardas[50];\n    int amzius;\n    double pazymys;\n};\n\nint main() {\n    Student s1;\n    strcpy(s1.vardas, \"Jonas\");\n    s1.amzius = 20;\n    s1.pazymys = 8.5;\n\n    cout &lt;&lt; \"Studentas: \" &lt;&lt; s1.vardas \n         &lt;&lt; \", Am\u017eius: \" &lt;&lt; s1.amzius \n         &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; s1.pazymys &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Kompiliacija: <pre><code>g++ student_struct.cpp -o struct_versija\n./struct_versija\n</code></pre></p>"},{"location":"Pratybos/U2_0/#failas-student_classcpp-c-klases-versija","title":"Failas <code>student_class.cpp</code> - C++ klas\u0117s versija:","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nusing namespace std;\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\npublic:\n    // Metodai prid\u0117ti 3 \u017eingsnyje\n};\n\nint main() {\n    // TODO: Sukurti student\u0105 ir i\u0161spausdinti\n    return 0;\n}\n</code></pre> <p>SVARBU: - <code>struct</code> - visi nariai public pagal nutyl\u0117jim\u0105 - <code>class</code> - visi nariai private pagal nutyl\u0117jim\u0105 - Parodyti skirtum\u0105 tarp <code>struct</code> (visk\u0105 galima pasiekti) ir <code>class</code> (reikia metod\u0173)</p> <p>Testas: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/01/\n\u251c\u2500\u2500 student_struct.cpp\n\u251c\u2500\u2500 student_class.cpp\n\u2514\u2500\u2500 README.md (neprivalomas)\n</code></pre></p>"},{"location":"Pratybos/U2_0/#2-zingsnis-konstruktoriai","title":"2 \u017eingsnis: Konstruktoriai","text":"<p>Direktorija: <code>U2/02/</code></p> <p>Reikalavimai:</p> <p>Sukurkite Student klas\u0119 su konstruktoriais:</p>"},{"location":"Pratybos/U2_0/#student-klase","title":"Student klas\u0117:","text":"<p>Private nariai: - <code>char vardas[50]</code> - studento vardas - <code>int amzius</code> - studento am\u017eius - <code>double pazymys</code> - studento pa\u017eymys (vienas)</p> <p>Public konstruktoriai:</p> <p>1. Default konstruktorius: <pre><code>Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    cout &lt;&lt; \"[DEBUG] Student sukurtas (default): \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>2. Parametrinis konstruktorius: <pre><code>Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    cout &lt;&lt; \"[DEBUG] Student sukurtas: \" &lt;&lt; vardas &lt;&lt; endl;\n}\n</code></pre></p> <p>SVARBU: - Naudokite <code>strcpy()</code> (i\u0161 <code>&lt;cstring&gt;</code>) C-style string'ams - Konstruktoriai inicializuoja objekt\u0105 suk\u016brimo metu - Logging padeda matyti, kada objektai kuriami</p> <p>Testas: <pre><code>int main() {\n    Student s1;  // Default konstruktorius\n    Student s2(\"Jonas\", 20, 8.5);  // Parametrinis\n    Student s3(\"Petras\", 21, 9.0);\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[DEBUG] Student sukurtas (default): Nezinomas\n[DEBUG] Student sukurtas: Jonas\n[DEBUG] Student sukurtas: Petras\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U2/02/\n\u251c\u2500\u2500 Student.h\n\u251c\u2500\u2500 Student.cpp\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/U2_0/#3-zingsnis-metodai-getters-setters-utility","title":"3 \u017eingsnis: Metodai (getters, setters, utility)","text":"<p>Direktorija: <code>U2/03/</code></p> <p>Reikalavimai:</p> <p>Prid\u0117kite metodus prie Student klas\u0117s:</p>"},{"location":"Pratybos/U2_0/#public-metodai","title":"Public metodai:","text":"<p>Getters (const metodai) - PAVYZDYS: <pre><code>const char* gautiVarda() const { \n    return vardas; \n}\n\nint gautiAmziu() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti am\u017ei\u0173\n}\n\ndouble gautiPazymi() const { \n    // U\u017dDUOTIS: gr\u0105\u017einti pa\u017eym\u012f\n}\n</code></pre></p> <p>Setters - J\u016aS\u0172 KODAS: <pre><code>void nustatytiVarda(const char* v) {\n    // U\u017dDUOTIS: nukopijuoti vard\u0105 su strcpy()\n}\n\nvoid nustatytiAmziu(int a) {\n    // U\u017dDUOTIS: patikrinti ar am\u017eius tinkamas (&gt; 0 ir &lt; 120)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n\nvoid nustatytiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei taip - priskirti\n}\n</code></pre></p> <p>Utility metodai - J\u016aS\u0172 KODAS: <pre><code>bool arPilnametis() const {\n    // U\u017dDUOTIS: gr\u0105\u017einti true jei amzius &gt;= 18, kitaip false\n}\n\nvoid spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;, Pa\u017eymys: &lt;pazymys&gt;\"\n    // U\u017dDUOTIS: jei pilnametis, prid\u0117ti \" (pilnametis)\"\n}\n</code></pre></p> <p>SVARBU: - <code>const</code> metodai - nekei\u010dia objekto b\u016bsenos - Getters - tik skaito duomenis - Setters - modifikuoja duomenis (su validacija!) - Utility metodai - skai\u010diuoja ar tikrina logik\u0105</p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20, 8.5);\n    s1.spausdinti();\n\n    s1.nustatytiPazymi(9.0);\n    cout &lt;&lt; \"Naujas pa\u017eymys: \" &lt;&lt; s1.gautiPazymi() &lt;&lt; endl;\n\n    Student s2(\"Petras\", 16, 7.5);\n    s2.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Studentas: Jonas, Am\u017eius: 20, Pa\u017eymys: 8.5 (pilnametis)\nNaujas pa\u017eymys: 9\nStudentas: Petras, Am\u017eius: 16, Pa\u017eymys: 7.5\n</code></pre></p>"},{"location":"Pratybos/U2_0/#4-zingsnis-static-counter-destruktorius","title":"4 \u017eingsnis: Static counter + destruktorius","text":"<p>Direktorija: <code>U2/04/</code></p> <p>Reikalavimai:</p> <p>Prid\u0117kite statinius narius ir destruktori\u0173:</p>"},{"location":"Pratybos/U2_0/#studenth","title":"Student.h:","text":"<pre><code>class Student {\nprivate:\n    char vardas[50];\n    int amzius;\n    double pazymys;\n\n    static int sukurtaStudentu;  // Statinis skaitiklis\n\npublic:\n    Student();  // Default konstruktorius\n    Student(const char* v, int a, double p);  // Parametrinis\n    ~Student();  // Destruktorius\n\n    // Getters, setters, utility metodai...\n\n    static int gautiSukurtaStudentu();  // Static getter\n};\n</code></pre>"},{"location":"Pratybos/U2_0/#studentcpp","title":"Student.cpp:","text":"<p>Statinio nario inicializacija (u\u017e klas\u0117s rib\u0173!): <pre><code>int Student::sukurtaStudentu = 0;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymys = 0.0;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti debug \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n\nStudent::Student(const char* v, int a, double p) {\n    strcpy(vardas, v);\n    amzius = a;\n    pazymys = p;\n    // U\u017dDUOTIS: padidinti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti debug \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Destruktorius - J\u016aS\u0172 KODAS: <pre><code>Student::~Student() {\n    // U\u017dDUOTIS: suma\u017einti sukurtaStudentu\n    // U\u017dDUOTIS: i\u0161spausdinti debug \u017einut\u0119 su vardas ir sukurtaStudentu\n}\n</code></pre></p> <p>Static getter: <pre><code>int Student::gautiSukurtaStudentu() {\n    return sukurtaStudentu;\n}\n</code></pre></p> <p>SVARBU: - Static narys - bendras visiems objektams (ne kiekvienas objektas turi savo kopij\u0105) - Inicializuoti u\u017e klas\u0117s rib\u0173: <code>int Student::sukurtaStudentu = 0;</code> - Destruktorius - automati\u0161kai kvie\u010diamas, kai objektas \"mir\u0161ta\" (i\u0161eina i\u0161 scope)</p> <p>Testas: <pre><code>int main() {\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    {\n        Student s1(\"Jonas\", 20, 8.5);\n        Student s2(\"Petras\", 21, 9.0);\n        cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 2\n    }  // s1 ir s2 sunaikinami \u010dia\n\n    cout &lt;&lt; \"Student\u0173: \" &lt;&lt; Student::gautiSukurtaStudentu() &lt;&lt; endl;  // 0\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>Student\u0173: 0\n[DEBUG] Student sukurtas: Jonas. Viso student\u0173: 1\n[DEBUG] Student sukurtas: Petras. Viso student\u0173: 2\nStudent\u0173: 2\n[DEBUG] Student sunaikintas: Petras. Liko student\u0173: 1\n[DEBUG] Student sunaikintas: Jonas. Liko student\u0173: 0\nStudent\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U2_0/#5-zingsnis-evoliucija-pazymiu-masyvas","title":"5 \u017eingsnis: Evoliucija \u2192 pa\u017eymi\u0173 masyvas","text":"<p>Direktorija: <code>U2/05/</code></p> <p>Reikalavimai:</p> <p>Evoliucionuokite klas\u0119 nuo vieno pa\u017eymio prie pa\u017eymi\u0173 masyvo:</p>"},{"location":"Pratybos/U2_0/#senasis-kodas-uzkomentuoti-bet-palikti-matytis","title":"Senasis kodas (U\u017dKOMENTUOTI, bet palikti matytis!):","text":"<pre><code>// SENASIS KODAS (vienas pa\u017eymys):\n// private:\n//     double pazymys;\n//\n// public:\n//     double gautiPazymi() const { return pazymys; }\n//     void nustatytiPazymi(double p) { pazymys = p; }\n</code></pre>"},{"location":"Pratybos/U2_0/#naujasis-kodas","title":"Naujasis kodas:","text":"<p>Private nariai: <pre><code>private:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: pa\u017eymi\u0173 masyvas\n    static const int MAX_PAZYMIU = 20;\n    double pazymiai[MAX_PAZYMIU];\n    int pazymiuKiekis;\n\n    static int sukurtaStudentu;\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    pazymiuKiekis = 0;  // Prad\u017eioje 0 pa\u017eymi\u0173\n    sukurtaStudentu++;\n    // ...\n}\n\nStudent::Student(const char* v, int a) {  // Be pa\u017eymio!\n    strcpy(vardas, v);\n    amzius = a;\n    pazymiuKiekis = 0;\n    sukurtaStudentu++;\n    // ...\n}\n</code></pre></p> <p>Nauji metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar pazymiuKiekis &lt; MAX_PAZYMIU\n    // U\u017dDUOTIS: patikrinti ar pa\u017eymys tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: jei viskas OK - prid\u0117ti \u012f masyv\u0105 ir padidinti kiek\u012f\n    // U\u017dDUOTIS: jei ne - i\u0161spausdinti klaidos prane\u0161im\u0105\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: jei pazymiuKiekis == 0, gr\u0105\u017einti 0.0\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 vis\u0173 pa\u017eymi\u0173 (naudoti for cikl\u0105)\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiuKiekis\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;kiekis&gt;): \"\n    // U\u017dDUOTIS: i\u0161spausdinti visus pa\u017eymius atskiriant kableliais\n    // Pavyzdys: \"Pa\u017eymiai (4): 8.5, 9, 7.5, 8\"\n}\n</code></pre> <p>Atnaujinta <code>spausdinti()</code> - J\u016aS\u0172 KODAS: <pre><code>void spausdinti() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Studentas: &lt;vardas&gt;, Am\u017eius: &lt;amzius&gt;\"\n    // U\u017dDUOTIS: i\u0161kviesti spausdintiPazymius()\n    // U\u017dDUOTIS: i\u0161spausdinti \"Vidurkis: &lt;vidurkis&gt;\"\n}\n</code></pre></p> <p>SVARBU: - U\u017ekomentuoti sen\u0105 kod\u0105 (ne i\u0161trinti!) - tai \"evoliucijos\" principas - Masyvas <code>double pazymiai[MAX_PAZYMIU]</code> + <code>int pazymiuKiekis</code> - kaip U1 \u017eingsnis 1 - Prid\u0117ti validacij\u0105 (<code>pazymiuKiekis &lt; MAX_PAZYMIU</code>)</p> <p>Testas: <pre><code>int main() {\n    Student s1(\"Jonas\", 20);\n\n    s1.pridetiPazymi(8.5);\n    s1.pridetiPazymi(9.0);\n    s1.pridetiPazymi(7.5);\n    s1.pridetiPazymi(8.0);\n\n    s1.spausdinti();\n\n    return 0;\n}\n</code></pre></p> <p>I\u0161vestis: <pre><code>[DEBUG] Student sukurtas: Jonas. Viso student\u0173: 1\nStudentas: Jonas, Am\u017eius: 20\nPa\u017eymiai (4): 8.5, 9, 7.5, 8\nVidurkis: 8.25\n[DEBUG] Student sunaikintas: Jonas. Liko student\u0173: 0\n</code></pre></p>"},{"location":"Pratybos/U2_0/#6-zingsnis-bonus-02-balo-array-vector-evoliucija","title":"6 \u017eingsnis (BONUS +0.2 balo): array \u2192 vector evoliucija","text":"<p>Direktorija: <code>U2/06-bonus/</code></p> <p>Reikalavimai:</p> <p>Evoliucionuokite nuo masyvo prie <code>vector&lt;double&gt;</code> (kaip U1 \u017eingsnis 4):</p>"},{"location":"Pratybos/U2_0/#senasis-kodas-uzkomentuoti","title":"Senasis kodas (U\u017dKOMENTUOTI!):","text":"<pre><code>// SENASIS KODAS (masyvas):\n// private:\n//     static const int MAX_PAZYMIU = 20;\n//     double pazymiai[MAX_PAZYMIU];\n//     int pazymiuKiekis;\n</code></pre>"},{"location":"Pratybos/U2_0/#naujasis-kodas_1","title":"Naujasis kodas:","text":"<p>Student.h: <pre><code>#include &lt;vector&gt;  // SVARBU!\n\nclass Student {\nprivate:\n    char vardas[50];\n    int amzius;\n\n    // NAUJAS KODAS: vector\n    vector&lt;double&gt; pazymiai;\n\n    static int sukurtaStudentu;\n\npublic:\n    // ...\n};\n</code></pre></p> <p>Konstruktoriai (atnaujinti): <pre><code>Student::Student() {\n    strcpy(vardas, \"Nezinomas\");\n    amzius = 0;\n    // pazymiai jau tu\u0161\u010dias vector (default konstruktorius)\n    sukurtaStudentu++;\n}\n</code></pre></p> <p>Atnaujinti metodai - J\u016aS\u0172 KODAS:</p> <pre><code>void pridetiPazymi(double p) {\n    // U\u017dDUOTIS: patikrinti ar p tinkamas (0.0 - 10.0)\n    // U\u017dDUOTIS: naudoti pazymiai.push_back(p)\n}\n\ndouble skaiciuotiVidurki() const {\n    // U\u017dDUOTIS: patikrinti ar pazymiai.empty()\n    // U\u017dDUOTIS: suskai\u010diuoti sum\u0105 (galite naudoti range-based for: for (double p : pazymiai))\n    // U\u017dDUOTIS: gr\u0105\u017einti suma / pazymiai.size()\n}\n\nvoid spausdintiPazymius() const {\n    // U\u017dDUOTIS: i\u0161spausdinti \"Pa\u017eymiai (&lt;pazymiai.size()&gt;): \"\n    // U\u017dDUOTIS: iteruoti per pazymiai ir spausdinti\n}\n</code></pre> <p>PRIVALUMAI: - \u2705 Dinaminis dydis (ne limitai!) - \u2705 Paprastesnis kodas (<code>push_back()</code>, <code>size()</code>, <code>empty()</code>) - \u2705 Range-based for loop (moderni\u0161kas C++)</p> <p>Testas: tas pats kaip \u017eingsnis 5, bet be limit\u0173.</p>"},{"location":"Pratybos/U2_0/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/U2_0/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/\n\u2514\u2500\u2500 U2/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Struct \u2192 Class\n    \u2502   \u251c\u2500\u2500 student_struct.cpp\n    \u2502   \u2514\u2500\u2500 student_class.cpp\n    \u251c\u2500\u2500 02/                \u2190 Konstruktoriai\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 03/                \u2190 Metodai (getters/setters)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 Static + destruktorius\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 05/                \u2190 Pa\u017eymi\u0173 masyvas (FINAL)\n    \u2502   \u251c\u2500\u2500 Student.h\n    \u2502   \u251c\u2500\u2500 Student.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 06-bonus/          \u2190 BONUS: vector (neprivalomas)\n        \u251c\u2500\u2500 Student.h\n        \u251c\u2500\u2500 Student.cpp\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/U2_0/#git-workflow","title":"Git workflow:","text":"<pre><code>git add U2/01/\ngit commit -m \"U2: 1 \u017eingsnis - Struct \u2192 Class transformacija\"\ngit push\n\ngit add U2/02/\ngit commit -m \"U2: 2 \u017eingsnis - Konstruktoriai\"\ngit push\n\n# ... ir t.t.\n</code></pre>"},{"location":"Pratybos/U2_0/#u2readmemd-sablonas","title":"U2/README.md \u0161ablonas:","text":"<p><pre><code># U2: OOP Pagrindai su Student Klase\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-01\n\n---\n\n## \ud83d\udcc1 \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Struct \u2192 Class transformacija |\n| 2 | `02/` | Konstruktoriai (default + parametrinis) |\n| 3 | `03/` | Metodai (getters, setters, utility) |\n| 4 | `04/` | Static counter + destruktorius |\n| 5 | `05/` | Pa\u017eymi\u0173 masyvas (evoliucija) |\n| 6 | `06-bonus/` | BONUS: array \u2192 vector |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (konstruktoriai)**:\n</code></pre> [DEBUG] Student sukurtas: Jonas. Viso student\u0173: 1 \u2705 VEIKIA <pre><code>**Testas 2 (pa\u017eymi\u0173 vidurkis)**:\n</code></pre> Pa\u017eymiai (4): 8.5, 9, 7.5, 8 Vidurkis: 8.25 \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Class vs Struct - private vs public\n2. Konstruktoriai inicializuoja objekt\u0105\n3. Static nariai - bendri visiems objektams\n4. Destruktorius - automati\u0161kas cleanup\n5. Masyvas \u2192 vector evoliucija (lankstesnis!)\n</code></pre></p>"},{"location":"Pratybos/U2_0/#moodle-pateikimas","title":"Moodle pateikimas:","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U2_VardasPavarde.zip HEAD U2/ README.md .gitignore\n</code></pre>"},{"location":"Pratybos/U2_0/#vertinimo-kriterijai","title":"\u2705 Vertinimo kriterijai","text":"Kriterijus Balai Programa kompiliuojasi be klaid\u0173 10% Struct \u2192 Class transformacija veikia 10% Konstruktoriai veikia (default + parametrinis) 15% Getters/setters veikia 10% Utility metodai veikia (<code>arPilnametis()</code>, <code>spausdinti()</code>) 10% Static counter veikia 15% Destruktorius su logging veikia 10% Pa\u017eymi\u0173 masyvas + vidurkis veikia 15% README.md su testais 5% TOTAL 100% BONUS (\u017eingsnis 6: vector) +0.2 balo"},{"location":"Pratybos/U2_0/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Struct vs Class:</li> <li><code>struct</code> - public pagal nutyl\u0117jim\u0105</li> <li> <p><code>class</code> - private pagal nutyl\u0117jim\u0105</p> </li> <li> <p>Konstruktoriai:</p> </li> <li>Naudokite <code>strcpy()</code> C-style string'ams</li> <li> <p>Inicializuokite visus narius</p> </li> <li> <p>Static nariai:</p> </li> <li>Deklaruoti klas\u0117je: <code>static int sukurtaStudentu;</code></li> <li> <p>Inicializuoti u\u017e klas\u0117s rib\u0173 (<code>.cpp</code>): <code>int Student::sukurtaStudentu = 0;</code></p> </li> <li> <p>Const metodai:</p> </li> <li>Getters visada <code>const</code></li> <li> <p>Utility metodai, kurie nesikeis objekto - <code>const</code></p> </li> <li> <p>Validacija:</p> </li> <li>Am\u017eius: <code>&gt; 0 &amp;&amp; &lt; 120</code></li> <li>Pa\u017eymys: <code>&gt;= 0.0 &amp;&amp; &lt;= 10.0</code></li> <li> <p>Masyvo ribos: <code>pazymiuKiekis &lt; MAX_PAZYMIU</code></p> </li> <li> <p>Evoliucija:</p> </li> <li>U\u017ekomentuokite sen\u0105 kod\u0105 (ne i\u0161trinkite!)</li> <li>Tai leid\u017eia matyti \"prie\u0161 ir po\"</li> </ol>"},{"location":"Pratybos/U2_0/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ classes</li> <li>Constructors</li> <li>Destructors</li> <li>Static members</li> <li>Vector container</li> </ul>"},{"location":"Pratybos/U2_0/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l <code>strcpy()</code> vietoj <code>string</code>? A: Demonstruoti C-style string'us (tradicin\u0117 sintaks\u0117). V\u0117liau (U4+) naudosime <code>std::string</code>.</p> <p>K: Ar privaloma naudoti <code>const</code> metodams? A: Taip, getters ir utility metodai turi b\u016bti <code>const</code> (gera praktika).</p> <p>K: Kod\u0117l static narys inicializuojamas u\u017e klas\u0117s? A: Nes static narys - bendras visiems objektams, ne kiekvieno objekto dalis. Reikia vienos kopijos visai klasei.</p> <p>K: Ar destruktorius visada automatinis? A: Taip, destruktorius automati\u0161kai kvie\u010diamas, kai objektas i\u0161eina i\u0161 scope (arba <code>delete</code> jei dinaminis).</p> <p>K: Ar \u017eingsnis 6 (bonus) privalomas? A: Ne, tai bonus (+0.2 balo). Bet rekomenduojama stipresniems studentams.</p> <p>K: Kiek bal\u0173 u\u017e u\u017ekomentuot\u0105 sen\u0105 kod\u0105? A: Tai privaloma \u017eingsniuose 5-6 (dalis \"evoliucijos\" principo). Be to - minusas.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/Tvarka/README-assignment/","title":"U[N]: [U\u017eduoties pavadinimas]","text":"<p>B\u016bsena: \u2705 Atlikta Pateikta: 2026-XX-XX</p>"},{"location":"Pratybos/Tvarka/README-assignment/#zingsniai","title":"\ud83d\udcdd \u017dingsniai","text":"\u017dingsnis Direktorija Apra\u0161ymas B\u016bsena 1 <code>01/</code> [Trumpas apra\u0161ymas] \u2705 2 <code>02/</code> [Trumpas apra\u0161ymas] \u2705 3 <code>03/</code> [Trumpas apra\u0161ymas] \u2705 <p>Legenda: \u2705 Atlikta | \ud83d\udd04 Vykdoma | \u23f3 Laukia</p>"},{"location":"Pratybos/Tvarka/README-assignment/#testavimas","title":"\ud83e\uddea Testavimas","text":"<p>Testas 1: [Apra\u0161ymas]</p> <pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 VEIKIA</p> <p>Testas 2: [Apra\u0161ymas]</p> <pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 VEIKIA</p>"},{"location":"Pratybos/Tvarka/README-assignment/#izvalgos","title":"\ud83d\udcad \u012e\u017evalgos","text":"<ol> <li>[Pagrindin\u0117 \u012f\u017evalga 1]</li> <li>[Pagrindin\u0117 \u012f\u017evalga 2]</li> <li>[Pagrindin\u0117 \u012f\u017evalga 3]</li> </ol>"},{"location":"Pratybos/Tvarka/README-assignment/#problemos-jei-buvo","title":"\u26a0\ufe0f Problemos (jei buvo)","text":"<p>Problema 1: [Apra\u0161ymas] Sprendimas: [Kaip i\u0161sprend\u0117te]</p>"},{"location":"Pratybos/Tvarka/README-assignment/#kompiliavimas","title":"\ud83d\udce6 Kompiliavimas","text":"<pre><code>cd 03/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/README-assignment/#nuorodos","title":"\ud83d\udd17 Nuorodos","text":"<ul> <li>GitLab commit'ai: [nuoroda \u012f commit history]</li> <li>U\u017eduoties apra\u0161ymas: U[N].md</li> </ul>"},{"location":"Pratybos/Tvarka/README-project/","title":"Objektinis Programavimas C++ (2026)","text":"<p>Studentas: [Vardas Pavard\u0117] Grup\u0117: [Grup\u0117s numeris] GitLab: <code>https://gitlab.mif.vu.lt/[username]/cpp-2026</code></p>"},{"location":"Pratybos/Tvarka/README-project/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md          \u2190 \u0160is failas\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/                \u2190 C++ primityvai\n\u251c\u2500\u2500 U2/                \u2190 IntList (RAII)\n\u251c\u2500\u2500 U3/                \u2190 Kompozicija\n\u251c\u2500\u2500 U4/                \u2190 Deep Copy\n\u251c\u2500\u2500 U5/                \u2190 Operatoriai + Exceptions\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"Pratybos/Tvarka/README-project/#uzduociu-busena","title":"\u2705 U\u017eduo\u010di\u0173 b\u016bsena","text":"U\u017eduotis Tema Terminas B\u016bsena Pateikta U1 C++ primityvai 2026-02-14 \u2705 Atlikta 2026-02-13 U2 IntList (RAII) 2026-02-28 \ud83d\udd04 Vykdoma - U3 Kompozicija 2026-03-14 \u23f3 Laukia - U4 Deep Copy 2026-03-28 \u23f3 Laukia - U5 Operatoriai 2026-04-11 \u23f3 Laukia - <p>Legenda: \u2705 Atlikta | \ud83d\udd04 Vykdoma | \u23f3 Laukia | \u274c Praleista</p>"},{"location":"Pratybos/Tvarka/README-project/#kompiliavimas","title":"\ud83d\udee0\ufe0f Kompiliavimas","text":"<p>Kiekviena u\u017eduotis turi savo Makefile:</p> <pre><code>cd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/README-project/#pastabos","title":"\ud83d\udcdd Pastabos","text":"<ul> <li>Commit'ai daromi po kiekvieno \u017eingsnio</li> </ul>"},{"location":"Pratybos/Tvarka/README-project/#klausimai-destytojui","title":"Klausimai d\u0117stytojui","text":""},{"location":"Pratybos/Tvarka/README-step/","title":"U[N]: \u017dingsnis [N] - [Pavadinimas]","text":"<p>PASTABA: \u0160is failas neprivalomas, jei u\u017eduoties \u017eingsni\u0173 atlikimas pakankamai dokumentuotas u\u017eduoties README. Tiesiog - pasibandykite!</p>"},{"location":"Pratybos/Tvarka/README-step/#kas-padaryta","title":"\ud83d\udcdd Kas padaryta","text":"<ul> <li>[x] [U\u017eduotis 1]</li> <li>[x] [U\u017eduotis 2]</li> <li>[ ] [U\u017eduotis 3]</li> </ul>"},{"location":"Pratybos/Tvarka/README-step/#testavimas","title":"\ud83e\uddea Testavimas","text":"<pre><code>Input: [\u012fvestis]\nOutput: [i\u0161vestis]\n</code></pre> <p>\u2705 Veikia | \u23f3 Dar ne | \u274c Neveikia</p>"},{"location":"Pratybos/Tvarka/README-step/#pastabos","title":"\ud83d\udcad Pastabos","text":"<p>[J\u016bs\u0173 pastabos, mintys, problemos]</p>"},{"location":"Pratybos/Tvarka/README-step/#kompiliavimas","title":"\ud83d\udce6 Kompiliavimas","text":"<pre><code>make\n./programa\n</code></pre> <p>Gr\u012f\u017eti: \u2190 U[N] README</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://git.mif.vu.lt</code></li> <li>Prisijunkite su MIF (!) kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code> (svarbu!)</li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Settings \u2192 Members</li> <li>Add member: <code>[d\u0117stytojo username]</code></li> <li>Role: <code>Maintainer</code></li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://gitlab.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#pilna-struktura","title":"Pilna strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis (FINAL)\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina \u274c NE"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#zingsnis-2-atlikti-uzduoties-u1-1-zingsni","title":"\u017dingsnis 2: Atlikti u\u017eduoties U1 1 \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#zingsnis-4-atlikti-uzduoties-u1-2-zingsni","title":"\u017dingsnis 4: Atlikti u\u017eduoties U1 2 \u017eingsn\u012f","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#zingsnis-5-po-visu-zingsniu-uzduoties-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - u\u017eduoties README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 ...)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#2-uzduoties-readme-u1readmemd-privalomas","title":"2. U\u017eduoties README (<code>/U1/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-XX-XX\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n```bash\nInput: 42 17 99 5 0\nOutput: 5 17 42 99\n```bash\n\u2705 VEIKIA\n\n\n**Testas 2 (\u017eod\u017eiai)**:\n```bash\nInput: obuolys bananas citrina -\nOutput: bananas citrina obuolys\n```bash\n\u2705 VEIKIA\n\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Modulin\u0117 strukt\u016bra - `.h`/.`cpp` separacija patogu\n2. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n3. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n</code></pre> <p>Minimumas (jei tingite): - \u2705 \u017dingsni\u0173 lentel\u0117 - \u2705 Bent 1-2 testai - \u2705 Kompiliavimo instrukcijos</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#3-zingsnio-readme-u101readmemd-neprivalomas","title":"3. \u017dingsnio README (<code>/U1/01/README.md</code>) - NEPRIVALOMAS","text":"<p>Jei norite, galite prid\u0117ti trumpas pastabas kiekviename \u017eingsnyje!</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#pateikimas-moodle","title":"\ud83d\udce6 Pateikimas Moodle","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#1-budas-git-archive-rekomenduojama","title":"1 b\u016bdas: Git archive (rekomenduojama)","text":"<pre><code>cd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#archyvo-vardas","title":"Archyvo vardas:","text":"<pre><code>U[numeris]_VardasPavarde.zip\n\nPavyzd\u017eiai:\n- U1_JonasJonaitis.zip\n- U2_PetrasPetraitis.zip\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):    <pre><code>GitLab repo: https://gitlab.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre></li> <li>Submit</li> </ol> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (Stack Evolution stilius).</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (neduoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, nelaukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#k-i-ka-kreiptis-pagalbos","title":"K: \u012e k\u0105 kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (auditorijoje, Teams arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kodo!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://git.mif.vu.lt</code></li> <li>Prisijunkite su MIF (!) kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code> (svarbu!)</li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Settings \u2192 Members</li> <li>Add member: <code>[d\u0117stytojo username]</code></li> <li>Role: <code>Maintainer</code></li> </ol>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://gitlab.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#pilna-struktura","title":"Pilna strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis (FINAL)\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina \u274c NE"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#zingsnis-2-atlikti-uzduoties-u1-1-zingsni","title":"\u017dingsnis 2: Atlikti u\u017eduoties U1 1 \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#zingsnis-4-atlikti-uzduoties-u1-2-zingsni","title":"\u017dingsnis 4: Atlikti u\u017eduoties U1 2 \u017eingsn\u012f","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#zingsnis-5-po-visu-zingsniu-uzduoties-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - u\u017eduoties README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 ...)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":"<p>Kiekvienas lygis turi savo \u0161ablon\u0105 (<code>README-templates/</code> direktorijoje). Nukopijuokite \u0161ablon\u0105 \u012f reikiam\u0105 vieta ir u\u017epildykite savo duomenys.</p> Lygis Failas \u0160ablonas Privaloma? Projektas <code>/README.md</code> <code>README-project.md</code> \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> <code>README-assignment.md</code> \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> <code>README-step.md</code> \u274c NE"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas: <code>README-project.md</code></p> <p>Turi: - Studentas: vardas, pavard\u0117, grup\u0117, GitLab URL - Projekto strukt\u016bra (direktorij\u0173 s\u0105ra\u0161as) - U\u017eduo\u010di\u0173 b\u016bsenos lentel\u0117 (atnaujinti po kiekvienos pateiktos u\u017eduoties)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#2-uzduoties-readme-u1readmemd-privalomas","title":"2. U\u017eduoties README (<code>/U1/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas: <code>README-assignment.md</code></p> <p>Turi: - \u017dingsni\u0173 lentel\u0117 su apra\u0161ymais ir b\u016bsenomis - Bent 1-2 testai (Input/Output formatu) - Kompiliavimo instrukcijos (<code>make</code> arba <code>g++</code>)</p> <p>Rekomenduojama papildyti: - \u012e\u017evalgos (k\u0105 naujo i\u0161mokote) - Problemos ir j\u0173 sprendimai</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#3-zingsnio-readme-u101readmemd-neprivalomas","title":"3. \u017dingsnio README (<code>/U1/01/README.md</code>) - NEPRIVALOMAS","text":"<p>\u0160ablonas: <code>README-step.md</code></p> <p>Trumpos pastabos per \u017eingsniui \u2014 naudingia debug'inimo metu, bet neprivaloma.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#pateikimas-moodle","title":"\ud83d\udce6 Pateikimas Moodle","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#1-budas-git-archive-rekomenduojama","title":"1 b\u016bdas: Git archive (rekomenduojama)","text":"<pre><code>cd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#archyvo-vardas","title":"Archyvo vardas:","text":"<pre><code>U[numeris]_VardasPavarde.zip\n\nPavyzd\u017eiai:\n- U1_JonasJonaitis.zip\n- U2_PetrasPetraitis.zip\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):    <pre><code>GitLab repo: https://gitlab.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre></li> <li>Submit</li> </ol> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis i\u0161 komandin\u0117s eilut\u0117s (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite po kiekvieno \u017eingsnio.</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (neduoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Prad\u0117ti anks\u010diau, nelaukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#k-i-ka-kreiptis-pagalbos","title":"K: \u012e k\u0105 kreiptis pagalbos?","text":"<p>A: 1. Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Klausti d\u0117stytojo (auditorijoje, Teams arba email) 4. Klausti kolegos (bet ne kopijuoti kodo!)</p>"},{"location":"Pratybos/Tvarka/UzduociuGidasFull2/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/","title":"U\u017eduo\u010di\u0173 Gidas (Trumpa versija)","text":"<p>Tikslas: Greitas start - tik essentials! Pilna versija: UzduotiuGidas-full.md \u2190 Detalesn\u0117 info</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#quick-start-5-zingsniai","title":"\ud83d\ude80 Quick Start (5 \u017eingsniai)","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#1-gitlab-projektas","title":"1. GitLab projektas","text":"<pre><code># GitLab \u2192 New Project \u2192 cpp-2026\n# Settings \u2192 Members \u2192 Add d\u0117stytoj\u0105 (Reporter)\ngit clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#2-projekto-struktura","title":"2. Projekto strukt\u016bra","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md          \u2190 Naudok \u0161ablon\u0105: README-project.md\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 U1/\n    \u251c\u2500\u2500 README.md      \u2190 Naudok \u0161ablon\u0105: README-assignment.md\n    \u251c\u2500\u2500 01/            \u2190 \u017dingsnis 1\n    \u251c\u2500\u2500 02/            \u2190 \u017dingsnis 2\n    \u2514\u2500\u2500 03/            \u2190 \u017dingsnis 3 (FINAL)\n</code></pre> <p>README \u0161ablonai: <code>README-templates/</code> direktorijoje</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#3-git-workflow-po-kiekvieno-zingsnio","title":"3. Git workflow (po kiekvieno \u017eingsnio!)","text":"<pre><code># Po \u017eingsnio 1\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - [apra\u0161ymas]\"\ngit push\n\n# Po \u017eingsnio 2\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - [apra\u0161ymas]\"\ngit push\n\n# ... ir t.t.\n</code></pre> <p>SVARBU: Commit'inti po kiekvieno \u017eingsnio, ne vis\u0105 u\u017eduot\u012f vienu kartu!</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#4-readmemd-uzpildymas","title":"4. README.md u\u017epildymas","text":"<p>Po vis\u0173 \u017eingsni\u0173:</p> <pre><code>cd U1\n# Nukopijuok \u0161ablon\u0105\ncp ../README-templates/README-assignment.md README.md\n# Redaguok (u\u017epildyk lenteles, testus)\ngit add README.md\ngit commit -m \"U1: README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#5-moodle-pateikimas","title":"5. Moodle pateikimas","text":"<pre><code># Sukurti archyv\u0105\ncd cpp-2026\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/ README.md .gitignore\n\n# \u012ekelti \u012f Moodle + prid\u0117ti GitLab URL\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#readme-hierarchija","title":"\ud83d\udcdd README hierarchija","text":"Lygis Failas \u0160ablonas Privaloma? Projektas <code>/README.md</code> <code>README-project.md</code> \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> <code>README-assignment.md</code> \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> <code>README-step.md</code> \u274c NE"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#vertinimas","title":"\u2705 Vertinimas","text":"Kriterijus % Funkcionalumas 50% Kodo kokyb\u0117 30% Git + README 20% <p>Commit'\u0173 vertinimas: - Po kiekvieno \u017eingsnio: 100% - Keli commit'ai: 70% - Vienas commit: 30%</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#gitignore-butinas","title":"\u2699\ufe0f .gitignore (b\u016btinas!)","text":"<p>Sukurti <code>.gitignore</code> root direktorijoje:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#duk-top-5","title":"\u2753 DUK (Top 5)","text":"<p>K: Ar galiu naudoti branch'us? A: Taip, bet subdirektorijos paprastesn\u0117s. Branch'ai - optional.</p> <p>K: Makefile b\u016btinas? A: Nuo 3 \u017eingsnio - rekomenduojamas. Anks\u010diau - <code>g++</code> tiesiogiai OK.</p> <p>K: Ar reikia logging destruktoriuose? A: Taip - padeda debug'inti (U2+).</p> <p>K: Self-assignment check? A: B\u016btinas operator= (U4).</p> <p>K: I\u0161imtys - kada naudoti? A: Pradedant U5 (validacija), U6+ (runtime errors).</p> <p>Daugiau: UzduotiuGidas-full.md</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas-short/#nuorodos","title":"\ud83d\udd17 Nuorodos","text":"<ul> <li>README \u0161ablonai: README-templates/</li> <li>Pilnas gidas: UzduotiuGidas-full.md</li> <li>U\u017eduotys: U1.md, U2.md, ...</li> <li>GitLab Help: https://docs.gitlab.com/</li> <li>C++ Reference: https://en.cppreference.com/</li> </ul> <p>Kontaktai: D\u0117stytojas: [email] Konsultacijos: [laikas/vieta]</p> <p>\u2705 \u0160tai ir viskas! S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://gitlab.mif.vu.lt</code></li> <li>Prisijunkite su VU kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code> (svarbu!)</li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Settings \u2192 Members</li> <li>Add member: <code>[d\u0117stytojo username]</code></li> <li>Role: <code>Reporter</code> (skaitymo teis\u0117s)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://gitlab.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#pilna-struktura","title":"Pilna strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis (FINAL)\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina (tik jei norite) \u274c NE"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#zingsnis-2-atlikti-1-zingsni","title":"\u017dingsnis 2: Atlikti 1 \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#zingsnis-4-testi-su-2-zingsniu","title":"\u017dingsnis 4: T\u0119sti su 2 \u017eingsniu","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#zingsnis-5-po-visu-zingsniu-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 \u017eemiau)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#pastabos","title":"\ud83d\udcdd Pastabos","text":"<ul> <li>Commit'ai daroma po kiekvieno \u017eingsnio</li> <li>Jei klausimai - ra\u0161yti d\u0117stytojui <pre><code>---\n\n### **2. U\u017eduoties README (`/U1/README.md`)** - PRIVALOMAS\n\n**\u0160ablonas:**\n\n```markdown\n# U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-02-13\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n</code></pre> Input: 42 17 99 5 0 Output: 5 17 42 99 \u2705 VEIKIA <pre><code>**Testas 2 (\u017eod\u017eiai)**:\n</code></pre> Input: obuolys bananas citrina - Output: bananas citrina obuolys \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Modulin\u0117 strukt\u016bra - `.h`/.`cpp` separacija patogu\n2. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n3. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n*(Neprivaloma, bet naudinga)*\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n</code></pre> <pre><code>**Minimumas** (jei tingite):\n- \u2705 \u017dingsni\u0173 lentel\u0117\n- \u2705 Bent 1-2 testai\n- \u2705 Kompiliavimo instrukcijos\n\n---\n\n### **3. \u017dingsnio README (`/U1/01/README.md`)** - NEPRIVALOMAS\n\nJei **tikrai** norite, galite prid\u0117ti trumpas pastabas kiekviename \u017eingsnyje, bet **ne b\u016btina**!\n\n---\n\n## \ud83d\udce6 Pateikimas Moodle\n\n### **1 b\u016bdas: Git archive (rekomenduojama)**\n\n```bash\ncd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre></li> </ul> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#archyvo-vardas","title":"Archyvo vardas:","text":"<pre><code>U[numeris]_VardasPavarde.zip\n\nPavyzd\u017eiai:\n- U1_JonasJonaitis.zip\n- U2_PetrasPetraitis.zip\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):    <pre><code>GitLab repo: https://gitlab.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre></li> <li>Submit</li> </ol> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#vertinimas","title":"\u2705 Vertinimas","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#kas-vertinama","title":"Kas vertinama:","text":"Kriterijus % Programos funkcionalumas 50% \u251c\u2500 Programa kompiliuojasi be klaid\u0173 15% \u251c\u2500 Teisingai atlieka u\u017eduot\u012f 25% \u2514\u2500 Testai praeina 10% Kodo kokyb\u0117 30% \u251c\u2500 Ai\u0161k\u016bs komentarai 10% \u251c\u2500 Modulin\u0117 strukt\u016bra 10% \u2514\u2500 Geros praktikos (header guards, const, etc.) 10% Git ir dokumentacija 20% \u251c\u2500 Commit'\u0173 kokyb\u0117 10% \u2514\u2500 README.md kokyb\u0117 10% TOTAL 100%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#commitu-vertinimas","title":"Commit'\u0173 vertinimas:","text":"Commit stilius Balai Po kiekvieno \u017eingsnio, apra\u0161omieji prane\u0161imai 100% Keli commit'ai, bet ne visi \u017eingsniai 70% Vienas commit \"U1 done\" 30% N\u0117ra commit'\u0173 / tik vienas pradinis 0%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#readmemd-vertinimas","title":"README.md vertinimas:","text":"README kokyb\u0117 Balai Pilnas (\u017eingsniai, testai, \u012f\u017evalgos) 100% Minimalus (tik \u017eingsniai + testai) 70% Tik fail\u0173 s\u0105ra\u0161as 40% Tu\u0161\u010dias arba n\u0117ra 0%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (Stack Evolution stilius).</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (ne duoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, ne laukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#k-kam-kreiptis-pagalbos","title":"K: Kam kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (Moodle arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kod\u0105!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>C++ reference: https://en.cppreference.com/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1/#kontaktai","title":"\ud83d\udcde Kontaktai","text":"<p>D\u0117stytojas: [Vardas Pavard\u0117] Email: [email@mif.vu.lt] Konsultacijos: [Laikas ir vieta] Moodle: [Nuoroda]</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://git.mif.vu.lt</code></li> <li>Prisijunkite su VU kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code></li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Manage \u2192 Members</li> <li>Add member: <code>Viktoras Golubevas</code></li> <li>Role: <code>Maintainer</code></li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://git.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#pavyzdine-struktura","title":"Pavyzdin\u0117 strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina \u274c NE"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#zingsnis-2-atlikti-1-uzduoties-zingsni","title":"\u017dingsnis 2: Atlikti 1 u\u017eduoties \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#zingsnis-4-atlikti-2-uzduoties-zingsni","title":"\u017dingsnis 4: Atlikti 2 u\u017eduoties \u017eingsn\u012f","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#zingsnis-5-po-visu-zingsniu-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 \u017eemiau)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n```bash\n\n---\n\n## \ud83d\udcdd Pastabos\n\n- Commit'ai buvo daromi po kiekvieno \u017eingsnio\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#2-uzduoties-readme-u1readmemd-privalomas","title":"2. U\u017eduoties README (<code>/U1/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-02-10\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n```txt\nInput: 42 17 99 5 0\nOutput: 5 17 42 99\n\u2705 VEIKIA\n```txt\n\n**Testas 2 (\u017eod\u017eiai)**:\n```txt\nInput: obuolys bananas citrina -\nOutput: bananas citrina obuolys\n\u2705 VEIKIA\n```txt\n\n---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos (jei turite)\n\n1. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n2. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n*(Neprivaloma, bet naudinga)*\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n```bash\n</code></pre> <p>Minimumas (jei tingite): - \u2705 \u017dingsni\u0173 lentel\u0117 - \u2705 Bent 1 testas - \u2705 Kompiliavimo instrukcijos</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#pateikimas-moodle","title":"\ud83d\udce6 Pateikimas Moodle","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#1-budas-git-archive-rekomenduojama","title":"1 b\u016bdas: Git archive (rekomenduojama)","text":"<pre><code>cd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#archyvo-vardas","title":"Archyvo vardas:","text":"<p>U[numeris]_VardasPavarde.zip</p> <p>Pavyzd\u017eiai: - U1_JonasJonaitis.zip - U2_PetrasPetraitis.zip</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):</li> </ol> <p><pre><code>GitLab repo: https://git.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre> 5. Submit</p> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (D\u0117stytojo \"Stack Evolution\" stilius mokomojoje repo).</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (ne duoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, ne laukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#k-kam-kreiptis-pagalbos","title":"K: Kam kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (Moodle arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kod\u0105!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_1_1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>C++ reference: https://en.cppreference.com/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/","title":"U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas","text":"<p>Kursas: Objektinis programavimas C++ Semestras: 2026 pavasaris Versija: 1.0</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#turinys","title":"\ud83d\udccb Turinys","text":"<ol> <li>GitLab projekto suk\u016brimas</li> <li>Projekto strukt\u016bra</li> <li>U\u017eduoties atlikimo workflow</li> <li>Git commit'\u0173 gair\u0117s</li> <li>README.md reikalavimai</li> <li>Pateikimas Moodle</li> <li>Vertinimas</li> <li>DUK</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#gitlab-projekto-sukurimas","title":"\ud83d\ude80 GitLab projekto suk\u016brimas","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#1-zingsnis-sukurti-repo-gitlabe","title":"1 \u017eingsnis: Sukurti repo GitLab'e","text":"<ol> <li>Eikite \u012f fakulteto GitLab: <code>https://gitlab.mif.vu.lt</code></li> <li>Prisijunkite su VU kredencialais</li> <li>Sukurkite nauj\u0105 projekt\u0105:</li> <li>Project name: <code>cpp-2026</code></li> <li>Visibility: <code>Private</code> (svarbu!)</li> <li>Initialize with README: \u2705 (pa\u017eym\u0117ti)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#2-zingsnis-suteikti-prieiga-destytojui","title":"2 \u017eingsnis: Suteikti prieig\u0105 d\u0117stytojui","text":"<ol> <li>Settings \u2192 Members</li> <li>Add member: <code>[d\u0117stytojo username]</code></li> <li>Role: <code>Reporter</code> (skaitymo teis\u0117s)</li> </ol>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#3-zingsnis-clone-repo-i-savo-kompiuteri","title":"3 \u017eingsnis: Clone repo \u012f savo kompiuter\u012f","text":"<pre><code>git clone https://gitlab.mif.vu.lt/[j\u016bs\u0173-username]/cpp-2026.git\ncd cpp-2026\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#projekto-struktura","title":"\ud83d\udcc1 Projekto strukt\u016bra","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#pilna-struktura","title":"Pilna strukt\u016bra:","text":"<pre><code>cpp-2026/                    \u2190 GitLab repo\n\u2502\n\u251c\u2500\u2500 README.md                \u2190 Pagrindinis projekto README (PRIVALOMA)\n\u251c\u2500\u2500 .gitignore               \u2190 Git ignoruojami failai (PRIVALOMA)\n\u2502\n\u251c\u2500\u2500 U1/                      \u2190 U\u017eduotis 1\n\u2502   \u251c\u2500\u2500 README.md            \u2190 U\u017eduoties santrauka (PRIVALOMA)\n\u2502   \u251c\u2500\u2500 01/                  \u2190 1 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 02/                  \u2190 2 \u017eingsnis\n\u2502   \u2502   \u2514\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 03/                  \u2190 3 \u017eingsnis\n\u2502   \u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.h\n\u2502   \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n\u2502   \u2502   \u2514\u2500\u2500 Makefile\n\u2502   \u251c\u2500\u2500 04/                  \u2190 4 \u017eingsnis\n\u2502   \u2514\u2500\u2500 05/                  \u2190 5 \u017eingsnis (FINAL)\n\u2502\n\u251c\u2500\u2500 U2/                      \u2190 U\u017eduotis 2\n\u2502   \u251c\u2500\u2500 README.md\n\u2502   \u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 02/\n\u2502   \u2514\u2500\u2500 03/\n\u2502\n\u251c\u2500\u2500 U3/                      \u2190 U\u017eduotis 3\n\u2502   \u2514\u2500\u2500 ...\n\u2502\n\u2514\u2500\u2500 ... (U4-U9)\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#readmemd-hierarchija","title":"README.md hierarchija:","text":"Lygis Failas Turinys Privaloma? Projektas <code>/README.md</code> Bendras projekto apra\u0161ymas, u\u017eduo\u010di\u0173 b\u016bsena \u2705 TAIP U\u017eduotis <code>/U1/README.md</code> U\u017eduoties santrauka, testavimas, pastabos \u2705 TAIP \u017dingsnis <code>/U1/01/README.md</code> Neb\u016btina (tik jei norite) \u274c NE"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#uzduoties-atlikimo-workflow","title":"\ud83d\udd04 U\u017eduoties atlikimo workflow","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#bendra-schema","title":"Bendra schema:","text":"<pre><code>1. Perskaityti u\u017eduot\u012f (pvz., U1.md)\n   \u2193\n2. Sukurti direktorijas \u017eingsniams (U1/01/, U1/02/, ...)\n   \u2193\n3. Atlikti \u017eingsn\u012f \u2192 compile \u2192 test\n   \u2193\n4. Commit (po kiekvieno \u017eingsnio!)\n   \u2193\n5. Push \u012f GitLab (backup!)\n   \u2193\n6. Kartoti 3-5 kiekvienam \u017eingsniui\n   \u2193\n7. U\u017epildyti U1/README.md\n   \u2193\n8. Final commit + push\n   \u2193\n9. Sukurti archyv\u0105\n   \u2193\n10. Pateikti Moodle\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#detalus-pavyzdys-u1","title":"Detalus pavyzdys (U1):","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#zingsnis-1-sukurti-direktorijas","title":"\u017dingsnis 1: Sukurti direktorijas","text":"<pre><code>cd cpp-2026\nmkdir -p U1/01 U1/02 U1/03 U1/04 U1/05\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#zingsnis-2-atlikti-1-zingsni","title":"\u017dingsnis 2: Atlikti 1 \u017eingsn\u012f","text":"<pre><code>cd U1/01\n# Ra\u0161yti kod\u0105 (main.cpp)\ng++ main.cpp -o programa\n./programa\n# Testuoti\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#zingsnis-3-commit","title":"\u017dingsnis 3: Commit","text":"<pre><code>git add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#zingsnis-4-testi-su-2-zingsniu","title":"\u017dingsnis 4: T\u0119sti su 2 \u017eingsniu","text":"<pre><code>cd ../02\n# Kopijuoti i\u0161 01/ (jei reikia)\ncp ../01/main.cpp .\n# Modifikuoti kod\u0105\n# ...\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#zingsnis-5-po-visu-zingsniu-readme","title":"\u017dingsnis 5: Po vis\u0173 \u017eingsni\u0173 - README","text":"<pre><code>cd U1\n# Sukurti README.md (\u017er. \u0161ablon\u0105 \u017eemiau)\ngit add README.md\ngit commit -m \"U1: U\u017eduoties README\"\ngit push\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#git-commitu-gaires","title":"\ud83d\udcdd Git commit'\u0173 gair\u0117s","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#geri-commitai","title":"Geri commit'ai:","text":"<p>\u2705 Po kiekvieno \u017eingsnio <pre><code>git commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit commit -m \"U1: 2 \u017eingsnis - Bubble sort funkcija\"\ngit commit -m \"U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra\"\n</code></pre></p> <p>\u2705 Apra\u0161omieji prane\u0161imai <pre><code>git commit -m \"U2: Prid\u0117tas copy constructor su deep copy\"\ngit commit -m \"U3: Pataisyta memory leak destruktoriuje\"\n</code></pre></p> <p>\u2705 Da\u017eni commit'ai (po kiekvienos reik\u0161mingos modifikacijos)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#blogi-commitai","title":"Blogi commit'ai:","text":"<p>\u274c Vienas commit visai u\u017eduo\u010diai <pre><code>git commit -m \"U1 done\"  # Blogai!\n</code></pre></p> <p>\u274c Neapra\u0161omieji prane\u0161imai <pre><code>git commit -m \"fix\"      # Blogai!\ngit commit -m \"asdf\"     # Blogai!\ngit commit -m \"commit\"   # Blogai!\n</code></pre></p> <p>\u274c Reti commit'ai (tik prad\u017eioje ir pabaigoje)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#commit-pranesimu-formatas","title":"Commit prane\u0161im\u0173 formatas:","text":"<pre><code>U[numeris]: [Trumpas apra\u0161ymas]\n\nPavyzd\u017eiai:\n- U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\n- U1: 3 \u017eingsnis - Modulin\u0117 strukt\u016bra (.h/.cpp)\n- U2: IntList konstruktorius su dynamic allocation\n- U3: Copy constructor - deep copy implementacija\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#readmemd-reikalavimai","title":"\ud83d\udcc4 README.md reikalavimai","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#1-projekto-readme-readmemd-privalomas","title":"1. Projekto README (<code>/README.md</code>) - PRIVALOMAS","text":"<p>\u0160ablonas:</p> <pre><code># C++ Objektinis Programavimas (2026)\n\n**Studentas**: Vardas Pavard\u0117  \n**Grup\u0117**: XXXXXX  \n**GitLab**: https://gitlab.mif.vu.lt/[username]/cpp-2026\n\n---\n\n## \ud83d\udcc1 Projekto strukt\u016bra\n\n- **U1/** - C++ primityvai ir funkcij\u0173 moduliai\n- **U2/** - IntList klas\u0117 (RAII)\n- **U3/** - Kompozicija (Langas/Kambarys)\n- *(bus papildoma...)*\n\n---\n\n## \u2705 U\u017eduo\u010di\u0173 b\u016bsena\n\n| U\u017eduotis | B\u016bsena | Terminas | Pateikta |\n|----------|--------|----------|----------|\n| U1 | \u2705 Atlikta | 2026-02-14 | 2026-02-13 |\n| U2 | \ud83d\udd04 Vykdoma | 2026-02-28 | - |\n| U3 | \u23f3 Laukia | 2026-03-14 | - |\n\n---\n\n## \ud83d\udee0\ufe0f Kompiliavimas\n\nKiekviena u\u017eduotis turi savo Makefile:\n\n```bash\ncd U1/05/\nmake\n./programa\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#pastabos","title":"\ud83d\udcdd Pastabos","text":"<ul> <li>Commit'ai daroma po kiekvieno \u017eingsnio</li> <li>Jei klausimai - ra\u0161yti d\u0117stytojui <pre><code>---\n\n### **2. U\u017eduoties README (`/U1/README.md`)** - PRIVALOMAS\n\n**\u0160ablonas:**\n\n```markdown\n# U1: C++ Primityvai ir Funkcij\u0173 Moduliai\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-02-13\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Hello World + masyvas |\n| 2 | `02/` | Bubble sort funkcija |\n| 3 | `03/` | Modulin\u0117 strukt\u016bra (.h/.cpp) |\n| 4 | `04/` | array \u2192 vector&lt;int&gt; |\n| 5 | `05/` | vector&lt;int&gt; \u2192 vector&lt;string&gt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (skai\u010diai)**:\n</code></pre> Input: 42 17 99 5 0 Output: 5 17 42 99 \u2705 VEIKIA <pre><code>**Testas 2 (\u017eod\u017eiai)**:\n</code></pre> Input: obuolys bananas citrina - Output: bananas citrina obuolys \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Modulin\u0117 strukt\u016bra - `.h`/.`cpp` separacija patogu\n2. Vector daug lankstesnis u\u017e masyv\u0105 (dinaminis dydis)\n3. Tas pats algoritmas veikia su int ir string!\n\n---\n\n## \u26a0\ufe0f Problemos (jei buvo)\n\n*(Neprivaloma, bet naudinga)*\n\n**Problema 1**: Makefile TAB vs spaces  \n**Sprendimas**: Pakeisti spaces \u012f TAB simbolius\n\n---\n\n## \ud83d\udce6 Kompiliavimas\n\n```bash\ncd 05/\nmake\n./programa\n</code></pre> <pre><code>**Minimumas** (jei tingite):\n- \u2705 \u017dingsni\u0173 lentel\u0117\n- \u2705 Bent 1-2 testai\n- \u2705 Kompiliavimo instrukcijos\n\n---\n\n### **3. \u017dingsnio README (`/U1/01/README.md`)** - NEPRIVALOMAS\n\nJei **tikrai** norite, galite prid\u0117ti trumpas pastabas kiekviename \u017eingsnyje, bet **ne b\u016btina**!\n\n---\n\n## \ud83d\udce6 Pateikimas Moodle\n\n### **1 b\u016bdas: Git archive (rekomenduojama)**\n\n```bash\ncd cpp-2026\n\n# Sukurti archyv\u0105 tik su U1 u\u017eduotimi\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/\n\n# ARBA visa repo archyvas\ngit archive --format=zip --output=cpp2026_VardasPavarde.zip HEAD\n</code></pre></li> </ul> <p>Pliusai:  - \u2705 Archyvuoja tik commit'intus failus (ne \"junk\" failus) - \u2705 Automati\u0161kai ignoruoja <code>.o</code>, <code>programa</code>, ir kt.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#2-budas-rankinis-zip","title":"2 b\u016bdas: Rankinis zip","text":"<pre><code>cd cpp-2026\n\n# I\u0161valyti compiled failus\ncd U1/05\nmake clean\ncd ../..\n\n# Sukurti archyv\u0105\nzip -r U1_VardasPavarde.zip U1/ README.md .gitignore\n</code></pre> <p>Minusai: - \u26a0\ufe0f Reikia rankiniu b\u016bdu i\u0161valyti - \u26a0\ufe0f Galite \u012ftraukti \"junk\" failus</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#archyvo-vardas","title":"Archyvo vardas:","text":"<pre><code>U[numeris]_VardasPavarde.zip\n\nPavyzd\u017eiai:\n- U1_JonasJonaitis.zip\n- U2_PetrasPetraitis.zip\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#kas-turi-buti-archyve","title":"Kas turi b\u016bti archyve:","text":"<p>\u2705 Privaloma: - <code>/U1/</code> direktorija su visais \u017eingsniais - <code>/U1/README.md</code> - <code>/README.md</code> (projekto root README) - <code>/.gitignore</code></p> <p>\u274c Neturi b\u016bti: - <code>*.o</code> failai (compiled object files) - Executable failai (<code>programa</code>, <code>a.out</code>, etc.) - Editor junk (<code>.vscode/</code>, <code>.idea/</code>, <code>*~</code>)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#moodle-pateikimo-workflow","title":"Moodle pateikimo workflow:","text":"<ol> <li>Sukurti archyv\u0105 (\u017er. auk\u0161\u010diau)</li> <li>Eiti \u012f Moodle \u2192 C++ kursas \u2192 U\u017eduotis U1</li> <li>Upload fail\u0105: <code>U1_VardasPavarde.zip</code></li> <li>Prid\u0117ti GitLab URL (comment/text field):    <pre><code>GitLab repo: https://gitlab.mif.vu.lt/[username]/cpp-2026\nCommit hash: abc123def456\n</code></pre></li> <li>Submit</li> </ol> <p>Terminas: \u017di\u016br\u0117kite u\u017eduoties apra\u0161yme (pvz., U1.md)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#vertinimas","title":"\u2705 Vertinimas","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#kas-vertinama","title":"Kas vertinama:","text":"Kriterijus % Programos funkcionalumas 50% \u251c\u2500 Programa kompiliuojasi be klaid\u0173 15% \u251c\u2500 Teisingai atlieka u\u017eduot\u012f 25% \u2514\u2500 Testai praeina 10% Kodo kokyb\u0117 30% \u251c\u2500 Ai\u0161k\u016bs komentarai 10% \u251c\u2500 Modulin\u0117 strukt\u016bra 10% \u2514\u2500 Geros praktikos (header guards, const, etc.) 10% Git ir dokumentacija 20% \u251c\u2500 Commit'\u0173 kokyb\u0117 10% \u2514\u2500 README.md kokyb\u0117 10% TOTAL 100%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#commitu-vertinimas","title":"Commit'\u0173 vertinimas:","text":"Commit stilius Balai Po kiekvieno \u017eingsnio, apra\u0161omieji prane\u0161imai 100% Keli commit'ai, bet ne visi \u017eingsniai 70% Vienas commit \"U1 done\" 30% N\u0117ra commit'\u0173 / tik vienas pradinis 0%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#readmemd-vertinimas","title":"README.md vertinimas:","text":"README kokyb\u0117 Balai Pilnas (\u017eingsniai, testai, \u012f\u017evalgos) 100% Minimalus (tik \u017eingsniai + testai) 70% Tik fail\u0173 s\u0105ra\u0161as 40% Tu\u0161\u010dias arba n\u0117ra 0%"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#duk","title":"\u2753 DUK","text":""},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-galiu-naudoti-branchus-vietoj-subdirektoriju","title":"K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173?","text":"<p>A: Taip, galite, bet neprivaloma. </p> <p>Pavyzdys su branch'ais: <pre><code>git checkout -b u1-step1\n# ... darbas ...\ngit commit -m \"U1: 1 \u017eingsnis\"\n\ngit checkout -b u1-step2\n# ... darbas ...\ngit commit -m \"U1: 2 \u017eingsnis\"\n\n# Galutinis merge \u012f main\ngit checkout main\ngit merge u1-step5\n</code></pre></p> <p>Bet subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s ir labiau atitinka paskait\u0173 med\u017eiag\u0105 (Stack Evolution stilius).</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-reikia-makefile-kiekviename-zingsnyje","title":"K: Ar reikia Makefile kiekviename \u017eingsnyje?","text":"<p>A: Ne, tik nuo 3 \u017eingsnio (kai turite kelis <code>.cpp</code> failus).</p> <ul> <li>\u017dingsniai 1-2: <code>g++ main.cpp -o programa</code> pakanka</li> <li>\u017dingsniai 3-5: Makefile rekomenduojamas (daug fail\u0173)</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-galiu-naudoti-ide-vs-code-clion","title":"K: Ar galiu naudoti IDE (VS Code, CLion)?","text":"<p>A: Taip, bet: - \u2705 \u012etraukite <code>.gitignore</code> ignoruoti IDE failus - \u2705 Programa turi kompiliuotis su Makefile (ne tik IDE) - \u274c Ne\u012ftraukite <code>.vscode/</code>, <code>.idea/</code> \u012f repo</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ka-daryti-jei-pamirsau-commitinti","title":"K: K\u0105 daryti, jei pamir\u0161au commit'inti?","text":"<p>A: Commit'inkite dabar!</p> <pre><code># Jei jau padar\u0117te kelis \u017eingsnius be commit'\u0173:\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis (late commit)\"\n\ngit add U1/02/\ngit commit -m \"U1: 2 \u017eingsnis (late commit)\"\n</code></pre> <p>Geriau v\u0117liau nei niekada! Bet ateityje commit'inkite da\u017enai.</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-senasis-kodas-turi-buti-uzkomentuotas-ar-istrinti","title":"K: Ar senasis kodas turi b\u016bti u\u017ekomentuotas ar i\u0161trinti?","text":"<p>A: Priklauso nuo u\u017eduoties:</p> <ul> <li>U1: U\u017ekomentuoti (\u017er. U1.md reikalavimus)</li> <li>U2-U9: I\u0161trinti (senasis kodas - tai praeit\u0173 \u017eingsni\u0173 direktorijos)</li> </ul> <p>Git saugo vis\u0105 istorij\u0105, tod\u0117l galite i\u0161trinti sen\u0105 kod\u0105 - jis vis tiek matomas commit'uose!</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-gitignore-privalomas","title":"K: Ar <code>.gitignore</code> privalomas?","text":"<p>A: Taip! \u012etraukite \u0161\u012f minimal\u0173 <code>.gitignore</code>:</p> <pre><code># Compiled files\n*.o\n*.out\nprograma\na.out\n\n# Editor files\n*~\n.vscode/\n.idea/\n*.swp\n\n# OS files\n.DS_Store\nThumbs.db\n</code></pre>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ka-daryti-jei-gitlab-permission-denied","title":"K: K\u0105 daryti, jei GitLab \"permission denied\"?","text":"<p>A: Patikrinkite SSH raktus:</p> <pre><code># Sugeneruoti SSH rakt\u0105 (jei neturite)\nssh-keygen -t ed25519 -C \"your.email@mif.vu.lt\"\n\n# Nukopijuoti public key\ncat ~/.ssh/id_ed25519.pub\n\n# \u012etraukti \u012f GitLab:\n# Settings \u2192 SSH Keys \u2192 Add key\n</code></pre> <p>Arba naudokite HTTPS: <pre><code>git clone https://gitlab.mif.vu.lt/[username]/cpp-2026.git\n</code></pre></p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-ar-galiu-dirbti-grupeje","title":"K: Ar galiu dirbti grup\u0117je?","text":"<p>A: Ne, kiekvienas studentas turi savo repo.</p> <p>Bet galite: - \u2705 Diskutuoti id\u0117jas - \u2705 Pad\u0117ti debug'inti (ne duoti kodo!) - \u274c Kopijuoti kod\u0105 (plagiatas!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-kiek-laiko-uztrunka-uzduotis","title":"K: Kiek laiko u\u017etrunka u\u017eduotis?","text":"<p>A: Priklauso nuo u\u017eduoties ir j\u016bs\u0173 patirties:</p> <ul> <li>U1: 3-5 valandos (pradedantiesiems), 2-3 val (patyrusiems)</li> <li>U2-U3: 4-6 valandos</li> <li>U4-U7: 5-8 valandos</li> <li>U8-U9: 8-12 valand\u0173 (projektas)</li> </ul> <p>Patariu: Prad\u0117ti anks\u010diau, ne laukti paskutin\u0117s dienos! \ud83d\ude0a</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#k-kam-kreiptis-pagalbos","title":"K: Kam kreiptis pagalbos?","text":"<p>A: 1. Pirmiausia: Perskaityti u\u017eduoties apra\u0161ym\u0105 (U1.md, U2.md, ...) 2. Antra: Pa\u017ei\u016br\u0117ti Stack Overflow, cppreference.com 3. Tre\u010dia: Klausti d\u0117stytojo (Moodle arba email) 4. Paskutinis b\u016bdas: Klausti kolegos (bet ne kopijuoti kod\u0105!)</p>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>GitLab dokumentacija: https://docs.gitlab.com/</li> <li>Git tutorial: https://git-scm.com/book/en/v2</li> <li>Markdown sintaks\u0117: https://www.markdownguide.org/</li> <li>C++ reference: https://en.cppreference.com/</li> <li>Makefile tutorial: https://makefiletutorial.com/</li> </ul>"},{"location":"Pratybos/Tvarka/UzduotiuGidas_2/#kontaktai","title":"\ud83d\udcde Kontaktai","text":"<p>D\u0117stytojas: [Vardas Pavard\u0117] Email: [email@mif.vu.lt] Konsultacijos: [Laikas ir vieta] Moodle: [Nuoroda]</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/po%20U1/U1-solution/","title":"U1: Sprendimas - C++ Primityvai ir Funkcij\u0173 Moduliai","text":"<p>D\u0117stytojui: \u0160is failas skirtas jums - pilnas sprendimas su kodu, paai\u0161kinimais ir \"virtuve\".</p>"},{"location":"Pratybos/po%20U1/U1-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U1/\n\u251c\u2500\u2500 main.cpp\n\u251c\u2500\u2500 rusiavimas.h\n\u251c\u2500\u2500 rusiavimas.cpp\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 README.txt\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#1-1-zingsnis-hello-world-ir-masyvu-ivestis","title":"1\ufe0f\u20e3 1 \u017eingsnis: Hello World ir masyv\u0173 \u012fvestis","text":""},{"location":"Pratybos/po%20U1/U1-solution/#maincpp-pradine-versija","title":"main.cpp (pradin\u0117 versija):","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    // 1. Hello World\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n    // 2. Masyvas skai\u010diams\n    int skaiciai[100];  // Fiksuoto dyd\u017eio masyvas\n    int kiekis = 0;     // Kiek element\u0173 \u012fvesta\n    int x;\n\n    // 3. \u012evedimas\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai[kiekis++] = x;\n    }\n\n    // 4. I\u0161vedimas\n    cout &lt;&lt; \"\u012evesti skai\u010diai: \";\n    for(int i = 0; i &lt; kiekis; i++) {\n        cout &lt;&lt; skaiciai[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#kompiliacija","title":"Kompiliacija:","text":"<pre><code>g++ main.cpp -o programa\n./programa\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#testavimas","title":"Testavimas:","text":"<pre><code>Hello, World!\n\u012eveskite sveikus skai\u010dius (0 - baigti):\n42\n17\n99\n0\n\u012evesti skai\u010diai: 42 17 99\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Paprastas startas - visi tur\u0117t\u0173 sugeb\u0117ti</li> <li>\u2705 <code>cin &gt;&gt; x</code> automati\u0161kai konvertuoja \u012fvedim\u0105</li> <li>\u26a0\ufe0f Da\u017ena klaida: u\u017emir\u0161ti <code>kiekis</code> kintam\u0105j\u012f (saugo, kiek element\u0173)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>skaiciai[kiekis++]</code> vs <code>skaiciai[++kiekis]</code> (postfix/prefix)</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#2-2-zingsnis-bubble-sort-funkcija","title":"2\ufe0f\u20e3 2 \u017eingsnis: Bubble sort funkcija","text":""},{"location":"Pratybos/po%20U1/U1-solution/#maincpp-modifikuotas","title":"main.cpp (modifikuotas):","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Funkcijos deklaracija\nvoid rusiuotiMasyva(int masyvas[], int dydis);\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n    int skaiciai[100];\n    int kiekis = 0;\n    int x;\n\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai[kiekis++] = x;\n    }\n\n    // NAUJAS: R\u016b\u0161iavimas\n    cout &lt;&lt; \"Prie\u0161 r\u016b\u0161iavim\u0105: \";\n    for(int i = 0; i &lt; kiekis; i++) {\n        cout &lt;&lt; skaiciai[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    rusiuotiMasyva(skaiciai, kiekis);\n\n    cout &lt;&lt; \"Po r\u016b\u0161iavimo: \";\n    for(int i = 0; i &lt; kiekis; i++) {\n        cout &lt;&lt; skaiciai[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n\n// Funkcijos apibr\u0117\u017eimas (Bubble sort)\nvoid rusiuotiMasyva(int masyvas[], int dydis) {\n    for(int i = 0; i &lt; dydis - 1; i++) {\n        for(int j = 0; j &lt; dydis - i - 1; j++) {\n            if(masyvas[j] &gt; masyvas[j + 1]) {\n                // Sukeisti vietomis\n                int temp = masyvas[j];\n                masyvas[j] = masyvas[j + 1];\n                masyvas[j + 1] = temp;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#testavimas_1","title":"Testavimas:","text":"<pre><code>Prie\u0161 r\u016b\u0161iavim\u0105: 42 17 99\nPo r\u016b\u0161iavimo: 17 42 99\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Bubble sort algoritmas paprastas (bet neefektyvus - O(n\u00b2))</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>dydis - 1</code> vs <code>dydis</code> (off-by-one error)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>dydis - i - 1</code> (optimizacija - paskutiniai jau sur\u016b\u0161iuoti)</li> <li>\ud83d\udca1 Galite pademonstruoti \u017eingsnius su debug <code>cout</code> cikle</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#3-3-zingsnis-moduline-struktura","title":"3\ufe0f\u20e3 3 \u017eingsnis: Modulin\u0117 strukt\u016bra","text":""},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimash","title":"rusiavimas.h:","text":"<pre><code>#ifndef RUSIAVIMAS_H\n#define RUSIAVIMAS_H\n\n// Funkcija r\u016b\u0161iavimui (Bubble sort)\nvoid rusiuotiMasyva(int masyvas[], int dydis);\n\n// Funkcija spausdinimui\nvoid spausdintiMasyva(const int masyvas[], int dydis);\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos-header-guards","title":"Pedagogin\u0117s pastabos (header guards):","text":"<pre><code>#ifndef RUSIAVIMAS_H  // \"if not defined\"\n#define RUSIAVIMAS_H  // \"define it\"\n\n// ... turinys ...\n\n#endif  // U\u017ebaigti s\u0105lyg\u0105\n</code></pre> <p>Kod\u0117l reikia? - Apsaugo nuo multiple inclusion (dvigubo \u012ftraukimo) - Jei <code>rusiavimas.h</code> b\u016bt\u0173 <code>#include</code> kelis kartus \u2192 kompiliavimo klaida - Header guard u\u017etikrina, kad turinys \u012ftraukiamas tik vien\u0105 kart\u0105</p>"},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimascpp","title":"rusiavimas.cpp:","text":"<pre><code>#include \"rusiavimas.h\"\n#include &lt;iostream&gt;\n\n// Bubble sort implementacija\nvoid rusiuotiMasyva(int masyvas[], int dydis) {\n    for(int i = 0; i &lt; dydis - 1; i++) {\n        for(int j = 0; j &lt; dydis - i - 1; j++) {\n            if(masyvas[j] &gt; masyvas[j + 1]) {\n                int temp = masyvas[j];\n                masyvas[j] = masyvas[j + 1];\n                masyvas[j + 1] = temp;\n            }\n        }\n    }\n}\n\n// Spausdinimo funkcija\nvoid spausdintiMasyva(const int masyvas[], int dydis) {\n    for(int i = 0; i &lt; dydis; i++) {\n        std::cout &lt;&lt; masyvas[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>#include \"rusiavimas.h\"</code> - dvigubos kabut\u0117s (local file)</li> <li>\u2705 <code>#include &lt;iostream&gt;</code> - kampiniai skliaustai (system library)</li> <li>\u2705 <code>const int masyvas[]</code> - spausdinimas nekei\u010dia masyvo</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>#include &lt;rusiavimas.h&gt;</code> (tur\u0117t\u0173 b\u016bti <code>\"</code>)</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#maincpp-supaprastintas","title":"main.cpp (supaprastintas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"rusiavimas.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n    int skaiciai[100];\n    int kiekis = 0;\n    int x;\n\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai[kiekis++] = x;\n    }\n\n    cout &lt;&lt; \"Prie\u0161 r\u016b\u0161iavim\u0105: \";\n    spausdintiMasyva(skaiciai, kiekis);\n\n    rusiuotiMasyva(skaiciai, kiekis);\n\n    cout &lt;&lt; \"Po r\u016b\u0161iavimo: \";\n    spausdintiMasyva(skaiciai, kiekis);\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#makefile-rekomenduojama","title":"Makefile (rekomenduojama):","text":"<pre><code># Kompiliatorius\nCXX = g++\nCXXFLAGS = -Wall -std=c++11\n\n# Failai\nOBJS = main.o rusiavimas.o\nTARGET = programa\n\n# Pagrindinis tikslas\nall: $(TARGET)\n\n# Linkinimas\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\n# Kompiliacija\nmain.o: main.cpp rusiavimas.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nrusiavimas.o: rusiavimas.cpp rusiavimas.h\n    $(CXX) $(CXXFLAGS) -c rusiavimas.cpp\n\n# Valymas\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n# PHONY tikslai\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#naudojimas","title":"Naudojimas:","text":"<pre><code>make           # Kompiliuoti\n./programa     # Paleisti\nmake clean     # I\u0161valyti\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Makefile automatizuoja kompiliacij\u0105</li> <li>\u2705 Perkompiliuoja tik pasikeitusius failus (efektyvu!)</li> <li>\u26a0\ufe0f TAB simboliai privalomi (ne spaces!)</li> <li>\ud83d\udca1 Studentams galite duoti \u0161ablon\u0105, tik pritaikys vardus</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#kompiliacija-rankiniu-budu","title":"Kompiliacija rankiniu b\u016bdu:","text":"<pre><code># 1. Kompiliuoti kiekvien\u0105 .cpp fail\u0105 \u012f .o\ng++ -Wall -std=c++11 -c main.cpp\ng++ -Wall -std=c++11 -c rusiavimas.cpp\n\n# 2. Sujungti (link) \u012f vien\u0105 program\u0105\ng++ main.o rusiavimas.o -o programa\n\n# 3. Paleisti\n./programa\n</code></pre> <p>Flag'\u0173 paai\u0161kinimas: - <code>-Wall</code> - rodyti visus warning'us (good practice!) - <code>-std=c++11</code> - naudoti C++11 standart\u0105 (arba <code>-std=c++17</code>) - <code>-c</code> - compile only (nesujungti \u012f executable) - <code>-o</code> - output failo vardas</p>"},{"location":"Pratybos/po%20U1/U1-solution/#4-4-zingsnis-array-vectorint","title":"4\ufe0f\u20e3 4 \u017eingsnis: array \u2192 vector\\&lt;int&gt;","text":""},{"location":"Pratybos/po%20U1/U1-solution/#maincpp-su-vector","title":"main.cpp (su vector):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include \"rusiavimas.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n    /*\n    // ==================================================\n    // SENASIS KODAS SU MASYVU (U\u017dKOMENTUOTAS)\n    // ==================================================\n    int skaiciai[100];\n    int kiekis = 0;\n    int x;\n\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai[kiekis++] = x;\n    }\n    */\n\n    // ==================================================\n    // NAUJAS KODAS SU VECTOR\n    // ==================================================\n    vector&lt;int&gt; skaiciai;  // Dinaminis konteineris\n    int x;\n\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai.push_back(x);  // Prid\u0117ti \u012f pabaig\u0105\n    }\n\n    cout &lt;&lt; \"Prie\u0161 r\u016b\u0161iavim\u0105: \";\n    spausdintiVektoriu(skaiciai);\n\n    rusiuotiVektoriu(skaiciai);\n\n    cout &lt;&lt; \"Po r\u016b\u0161iavimo: \";\n    spausdintiVektoriu(skaiciai);\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimash-atnaujintas","title":"rusiavimas.h (atnaujintas):","text":"<pre><code>#ifndef RUSIAVIMAS_H\n#define RUSIAVIMAS_H\n\n#include &lt;vector&gt;\n\n// Funkcijos masyvams (senas kodas)\nvoid rusiuotiMasyva(int masyvas[], int dydis);\nvoid spausdintiMasyva(const int masyvas[], int dydis);\n\n// Funkcijos vektoriams (naujas kodas)\nvoid rusiuotiVektoriu(std::vector&lt;int&gt;&amp; skaiciai);\nvoid spausdintiVektoriu(const std::vector&lt;int&gt;&amp; skaiciai);\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimascpp-atnaujintas","title":"rusiavimas.cpp (atnaujintas):","text":"<pre><code>#include \"rusiavimas.h\"\n#include &lt;iostream&gt;\n\n// ==================================================\n// SENOS FUNKCIJOS (MASYVAMS)\n// ==================================================\nvoid rusiuotiMasyva(int masyvas[], int dydis) {\n    for(int i = 0; i &lt; dydis - 1; i++) {\n        for(int j = 0; j &lt; dydis - i - 1; j++) {\n            if(masyvas[j] &gt; masyvas[j + 1]) {\n                int temp = masyvas[j];\n                masyvas[j] = masyvas[j + 1];\n                masyvas[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid spausdintiMasyva(const int masyvas[], int dydis) {\n    for(int i = 0; i &lt; dydis; i++) {\n        std::cout &lt;&lt; masyvas[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\n// ==================================================\n// NAUJOS FUNKCIJOS (VEKTORIAMS)\n// ==================================================\nvoid rusiuotiVektoriu(std::vector&lt;int&gt;&amp; skaiciai) {\n    int dydis = skaiciai.size();  // Dinaminis dydis\n    for(int i = 0; i &lt; dydis - 1; i++) {\n        for(int j = 0; j &lt; dydis - i - 1; j++) {\n            if(skaiciai[j] &gt; skaiciai[j + 1]) {\n                int temp = skaiciai[j];\n                skaiciai[j] = skaiciai[j + 1];\n                skaiciai[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid spausdintiVektoriu(const std::vector&lt;int&gt;&amp; skaiciai) {\n    for(int i = 0; i &lt; skaiciai.size(); i++) {\n        std::cout &lt;&lt; skaiciai[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>vector&lt;int&gt;&amp;</code> - perduodame per nuorod\u0105 (modifikuojame original\u0105)</li> <li>\u2705 <code>const vector&lt;int&gt;&amp;</code> - nekei\u010diame (read-only)</li> <li>\u2705 <code>.size()</code> - dinaminis dydis (ne fiksuotas!)</li> <li>\u2705 <code>.push_back()</code> - prid\u0117ti nauj\u0105 element\u0105</li> <li>\ud83d\udca1 Vector automati\u0161kai ple\u010diasi (reallocates memory)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>skaiciai.size()</code> gr\u0105\u017eina <code>size_t</code> (unsigned) \u2192 <code>-Wsign-compare</code> warning</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#5-5-zingsnis-vectorint-vectorstring","title":"5\ufe0f\u20e3 5 \u017eingsnis: vector\\&lt;int&gt; \u2192 vector\\&lt;string&gt;","text":""},{"location":"Pratybos/po%20U1/U1-solution/#maincpp-su-string","title":"main.cpp (su string):","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include \"rusiavimas.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n\n    /*\n    // ==================================================\n    // SENASIS KODAS SU SKAI\u010cIAIS (U\u017dKOMENTUOTAS)\n    // ==================================================\n    vector&lt;int&gt; skaiciai;\n    int x;\n    cout &lt;&lt; \"\u012eveskite sveikus skai\u010dius (0 - baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; x &amp;&amp; x != 0) {\n        skaiciai.push_back(x);\n    }\n    */\n\n    // ==================================================\n    // NAUJAS KODAS SU \u017dOD\u017dIAIS\n    // ==================================================\n    vector&lt;string&gt; zodziai;\n    string zodis;\n\n    cout &lt;&lt; \"\u012eveskite \u017eod\u017eius ('-' baigti):\" &lt;&lt; endl;\n    while(cin &gt;&gt; zodis &amp;&amp; zodis != \"-\") {\n        zodziai.push_back(zodis);\n    }\n\n    cout &lt;&lt; \"Prie\u0161 r\u016b\u0161iavim\u0105: \";\n    spausdintiZodzius(zodziai);\n\n    rusiuotiZodzius(zodziai);\n\n    cout &lt;&lt; \"Po r\u016b\u0161iavimo: \";\n    spausdintiZodzius(zodziai);\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimash-galutine-versija","title":"rusiavimas.h (galutin\u0117 versija):","text":"<pre><code>#ifndef RUSIAVIMAS_H\n#define RUSIAVIMAS_H\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n// Funkcijos masyvams (1-2 \u017eingsniai)\nvoid rusiuotiMasyva(int masyvas[], int dydis);\nvoid spausdintiMasyva(const int masyvas[], int dydis);\n\n// Funkcijos int vektoriams (4 \u017eingsnis)\nvoid rusiuotiVektoriu(std::vector&lt;int&gt;&amp; skaiciai);\nvoid spausdintiVektoriu(const std::vector&lt;int&gt;&amp; skaiciai);\n\n// Funkcijos string vektoriams (5 \u017eingsnis)\nvoid rusiuotiZodzius(std::vector&lt;std::string&gt;&amp; zodziai);\nvoid spausdintiZodzius(const std::vector&lt;std::string&gt;&amp; zodziai);\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#rusiavimascpp-galutine-versija","title":"rusiavimas.cpp (galutin\u0117 versija):","text":"<pre><code>#include \"rusiavimas.h\"\n#include &lt;iostream&gt;\n\n// ... (senos funkcijos, paliekame)\n\n// ==================================================\n// STRING VEKTORI\u0172 FUNKCIJOS\n// ==================================================\nvoid rusiuotiZodzius(std::vector&lt;std::string&gt;&amp; zodziai) {\n    int dydis = zodziai.size();\n    for(int i = 0; i &lt; dydis - 1; i++) {\n        for(int j = 0; j &lt; dydis - i - 1; j++) {\n            // string palaiko &lt; operatori\u0173 (leksikografin\u0117 tvarka)\n            if(zodziai[j] &gt; zodziai[j + 1]) {\n                std::string temp = zodziai[j];\n                zodziai[j] = zodziai[j + 1];\n                zodziai[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid spausdintiZodzius(const std::vector&lt;std::string&gt;&amp; zodziai) {\n    for(int i = 0; i &lt; zodziai.size(); i++) {\n        std::cout &lt;&lt; zodziai[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-pastabos_5","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>string</code> klas\u0117 palaiko <code>&lt;</code> operatori\u0173 (leksikografin\u0117/ab\u0117c\u0117l\u0117s tvarka)</li> <li>\u2705 Tas pats Bubble sort algoritmas veikia su skirtingais tipais!</li> <li>\ud83d\udca1 Foreshadowing templates - \"ar matote pattern'\u0105? V\u0117liau naudosime templates\"</li> <li>\u26a0\ufe0f Lietuvi\u0161kos raid\u0117s (\u0105, \u010d, \u0117...) gali b\u016bti r\u016b\u0161iuojamos neteisingai (encoding problema)</li> </ul>"},{"location":"Pratybos/po%20U1/U1-solution/#readmetxt-pavyzdys","title":"\ud83d\udce6 README.txt pavyzdys","text":"<pre><code>===========================================\nU1: C++ Primityvai ir Funkcij\u0173 Moduliai\n===========================================\n\nAutorius: [Vardas Pavard\u0117]\nData: 2026-02-15\n\n-------------------------------------------\nKOMPILIAVIMAS\n-------------------------------------------\n\nNaudojant Makefile:\n    make\n    ./programa\n\nArba rankiniu b\u016bdu:\n    g++ -Wall -std=c++11 -c main.cpp\n    g++ -Wall -std=c++11 -c rusiavimas.cpp\n    g++ main.o rusiavimas.o -o programa\n    ./programa\n\n-------------------------------------------\nPROGRAMOS APRA\u0160YMAS\n-------------------------------------------\n\nPrograma leid\u017eia vartotojui \u012fvesti sveikus skai\u010dius\narba \u017eod\u017eius, sur\u016b\u0161iuoja juos Bubble sort algoritmu\nir atspausdina rezultat\u0105.\n\nPrograma demonstruoja evoliucij\u0105:\n1. Masyvas \u2192 vector&lt;int&gt;\n2. vector&lt;int&gt; \u2192 vector&lt;string&gt;\n\n-------------------------------------------\nTESTAVIMO PAVYZD\u017dIAI\n-------------------------------------------\n\nTestas 1 (skai\u010diai):\n    \u012evedimas: 42 17 99 0\n    Rezultatas: 17 42 99\n\nTestas 2 (\u017eod\u017eiai):\n    \u012evedimas: obuolys bananas citrina -\n    Rezultatas: bananas citrina obuolys\n\n-------------------------------------------\nPASTABOS\n-------------------------------------------\n\n- Senasis kodas u\u017ekomentuotas, bet matomas\n- Naudojamas Bubble sort (ne std::sort)\n- Header guards naudojami rusiavimas.h faile\n</code></pre>"},{"location":"Pratybos/po%20U1/U1-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/po%20U1/U1-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas U\u017emir\u0161o header guards \u2b50\u2b50\u2b50\u2b50 Parodyti kompiliavimo klaid\u0105 be j\u0173 <code>#include &lt;rusiavimas.h&gt;</code> vietoj <code>\"...\"</code> \u2b50\u2b50\u2b50\u2b50 Paai\u0161kinti skirtum\u0105 Neperdav\u0117 vektoriaus per nuorod\u0105 (<code>&amp;</code>) \u2b50\u2b50\u2b50 Parodyti, kad r\u016b\u0161iavimas neveikia Bubble sort off-by-one error \u2b50\u2b50\u2b50 Debug'inti su <code>cout</code> cikle Neu\u017ekomentavo seno kodo \u2b50\u2b50 Atimti balus (vertinimo kriterijus!) Makefile su spaces vietoj TAB \u2b50\u2b50 <code>make: *** missing separator</code> klaida"},{"location":"Pratybos/po%20U1/U1-solution/#galimi-prapletimai-stipriesiems","title":"Galimi prapl\u0117timai stipriesiems:","text":"<ol> <li>\u012evesti kelet\u0105 test\u0173 rinkmen\u0173</li> <li> <p>Skaityti i\u0161 fail\u0173 (<code>ifstream</code>)</p> </li> <li> <p>Matuoti r\u016b\u0161iavimo laik\u0105</p> </li> <li><code>#include &lt;chrono&gt;</code></li> <li> <p>Palyginti su <code>std::sort()</code></p> </li> <li> <p>Prid\u0117ti kitus r\u016b\u0161iavimo algoritmus</p> </li> <li>Selection sort</li> <li>Insertion sort</li> <li> <p>Palyginti efektyvum\u0105</p> </li> <li> <p>Error handling</p> </li> <li>Patikrinti, ar \u012fvedimas korekti\u0161kas</li> <li><code>cin.fail()</code> tikrinimas</li> </ol>"},{"location":"Pratybos/po%20U1/U1-solution/#diskusijos-taskai-paskaitoje","title":"\ud83d\udca1 Diskusijos ta\u0161kai paskaitoje","text":"<ol> <li>Kod\u0117l vector geresnis u\u017e masyv\u0105?</li> <li>Dinaminis dydis</li> <li>Automatinis memory management</li> <li> <p><code>.size()</code>, <code>.push_back()</code> patogumas</p> </li> <li> <p>Kod\u0117l reikia header guards?</p> </li> <li> <p>Pademonstruoti multiple inclusion problem\u0105</p> </li> <li> <p>Kod\u0117l perduoti per nuorod\u0105 (<code>&amp;</code>)?</p> </li> <li>Efektyvumas (nekopijuojama)</li> <li> <p>Modifikuojamas originalas</p> </li> <li> <p>Foreshadowing templates:</p> </li> <li>\"Ar matote, kad tas pats algoritmas veikia su <code>int</code> ir <code>string</code>?\"</li> <li>\"V\u0117liau i\u0161moksite templates - generin\u012f kod\u0105!\"</li> </ol> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/po%20U1/U1/","title":"U1: C++ Primityvai ir Funkcij\u0173 Moduliai","text":"<p>Savait\u0117s: 1-2 Svoris: 1 balas Terminas: Savait\u0117s 2 pabaiga</p>"},{"location":"Pratybos/po%20U1/U1/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>SVARBU: Jei dar nesuk\u016br\u0117te GitLab projekto, pirmiausia perskaitykite: \ud83d\udc49 U\u017eduo\u010di\u0173 Atlikimo ir Pateikimo Gidas</p> <p>Ten rasite: - GitLab projekto suk\u016brimo instrukcijas - Projekto strukt\u016br\u0105 - Git workflow gaires - README.md \u0161ablonus - Pateikimo \u012f Moodle proces\u0105</p>"},{"location":"Pratybos/po%20U1/U1/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>\u012esiva\u017eiuoti su C++ sintakse, i\u0161mokti dirbti su masyvais, konteineriais ir funkcijomis. Suprasti modulin\u0119 program\u0173 strukt\u016br\u0105.</p>"},{"location":"Pratybos/po%20U1/U1/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Naudoti C++ \u012fvesties/i\u0161vesties srautus (<code>cin</code>, <code>cout</code>)</li> <li>\u2705 Dirbti su masyvais ir <code>vector</code> konteineriais</li> <li>\u2705 Ra\u0161yti ir kviesti funkcijas</li> <li>\u2705 Organizuoti kod\u0105 \u012f keli\u0173 fail\u0173 strukt\u016br\u0105 (<code>.h</code>/<code>.cpp</code>)</li> <li>\u2705 Kompiliuoti program\u0105 i\u0161 keli\u0173 fail\u0173</li> </ul>"},{"location":"Pratybos/po%20U1/U1/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/po%20U1/U1/#1-zingsnis-hello-c-ir-masyvu-ivestis","title":"1 \u017eingsnis. \"Hello C++\" ir masyv\u0173 \u012fvestis","text":"<p>Reikalavimai: 1. Para\u0161ykite program\u0105, kuri:    - I\u0161veda \"Hello, C++!\" \u012f konsol\u0119    - Leid\u017eia vartotojui \u012fvesti sveikus skai\u010dius    - Talpina skai\u010dius \u012f fiksuoto dyd\u017eio masyv\u0105 (pvz., 100 element\u0173)    - Baigia \u012fvedim\u0105, kai vartotojas \u012fveda <code>0</code>    - Atspausdina visus \u012fvestus skai\u010dius</p> <p>Technikos: - Naudokite <code>cout</code> i\u0161vedimui - Naudokite <code>cin</code> \u012fvedimui - Naudokite <code>int</code> tipo masyv\u0105: <code>int skaiciai[100];</code> - Saugokite \u012fvest\u0173 skai\u010di\u0173 kiek\u012f atskirame kintamajame</p> <p>Pavyzdys: <pre><code>Hello, C++!\n\u012eveskite sveikus skai\u010dius (0 - baigti):\n42\n17\n99\n0\n\u012evesti skai\u010diai: 42 17 99\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U1/#2-zingsnis-bubble-sort-funkcija","title":"2 \u017eingsnis. Bubble sort funkcija","text":"<p>Reikalavimai: 1. Para\u0161ykite funkcij\u0105 <code>rusiuotiMasyva()</code>, kuri:    - Priima masyv\u0105 ir jo dyd\u012f    - Sur\u016b\u0161iuoja masyvo elementus nuo ma\u017eiausio iki did\u017eiausio    - Naudoja Bubble sort algoritm\u0105</p> <ol> <li>Programos <code>main()</code> funkcijoje:</li> <li>I\u0161kvieskite r\u016b\u0161iavimo funkcij\u0105</li> <li>Atspausdinkite sur\u016b\u0161iuotus skai\u010dius</li> </ol> <p>Technikos: - Funkcijos deklaracija: <code>void rusiuotiMasyva(int masyvas[], int dydis);</code> - Bubble sort: lyginkite gretimus elementus ir keiskite vietomis</p> <p>Pavyzdys: <pre><code>\u012evesti skai\u010diai: 42 17 99\nSur\u016b\u0161iuoti skai\u010diai: 17 42 99\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U1/#3-zingsnis-moduline-struktura-h-cpp","title":"3 \u017eingsnis. Modulin\u0117 strukt\u016bra (.h + .cpp)","text":"<p>Reikalavimai: 1. Sukurkite 3 failus direktorijoje <code>U1/03/</code>:    - <code>main.cpp</code> - pagrindin\u0117 programa (tik <code>main()</code> funkcija)    - <code>rusiavimas.h</code> - funkcij\u0173 deklaracijos    - <code>rusiavimas.cpp</code> - funkcij\u0173 implementacijos</p> <ol> <li><code>rusiavimas.h</code> turi tur\u0117ti:</li> <li>Header guard (<code>#ifndef</code>, <code>#define</code>, <code>#endif</code>)</li> <li>Funkcijos <code>rusiuotiMasyva()</code> deklaracij\u0105</li> <li> <p>Funkcijos <code>spausdintiMasyva()</code> deklaracij\u0105 (nauja!)</p> </li> <li> <p><code>rusiavimas.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li> <p>Funkcij\u0173 implementacijas</p> </li> <li> <p><code>main.cpp</code> turi tur\u0117ti:</p> </li> <li><code>#include \"rusiavimas.h\"</code></li> <li>Tik <code>main()</code> funkcij\u0105</li> </ol> <p>Kompiliacija: <pre><code>cd U1/03/\ng++ -c main.cpp\ng++ -c rusiavimas.cpp\ng++ main.o rusiavimas.o -o programa\n./programa\n</code></pre></p> <p>Arba naudojant Makefile (rekomenduojama).</p>"},{"location":"Pratybos/po%20U1/U1/#4-zingsnis-evoliucija-array-vectorint","title":"4 \u017eingsnis. Evoliucija: array \u2192 vector\\&lt;int&gt;","text":"<p>Reikalavimai: 1. Pakeiskite masyv\u0105 <code>int skaiciai[100]</code> \u012f <code>vector&lt;int&gt; skaiciai</code> 2. Vietoj <code>skaiciai[kiekis++] = x</code> naudokite <code>skaiciai.push_back(x)</code> 3. Vektoriaus dyd\u012f gaukite su <code>skaiciai.size()</code> 4. Adaptuokite r\u016b\u0161iavimo funkcij\u0105 dirbti su <code>vector&lt;int&gt;</code></p> <p>SVARBU:  - U\u017ekomentuokite sen\u0105 kod\u0105 su masyvais, bet palikite j\u012f matytis faile - Tai leis d\u0117stytojui \u012fsitikinti, kad atlikote visus \u017eingsnius</p> <p>Technikos: - <code>#include &lt;vector&gt;</code> - <code>vector&lt;int&gt;</code> vietoj <code>int[]</code> - Funkcija gali b\u016bti: <code>void rusiuotiVektoriu(vector&lt;int&gt;&amp; skaiciai)</code> - Perduokite vektori\u0173 per nuorod\u0105 (<code>&amp;</code>)</p>"},{"location":"Pratybos/po%20U1/U1/#5-zingsnis-evoliucija-vectorint-vectorstring","title":"5 \u017eingsnis. Evoliucija: vector\\&lt;int&gt; \u2192 vector\\&lt;string&gt;","text":"<p>Reikalavimai: 1. Sukurkite nauj\u0105 programos versij\u0105, kuri:    - \u012eveda \u017eod\u017eius (ne skai\u010dius)    - Baigia \u012fvedim\u0105, kai \u012fvedamas <code>-</code>    - R\u016b\u0161iuoja \u017eod\u017eius ab\u0117c\u0117l\u0117s tvarka    - Atspausdina sur\u016b\u0161iuotus \u017eod\u017eius</p> <ol> <li>Naudokite <code>vector&lt;string&gt;</code> konteiner\u012f</li> <li>R\u016b\u0161iavimo funkcija turi veikti su <code>string</code> tipu</li> </ol> <p>SVARBU: - V\u0117l u\u017ekomentuokite sen\u0105 kod\u0105 (su <code>int</code>), bet palikite matytis</p> <p>Technikos: - <code>#include &lt;string&gt;</code> - <code>vector&lt;string&gt;</code> vietoj <code>vector&lt;int&gt;</code> - <code>string</code> tipas palaiko <code>&lt;</code> operatori\u0173 (ab\u0117c\u0117l\u0117s tvarka)</p> <p>Pavyzdys: <pre><code>\u012eveskite \u017eod\u017eius ('-' baigti):\nobuolys\nbananas\ncitrina\n-\nSur\u016b\u0161iuoti \u017eod\u017eiai: bananas citrina obuolys\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U1/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/po%20U1/U1/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md              \u2190 Projekto README (\u017er. UzduotiuGidas.md)\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 U1/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 1 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 02/                \u2190 2 \u017eingsnis\n    \u2502   \u2514\u2500\u2500 main.cpp\n    \u251c\u2500\u2500 03/                \u2190 3 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 04/                \u2190 4 \u017eingsnis\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u251c\u2500\u2500 rusiavimas.h\n    \u2502   \u251c\u2500\u2500 rusiavimas.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 05/                \u2190 5 \u017eingsnis (FINAL)\n        \u251c\u2500\u2500 main.cpp\n        \u251c\u2500\u2500 rusiavimas.h\n        \u251c\u2500\u2500 rusiavimas.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/po%20U1/U1/#git-workflow-tariamas","title":"Git workflow (tariamas):","text":"<p>Po kiekvieno \u017eingsnio: <pre><code>cd cpp-2026/U1/01/\n# ... atlikti darb\u0105 ...\n\ngit add U1/01/\ngit commit -m \"U1: 1 \u017eingsnis - Hello World ir masyv\u0173 \u012fvestis\"\ngit push\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U1/#moodle-pateikimas-tariamas","title":"Moodle pateikimas (tariamas):","text":"<ol> <li> <p>Sukurti archyv\u0105:    <pre><code>cd cpp-2026\ngit archive --format=zip --output=U1_VardasPavarde.zip HEAD U1/ README.md .gitignore\n</code></pre></p> </li> <li> <p>\u012ekelti \u012f Moodle su GitLab URL</p> </li> </ol>"},{"location":"Pratybos/po%20U1/U1/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Perskaitykite U\u017eduo\u010di\u0173 Gidas prie\u0161 pradedant</li> <li>Git workflow:</li> <li>Commit'inkite po kiekvieno \u017eingsnio</li> <li>Push'inkite da\u017enai (backup!)</li> <li>Prad\u0117kite paprastai - pirmiausia paleiskite 1 \u017eingsn\u012f, tada t\u0119skite</li> <li>Kompiliuokite da\u017enai - po kiekvieno \u017eingsnio</li> <li>Testuokite su skirtingais duomenimis - teigiami, neigiami skai\u010diai</li> <li>Klauskite, jei neai\u0161ku - geriau anks\u010diau nei v\u0117liau!</li> </ol>"},{"location":"Pratybos/po%20U1/U1/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ vector dokumentacija</li> <li>C++ string dokumentacija</li> <li>Makefile tutorial</li> </ul>"},{"location":"Pratybos/po%20U1/U1/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Ar galiu naudoti <code>std::sort()</code> vietoj Bubble sort? A: Ne, \u0161ioje u\u017eduotyje privaloma implementuoti Bubble sort patys.</p> <p>K: Ar privalau naudoti Makefile? A: Ne, bet rekomenduojama nuo 3 \u017eingsnio. Galite kompiliuoti rankiniu b\u016bdu.</p> <p>K: Kiek test\u0173 reikia README faile? A: Bent 2 - vienas su skai\u010diais, vienas su \u017eod\u017eiais.</p> <p>K: Ar galiu naudoti branch'us vietoj subdirektorij\u0173? A: Taip, bet neprivaloma. Subdirektorijos (<code>01/</code>, <code>02/</code>, ...) paprastesn\u0117s.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/po%20U1/U2-solution/","title":"U2: Sprendimas - IntList Klas\u0117 ir RAII","text":"<p>D\u0117stytojui: Pilnas sprendimas su kodu ir paai\u0161kinimais.</p>"},{"location":"Pratybos/po%20U1/U2-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U2/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 IntList.h\n\u2502   \u251c\u2500\u2500 IntList.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 02/\n\u2502   \u251c\u2500\u2500 IntList.h\n\u2502   \u251c\u2500\u2500 IntList.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u2514\u2500\u2500 03/\n    \u251c\u2500\u2500 IntList.h\n    \u251c\u2500\u2500 IntList.cpp\n    \u251c\u2500\u2500 main.cpp\n    \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#1-1-zingsnis-basic-klase-su-fiksuotu-masyvu","title":"1\ufe0f\u20e3 1 \u017eingsnis: Basic klas\u0117 su fiksuotu masyvu","text":""},{"location":"Pratybos/po%20U1/U2-solution/#intlisth","title":"IntList.h:","text":"<pre><code>#ifndef INTLIST_H\n#define INTLIST_H\n\nclass IntList {\nprivate:\n    int duomenys[100];  // Fiksuoto dyd\u017eio masyvas\n    int dydis;          // Dabartinis element\u0173 skai\u010dius\n\npublic:\n    // Konstruktorius\n    IntList();\n\n    // Metodai\n    void pridetiGala(int reiksme);\n    int gautiElementa(int indeksas) const;\n    int gautiDydi() const;\n    void spausdinti() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos-header-guard","title":"Pedagogin\u0117s pastabos (header guard):","text":"<ul> <li>\u2705 <code>#ifndef</code> / <code>#define</code> / <code>#endif</code> - standartas</li> <li>\u2705 Paprastai vardas: <code>KLASESVARAS_H</code> (uppercase)</li> <li>\u26a0\ufe0f Da\u017ena klaida: pamir\u0161ti <code>#endif</code></li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#intlistcpp","title":"IntList.cpp:","text":"<pre><code>#include \"IntList.h\"\n#include &lt;iostream&gt;\n\n// Konstruktorius\nIntList::IntList() {\n    dydis = 0;  // Prad\u017eioje s\u0105ra\u0161as tu\u0161\u010dias\n}\n\n// Prid\u0117ti element\u0105 \u012f pabaig\u0105\nvoid IntList::pridetiGala(int reiksme) {\n    if (dydis &gt;= 100) {\n        std::cout &lt;&lt; \"[KLAIDA] Masyvas pilnas!\" &lt;&lt; std::endl;\n        return;\n    }\n    duomenys[dydis] = reiksme;\n    dydis++;\n}\n\n// Gauti element\u0105 pagal indeks\u0105\nint IntList::gautiElementa(int indeksas) const {\n    if (indeksas &lt; 0 || indeksas &gt;= dydis) {\n        std::cout &lt;&lt; \"[KLAIDA] Blogas indeksas!\" &lt;&lt; std::endl;\n        return -1;  // Klaida (v\u0117liau bus exception)\n    }\n    return duomenys[indeksas];\n}\n\n// Gauti dabartin\u012f dyd\u012f\nint IntList::gautiDydi() const {\n    return dydis;\n}\n\n// Spausdinti visus elementus\nvoid IntList::spausdinti() const {\n    std::cout &lt;&lt; \"IntList dydis: \" &lt;&lt; dydis &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Elementai: [\";\n    for (int i = 0; i &lt; dydis; i++) {\n        std::cout &lt;&lt; duomenys[i];\n        if (i &lt; dydis - 1) {\n            std::cout &lt;&lt; \", \";\n        }\n    }\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>IntList::</code> - scope resolution operator (klas\u0117s narys)</li> <li>\u2705 <code>const</code> metodai - nekei\u010dia objekto b\u016bsenos</li> <li>\u2705 Error handling - paprastas (<code>cout</code> + <code>return</code>)</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>dydis++</code> vietoj <code>dydis = dydis + 1</code> (bet abu OK)</li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#maincpp","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"IntList.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== IntList 1 \u017eingsnis (fixed array) ===\" &lt;&lt; endl;\n\n    // Sukurti IntList\n    IntList sarasas;\n\n    // Prid\u0117ti elementus\n    cout &lt;&lt; \"\\nPridedame 5 elementus:\" &lt;&lt; endl;\n    for (int i = 1; i &lt;= 5; i++) {\n        sarasas.pridetiGala(i * 10);\n    }\n\n    // Atspausdinti\n    sarasas.spausdinti();\n\n    // Gauti element\u0105\n    cout &lt;&lt; \"\\nElementas [2]: \" &lt;&lt; sarasas.gautiElementa(2) &lt;&lt; endl;\n\n    // Testas: pilnas masyvas\n    cout &lt;&lt; \"\\nBandome prid\u0117ti 100 element\u0173 (tur\u0117t\u0173 b\u016bti klaida):\" &lt;&lt; endl;\n    IntList didelis;\n    for (int i = 0; i &lt; 105; i++) {\n        didelis.pridetiGala(i);\n    }\n    cout &lt;&lt; \"Prid\u0117ta element\u0173: \" &lt;&lt; didelis.gautiDydi() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#makefile","title":"Makefile:","text":"<pre><code>CXX = g++\nCXXFLAGS = -Wall -std=c++11\n\nOBJS = main.o IntList.o\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\nmain.o: main.cpp IntList.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nIntList.o: IntList.cpp IntList.h\n    $(CXX) $(CXXFLAGS) -c IntList.cpp\n\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#kompiliacija-ir-testavimas","title":"Kompiliacija ir testavimas:","text":"<pre><code>cd U2/01/\nmake\n./programa\n</code></pre> <p>I\u0161vestis: <pre><code>=== IntList 1 \u017eingsnis (fixed array) ===\n\nPridedame 5 elementus:\nIntList dydis: 5\nElementai: [10, 20, 30, 40, 50]\n\nElementas [2]: 30\n\nBandome prid\u0117ti 100 element\u0173 (tur\u0117t\u0173 b\u016bti klaida):\n[KLAIDA] Masyvas pilnas!\n[KLAIDA] Masyvas pilnas!\n[KLAIDA] Masyvas pilnas!\n...\nPrid\u0117ta element\u0173: 100\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2-solution/#2-2-zingsnis-dynamic-memory-raii","title":"2\ufe0f\u20e3 2 \u017eingsnis: Dynamic memory + RAII","text":""},{"location":"Pratybos/po%20U1/U2-solution/#intlisth-modifikuotas","title":"IntList.h (modifikuotas):","text":"<pre><code>#ifndef INTLIST_H\n#define INTLIST_H\n\nclass IntList {\nprivate:\n    int* duomenys;      // Rodykl\u0117 \u012f dinamin\u012f masyv\u0105 (NAUJAS!)\n    int dydis;          // Dabartinis element\u0173 skai\u010dius\n    int talpa;          // I\u0161skirtos atminties talpa (NAUJAS!)\n\npublic:\n    // Konstruktoriai (NAUJI!)\n    IntList();                      // Default: talpa = 10\n    IntList(int pradineTalpa);      // Su parametru\n\n    // Destruktorius (NAUJAS!)\n    ~IntList();\n\n    // Metodai (tie patys kaip 1 \u017eingsnyje)\n    void pridetiGala(int reiksme);\n    int gautiElementa(int indeksas) const;\n    int gautiDydi() const;\n    void spausdinti() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>int*</code> - rodykl\u0117 (pointer)</li> <li>\u2705 <code>talpa</code> vs <code>dydis</code> - svarbu atskirti!</li> <li>\u2705 Destruktorius - <code>~IntList()</code> (tilde <code>~</code>)</li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#intlistcpp-modifikuotas","title":"IntList.cpp (modifikuotas):","text":"<pre><code>#include \"IntList.h\"\n#include &lt;iostream&gt;\n\n// Default konstruktorius\nIntList::IntList() {\n    talpa = 10;\n    dydis = 0;\n    duomenys = new int[talpa];  // Dinaminis masyvas!\n    std::cout &lt;&lt; \"[DEBUG] IntList sukurtas (talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\n// Konstruktorius su parametru\nIntList::IntList(int pradineTalpa) {\n    talpa = pradineTalpa;\n    dydis = 0;\n    duomenys = new int[talpa];\n    std::cout &lt;&lt; \"[DEBUG] IntList sukurtas (talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\n// Destruktorius\nIntList::~IntList() {\n    std::cout &lt;&lt; \"[DEBUG] IntList naikinamas (dydis=\" &lt;&lt; dydis \n              &lt;&lt; \", talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n    delete[] duomenys;      // Atlaisvinti atmint\u012f\n    duomenys = nullptr;     // Saugumui\n}\n\n// Prid\u0117ti element\u0105\nvoid IntList::pridetiGala(int reiksme) {\n    if (dydis &gt;= talpa) {\n        std::cout &lt;&lt; \"[KLAIDA] IntList pilnas (talpa=\" &lt;&lt; talpa &lt;&lt; \")!\" &lt;&lt; std::endl;\n        return;\n    }\n    duomenys[dydis] = reiksme;\n    dydis++;\n}\n\n// Gauti element\u0105 (tas pats)\nint IntList::gautiElementa(int indeksas) const {\n    if (indeksas &lt; 0 || indeksas &gt;= dydis) {\n        std::cout &lt;&lt; \"[KLAIDA] Blogas indeksas!\" &lt;&lt; std::endl;\n        return -1;\n    }\n    return duomenys[indeksas];\n}\n\n// Gauti dyd\u012f (tas pats)\nint IntList::gautiDydi() const {\n    return dydis;\n}\n\n// Spausdinti (tas pats)\nvoid IntList::spausdinti() const {\n    std::cout &lt;&lt; \"IntList dydis: \" &lt;&lt; dydis &lt;&lt; \" / talpa: \" &lt;&lt; talpa &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Elementai: [\";\n    for (int i = 0; i &lt; dydis; i++) {\n        std::cout &lt;&lt; duomenys[i];\n        if (i &lt; dydis - 1) {\n            std::cout &lt;&lt; \", \";\n        }\n    }\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>new int[talpa]</code> - i\u0161skirti dinamin\u012f masyv\u0105</li> <li>\u2705 <code>delete[] duomenys</code> - SVARBU: <code>delete[]</code> (su <code>[]</code>), ne <code>delete</code>!</li> <li>\u2705 <code>nullptr</code> po <code>delete[]</code> - gera praktika (dangling pointer prevention)</li> <li>\u2705 Logging - matome, kada konstruktorius/destruktorius kvie\u010diami</li> <li>\u26a0\ufe0f KRITIN\u0116 KLAIDA: <code>delete duomenys</code> vietoj <code>delete[] duomenys</code> \u2192 undefined behavior!</li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#maincpp-modifikuotas","title":"main.cpp (modifikuotas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"IntList.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== IntList 2 \u017eingsnis (dynamic memory + RAII) ===\" &lt;&lt; endl;\n\n    // Testas 1: Default konstruktorius\n    cout &lt;&lt; \"\\n--- Testas 1: Default konstruktorius ---\" &lt;&lt; endl;\n    {\n        IntList sarasas;  // talpa = 10\n        for (int i = 1; i &lt;= 5; i++) {\n            sarasas.pridetiGala(i * 10);\n        }\n        sarasas.spausdinti();\n    } // Destruktorius \u010dia!\n    cout &lt;&lt; \"Destruktorius jau i\u0161kvie\u010diamas (scope pabaiga)\" &lt;&lt; endl;\n\n    // Testas 2: Konstruktorius su parametru\n    cout &lt;&lt; \"\\n--- Testas 2: Konstruktorius su parametru ---\" &lt;&lt; endl;\n    {\n        IntList mazosSarasas(3);  // talpa = 3\n        mazosSarasas.pridetiGala(100);\n        mazosSarasas.pridetiGala(200);\n        mazosSarasas.pridetiGala(300);\n        mazosSarasas.spausdinti();\n\n        // Bandome prid\u0117ti 4-\u0105 (tur\u0117t\u0173 b\u016bti klaida)\n        cout &lt;&lt; \"\\nBandome prid\u0117ti 4-\u0105 element\u0105 (klaida!):\" &lt;&lt; endl;\n        mazosSarasas.pridetiGala(400);\n    } // Destruktorius \u010dia!\n\n    // Testas 3: Daug objekt\u0173\n    cout &lt;&lt; \"\\n--- Testas 3: Daug objekt\u0173 ---\" &lt;&lt; endl;\n    {\n        IntList s1, s2, s3;\n        s1.pridetiGala(1);\n        s2.pridetiGala(2);\n        s3.pridetiGala(3);\n        cout &lt;&lt; \"Sukurti 3 objektai (destruktoriai bus i\u0161kvie\u010diami reverse order)\" &lt;&lt; endl;\n    } // 3 destruktoriai \u010dia!\n\n    cout &lt;&lt; \"\\n=== Programa baigta ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>=== IntList 2 \u017eingsnis (dynamic memory + RAII) ===\n\n--- Testas 1: Default konstruktorius ---\n[DEBUG] IntList sukurtas (talpa=10)\nIntList dydis: 5 / talpa: 10\nElementai: [10, 20, 30, 40, 50]\n[DEBUG] IntList naikinamas (dydis=5, talpa=10)\nDestruktorius jau i\u0161kvie\u010diamas (scope pabaiga)\n\n--- Testas 2: Konstruktorius su parametru ---\n[DEBUG] IntList sukurtas (talpa=3)\nIntList dydis: 3 / talpa: 3\nElementai: [100, 200, 300]\n\nBandome prid\u0117ti 4-\u0105 element\u0105 (klaida!):\n[KLAIDA] IntList pilnas (talpa=3)!\n[DEBUG] IntList naikinamas (dydis=3, talpa=3)\n\n--- Testas 3: Daug objekt\u0173 ---\n[DEBUG] IntList sukurtas (talpa=10)\n[DEBUG] IntList sukurtas (talpa=10)\n[DEBUG] IntList sukurtas (talpa=10)\nSukurti 3 objektai (destruktoriai bus i\u0161kvie\u010diami reverse order)\n[DEBUG] IntList naikinamas (dydis=1, talpa=10)\n[DEBUG] IntList naikinamas (dydis=1, talpa=10)\n[DEBUG] IntList naikinamas (dydis=1, talpa=10)\n\n=== Programa baigta ===\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Scope <code>{ ... }</code> - destruktorius automati\u0161kai kvie\u010diamas scope pabaigoje</li> <li>\u2705 Reverse order - konstruktoriai: 1\u21922\u21923, destruktoriai: 3\u21922\u21921 (stack unwinding)</li> <li>\ud83d\udca1 Diskusijos ta\u0161kas: \"Kod\u0117l destruktoriai reverse order?\" (stack semantics)</li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#3-3-zingsnis-automatinis-ispletimas","title":"3\ufe0f\u20e3 3 \u017eingsnis: Automatinis i\u0161pl\u0117timas","text":""},{"location":"Pratybos/po%20U1/U2-solution/#intlisth-papildymas","title":"IntList.h (papildymas):","text":"<pre><code>#ifndef INTLIST_H\n#define INTLIST_H\n\nclass IntList {\nprivate:\n    int* duomenys;\n    int dydis;\n    int talpa;\n\n    // Private metodas (NAUJAS!)\n    void isplesti();\n\npublic:\n    IntList();\n    IntList(int pradineTalpa);\n    ~IntList();\n\n    void pridetiGala(int reiksme);\n    int gautiElementa(int indeksas) const;\n    int gautiDydi() const;\n    int gautiTalpa() const;  // NAUJAS - debugging\n    void spausdinti() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#intlistcpp-galutine-versija","title":"IntList.cpp (galutin\u0117 versija):","text":"<pre><code>#include \"IntList.h\"\n#include &lt;iostream&gt;\n\n// Konstruktoriai (tie patys)\nIntList::IntList() {\n    talpa = 10;\n    dydis = 0;\n    duomenys = new int[talpa];\n    std::cout &lt;&lt; \"[DEBUG] IntList sukurtas (talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\nIntList::IntList(int pradineTalpa) {\n    talpa = pradineTalpa;\n    dydis = 0;\n    duomenys = new int[talpa];\n    std::cout &lt;&lt; \"[DEBUG] IntList sukurtas (talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\n// Destruktorius (tas pats)\nIntList::~IntList() {\n    std::cout &lt;&lt; \"[DEBUG] IntList naikinamas (dydis=\" &lt;&lt; dydis \n              &lt;&lt; \", talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; std::endl;\n    delete[] duomenys;\n    duomenys = nullptr;\n}\n\n// NAUJAS: Privatus metodas - i\u0161pl\u0117sti masyv\u0105\nvoid IntList::isplesti() {\n    int naujaTalpa = talpa + 5;  // Didinti po 5\n\n    std::cout &lt;&lt; \"[DEBUG] IntList isplesta (sena talpa=\" &lt;&lt; talpa \n              &lt;&lt; \", nauja talpa=\" &lt;&lt; naujaTalpa &lt;&lt; \")\" &lt;&lt; std::endl;\n\n    // 1. I\u0161skirti nauj\u0105 masyv\u0105\n    int* naujasDuomenys = new int[naujaTalpa];\n\n    // 2. Nukopijuoti senus duomenis\n    for (int i = 0; i &lt; dydis; i++) {\n        naujasDuomenys[i] = duomenys[i];\n    }\n\n    // 3. Atlaisvinti sen\u0105 masyv\u0105\n    delete[] duomenys;\n\n    // 4. Priskirti nauj\u0105 masyv\u0105\n    duomenys = naujasDuomenys;\n    talpa = naujaTalpa;\n}\n\n// MODIFIKUOTAS: Prid\u0117ti element\u0105 (dabar su auto-expand)\nvoid IntList::pridetiGala(int reiksme) {\n    if (dydis &gt;= talpa) {\n        isplesti();  // Automatinis i\u0161pl\u0117timas!\n    }\n    duomenys[dydis] = reiksme;\n    dydis++;\n}\n\n// Kiti metodai (tie patys)\nint IntList::gautiElementa(int indeksas) const {\n    if (indeksas &lt; 0 || indeksas &gt;= dydis) {\n        std::cout &lt;&lt; \"[KLAIDA] Blogas indeksas!\" &lt;&lt; std::endl;\n        return -1;\n    }\n    return duomenys[indeksas];\n}\n\nint IntList::gautiDydi() const {\n    return dydis;\n}\n\n// NAUJAS - debugging\nint IntList::gautiTalpa() const {\n    return talpa;\n}\n\nvoid IntList::spausdinti() const {\n    std::cout &lt;&lt; \"IntList dydis: \" &lt;&lt; dydis &lt;&lt; \" / talpa: \" &lt;&lt; talpa &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Elementai: [\";\n    for (int i = 0; i &lt; dydis; i++) {\n        std::cout &lt;&lt; duomenys[i];\n        if (i &lt; dydis - 1) {\n            std::cout &lt;&lt; \", \";\n        }\n    }\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>isplesti()</code> - private metodas (internal implementation detail)</li> <li>\u2705 Reallocation algoritmas:</li> <li>I\u0161skirti nauj\u0105 didesn\u012f masyv\u0105</li> <li>Kopijuoti senus duomenis</li> <li>Atlaisvinti sen\u0105</li> <li>Priskirti nauj\u0105</li> <li>\u26a0\ufe0f KRITIN\u0116 KLAIDA: Kopijuoti prie\u0161 <code>delete[]</code> (prie\u0161ingu atveju - duomen\u0173 praradimas!)</li> <li>\ud83d\udca1 Optimizacija: Growth factor (dabar +5, galima *2 - logaritminis growth)</li> </ul>"},{"location":"Pratybos/po%20U1/U2-solution/#maincpp-galutinis-testas","title":"main.cpp (galutinis testas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"IntList.h\"\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== IntList 3 \u017eingsnis (auto-expand) ===\" &lt;&lt; endl;\n\n    // Testas 1: Ma\u017eas talpa, daug element\u0173\n    cout &lt;&lt; \"\\n--- Testas 1: Ma\u017eas talpa (3), pridedame 10 element\u0173 ---\" &lt;&lt; endl;\n    IntList sarasas(3);\n    for (int i = 1; i &lt;= 10; i++) {\n        cout &lt;&lt; \"Pridedame \" &lt;&lt; (i * 10) &lt;&lt; \"...\" &lt;&lt; endl;\n        sarasas.pridetiGala(i * 10);\n    }\n    sarasas.spausdinti();\n\n    // Testas 2: Default talpa, daug element\u0173\n    cout &lt;&lt; \"\\n--- Testas 2: Default talpa (10), pridedame 20 element\u0173 ---\" &lt;&lt; endl;\n    IntList didelis;\n    for (int i = 1; i &lt;= 20; i++) {\n        didelis.pridetiGala(i);\n    }\n    didelis.spausdinti();\n\n    // Testas 3: Labai ma\u017eas talpa (1), demonstruoti daug i\u0161pl\u0117tim\u0173\n    cout &lt;&lt; \"\\n--- Testas 3: Talpa=1, pridedame 7 elementus (daug i\u0161pl\u0117tim\u0173) ---\" &lt;&lt; endl;\n    IntList mazytis(1);\n    for (int i = 0; i &lt; 7; i++) {\n        mazytis.pridetiGala(i * 100);\n    }\n    mazytis.spausdinti();\n\n    cout &lt;&lt; \"\\n=== Programa baigta (destruktoriai bus i\u0161kvie\u010diami) ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>=== IntList 3 \u017eingsnis (auto-expand) ===\n\n--- Testas 1: Ma\u017eas talpa (3), pridedame 10 element\u0173 ---\n[DEBUG] IntList sukurtas (talpa=3)\nPridedame 10...\nPridedame 20...\nPridedame 30...\nPridedame 40...\n[DEBUG] IntList isplesta (sena talpa=3, nauja talpa=8)\nPridedame 50...\nPridedame 60...\nPridedame 70...\nPridedame 80...\nPridedame 90...\n[DEBUG] IntList isplesta (sena talpa=8, nauja talpa=13)\nPridedame 100...\nIntList dydis: 10 / talpa: 13\nElementai: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n\n--- Testas 2: Default talpa (10), pridedame 20 element\u0173 ---\n[DEBUG] IntList sukurtas (talpa=10)\n[DEBUG] IntList isplesta (sena talpa=10, nauja talpa=15)\n[DEBUG] IntList isplesta (sena talpa=15, nauja talpa=20)\nIntList dydis: 20 / talpa: 20\nElementai: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\n--- Testas 3: Talpa=1, pridedame 7 elementus (daug i\u0161pl\u0117tim\u0173) ---\n[DEBUG] IntList sukurtas (talpa=1)\n[DEBUG] IntList isplesta (sena talpa=1, nauja talpa=6)\n[DEBUG] IntList isplesta (sena talpa=6, nauja talpa=11)\nIntList dydis: 7 / talpa: 11\nElementai: [0, 100, 200, 300, 400, 500, 600]\n\n=== Programa baigta (destruktoriai bus i\u0161kvie\u010diami) ===\n[DEBUG] IntList naikinamas (dydis=7, talpa=11)\n[DEBUG] IntList naikinamas (dydis=20, talpa=20)\n[DEBUG] IntList naikinamas (dydis=10, talpa=13)\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/po%20U1/U2-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas <code>delete duomenys</code> vietoj <code>delete[]</code> \u2b50\u2b50\u2b50\u2b50\u2b50 Kritin\u0117 klaida! Undefined behavior Neu\u017ekomentavo destruktoriaus logging \u2b50\u2b50\u2b50\u2b50 Nematys, kada destruktorius kvie\u010diamas <code>isplesti()</code> kopijuoja po <code>delete[]</code> \u2b50\u2b50\u2b50 Duomen\u0173 praradimas! Pamir\u0161o <code>nullptr</code> po <code>delete[]</code> \u2b50\u2b50\u2b50 Dangling pointer (ne kritin\u0117, bet svarbu) <code>talpa</code> vs <code>dydis</code> painiava \u2b50\u2b50 Paai\u0161kinti skirtum\u0105 Konstruktorius be logging \u2b50\u2b50 Nematys konstruktoriaus kvietim\u0173"},{"location":"Pratybos/po%20U1/U2-solution/#diskusijos-taskai-paskaitose","title":"Diskusijos ta\u0161kai paskaitose:","text":"<ol> <li>RAII principas:</li> <li>\"Kas b\u016bt\u0173, jei u\u017emir\u0161tume <code>delete[]</code>?\" \u2192 Memory leak!</li> <li> <p>\"Kod\u0117l destruktorius automati\u0161kai kvie\u010diamas?\" \u2192 RAII magic</p> </li> <li> <p><code>delete</code> vs <code>delete[]</code>:</p> </li> <li>Parodyti undefined behavior pavyzd\u012f</li> <li> <p>Valgrind demo (jei galima)</p> </li> <li> <p>Growth strategy:</p> </li> <li>Dabar: +5 (linear)</li> <li><code>std::vector</code>: \u00d72 (exponential)</li> <li> <p>Trade-off: memory vs reallocations</p> </li> <li> <p>Destruktori\u0173 tvarka:</p> </li> <li>Stack unwinding (LIFO)</li> <li> <p>Reverse order demonstration</p> </li> <li> <p>Foreshadowing:</p> </li> <li>\"V\u0117liau i\u0161moksime copy constructor - dabar shallow copy problema!\"</li> <li>\"Kas b\u016bt\u0173, jei <code>IntList s2 = s1;</code>?\" \u2192 Dangling pointer!</li> </ol>"},{"location":"Pratybos/po%20U1/U2-solution/#prapletimai-stipriesiems","title":"Prapl\u0117timai stipriesiems:","text":"<ol> <li>Growth factor:</li> <li>Pakeisti <code>talpa + 5</code> \u2192 <code>talpa * 2</code></li> <li> <p>Palyginti reallocations skai\u010di\u0173</p> </li> <li> <p>Capacity reserve:</p> </li> <li>Prid\u0117ti <code>void rezervuoti(int naujaTalpa)</code></li> <li> <p>Preallocate jei \u017einome, kiek reikia</p> </li> <li> <p>Error handling su exceptions:</p> </li> <li><code>throw std::bad_alloc</code> jei <code>new</code> fails</li> <li> <p><code>throw std::out_of_range</code> jei indeksas blogas</p> </li> <li> <p>Debugging metodai:</p> </li> <li><code>void spausdintiDebug()</code> - parodyti memory address, talpa, dydis</li> <li> <p><code>bool arTuscias()</code>, <code>bool arPilnas()</code></p> </li> <li> <p>Additional methods:</p> </li> <li><code>void pasalinti(int indeksas)</code> - remove element</li> <li><code>void isvalyti()</code> - clear all elements</li> </ol>"},{"location":"Pratybos/po%20U1/U2-solution/#testai-extra","title":"\ud83d\udca1 Testai (extra):","text":""},{"location":"Pratybos/po%20U1/U2-solution/#memory-leak-testas","title":"Memory leak testas:","text":"<pre><code>// Sukurti daug objekt\u0173 - netur\u0117t\u0173 b\u016bti memory leak\nfor (int i = 0; i &lt; 1000; i++) {\n    IntList temp(100);\n    for (int j = 0; j &lt; 50; j++) {\n        temp.pridetiGala(j);\n    }\n} // 1000 destruktori\u0173 - visos atmintis atlaisvinta?\n</code></pre> <p>Tikrinti su Valgrind: <pre><code>g++ -g main.cpp IntList.cpp -o programa\nvalgrind --leak-check=full ./programa\n</code></pre></p> <p>Rezultatas (jei teisingai): <pre><code>All heap blocks were freed -- no leaks are possible\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2-solution/#performance-testas","title":"Performance testas:","text":"<pre><code>#include &lt;chrono&gt;\n\nauto start = std::chrono::high_resolution_clock::now();\n\nIntList didelis(1);  // Ma\u017eas talpa\nfor (int i = 0; i &lt; 100000; i++) {\n    didelis.pridetiGala(i);\n}\n\nauto end = std::chrono::high_resolution_clock::now();\nauto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);\n\ncout &lt;&lt; \"Laikas: \" &lt;&lt; duration.count() &lt;&lt; \" ms\" &lt;&lt; endl;\ncout &lt;&lt; \"Reallocations: \" &lt;&lt; (didelis.gautiTalpa() - 1) / 5 &lt;&lt; endl;\n</code></pre> <p>Diskusija: Linear (+5) vs Exponential (\u00d72) growth</p> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/po%20U1/U2/","title":"U2: IntList Klas\u0117 ir RAII","text":"<p>Savait\u0117s: 3-4 Svoris: 1 balas Terminas: Savait\u0117s 4 pabaiga</p>"},{"location":"Pratybos/po%20U1/U2/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: \u0160iai u\u017eduo\u010diai taikomi tie patys reikalavimai kaip ir U1. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas d\u0117l: - GitLab projekto strukt\u016bros - Git commit'\u0173 gairi\u0173 - README.md \u0161ablon\u0173 - Pateikimo \u012f Moodle</p>"},{"location":"Pratybos/po%20U1/U2/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>Sukurti pirm\u0105 klas\u0119 su dinaminiu atminties valdymu. I\u0161mokti RAII (Resource Acquisition Is Initialization) princip\u0105 - kad konstruktorius i\u0161skiria resursus, o destruktorius juos atlaisvina.</p>"},{"location":"Pratybos/po%20U1/U2/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Sukurti klas\u0119 su private/public nariais</li> <li>\u2705 Ra\u0161yti konstruktorius (default ir su parametrais)</li> <li>\u2705 Ra\u0161yti destruktori\u0173 su logging</li> <li>\u2705 Dirbti su dinaminiu atminties skyrimu (<code>new</code>/<code>delete</code>)</li> <li>\u2705 Implementuoti automatin\u012f konteinerio i\u0161pl\u0117tim\u0105</li> <li>\u2705 Suprasti RAII princip\u0105</li> <li>\u2705 Organizuoti klas\u0119 \u012f <code>.h</code>/<code>.cpp</code> failus</li> </ul>"},{"location":"Pratybos/po%20U1/U2/#kas-yra-intlist","title":"\ud83d\udca1 Kas yra IntList?","text":"<p>IntList - tai dinaminis s\u0105ra\u0161as sveikiems skai\u010diams (pana\u0161us \u012f <code>vector&lt;int&gt;</code>).</p> <p>Funkcionalumas: - Saugoja sveikus skai\u010dius - Automati\u0161kai i\u0161siple\u010dia, kai reikia daugiau vietos - Leid\u017eia prid\u0117ti elementus \u012f pabaig\u0105 - Leid\u017eia gauti element\u0105 pagal indeks\u0105</p> <p>Skirtumas nuo U1: - U1: funkcijos su masyvais/vektoriais - U2: klas\u0117 su inkapsuliuotu dinaminiu masyvu</p>"},{"location":"Pratybos/po%20U1/U2/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/po%20U1/U2/#1-zingsnis-basic-klase-su-fiksuotu-masyvu","title":"1 \u017eingsnis: Basic klas\u0117 su fiksuotu masyvu","text":"<p>Direktorija: <code>U2/01/</code></p> <p>Reikalavimai:</p> <p>Sukurkite <code>IntList</code> klas\u0119 su:</p> <ol> <li>Private nariai:</li> <li><code>int duomenys[100]</code> - fiksuoto dyd\u017eio masyvas</li> <li> <p><code>int dydis</code> - dabartinis element\u0173 skai\u010dius</p> </li> <li> <p>Public metodai:</p> </li> <li><code>IntList()</code> - default konstruktorius (inicializuoja <code>dydis = 0</code>)</li> <li><code>void pridetiGala(int reiksme)</code> - prid\u0117ti element\u0105 \u012f pabaig\u0105</li> <li><code>int gautiElementa(int indeksas) const</code> - gauti element\u0105 pagal indeks\u0105</li> <li><code>int gautiDydi() const</code> - gauti dabartin\u012f dyd\u012f</li> <li> <p><code>void spausdinti() const</code> - atspausdinti visus elementus</p> </li> <li> <p>Modulin\u0117 strukt\u016bra:</p> </li> <li><code>IntList.h</code> - klas\u0117s deklaracija</li> <li><code>IntList.cpp</code> - klas\u0117s implementacija</li> <li><code>main.cpp</code> - testavimo programa</li> <li><code>Makefile</code> - kompiliavimo automatizavimas</li> </ol> <p>Testas: <pre><code>IntList sarasas;\nsarasas.pridetiGala(10);\nsarasas.pridetiGala(20);\nsarasas.pridetiGala(30);\nsarasas.spausdinti();  // [10, 20, 30]\n</code></pre></p> <p>Pavyzdys: <pre><code>IntList dydis: 3\nElementai: [10, 20, 30]\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2/#2-zingsnis-dynamic-memory-konstruktoriaidestruktorius","title":"2 \u017eingsnis: Dynamic memory + konstruktoriai/destruktorius","text":"<p>Direktorija: <code>U2/02/</code></p> <p>Reikalavimai:</p> <p>Modifikuokite <code>IntList</code> klas\u0119:</p> <ol> <li>Pakeisti private narius:</li> <li><code>int* duomenys</code> - rodykl\u0117 \u012f dinamin\u012f masyv\u0105 (ne fixed array!)</li> <li><code>int dydis</code> - dabartinis element\u0173 skai\u010dius</li> <li> <p><code>int talpa</code> - i\u0161skirtos atminties talpa</p> </li> <li> <p>Konstruktoriai:</p> </li> <li><code>IntList()</code> - default: talpa = 10, i\u0161skirti atmint\u012f</li> <li><code>IntList(int pradineTalpa)</code> - su parametru: i\u0161skirti nurodyt\u0105 talp\u0105</li> <li> <p>Svarbu: Konstruktoriuje naudoti <code>new int[talpa]</code></p> </li> <li> <p>Destruktorius:</p> </li> <li><code>~IntList()</code> - atlaisvinti atmint\u012f su <code>delete[]</code></li> <li>Logging: I\u0161vesti prane\u0161im\u0105 \u012f <code>cout</code> (debug)</li> <li> <p>Nustatyti rodykl\u0119 <code>nullptr</code> (saugumui)</p> </li> <li> <p>Metodai:</p> </li> <li>I\u0161laikyti visus metodus i\u0161 1 \u017eingsnio</li> <li><code>pridetiGala()</code> - dabar prideda \u012f dinamin\u012f masyv\u0105</li> <li>Patikrinti: <code>if (dydis &gt;= talpa)</code> \u2192 klaida (kol kas be auto-expand)</li> </ol> <p>Logging pavyzdys: <pre><code>~IntList() {\n    cout &lt;&lt; \"[DEBUG] IntList naikinamas (dydis=\" &lt;&lt; dydis \n         &lt;&lt; \", talpa=\" &lt;&lt; talpa &lt;&lt; \")\" &lt;&lt; endl;\n    delete[] duomenys;\n    duomenys = nullptr;\n}\n</code></pre></p> <p>Testas: <pre><code>{\n    IntList sarasas(5);  // Talpa = 5\n    for(int i = 1; i &lt;= 5; i++) {\n        sarasas.pridetiGala(i * 10);\n    }\n    sarasas.spausdinti();\n} // Destruktorius \u010dia i\u0161kvie\u010diamas automati\u0161kai!\n</code></pre></p> <p>Pavyzdys: <pre><code>[DEBUG] IntList sukurtas (talpa=5)\nIntList dydis: 5\nElementai: [10, 20, 30, 40, 50]\n[DEBUG] IntList naikinamas (dydis=5, talpa=5)\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2/#3-zingsnis-automatinis-ispletimas","title":"3 \u017eingsnis: Automatinis i\u0161pl\u0117timas","text":"<p>Direktorija: <code>U2/03/</code></p> <p>Reikalavimai:</p> <p>Prid\u0117kite automatin\u012f atminties i\u0161pl\u0117tim\u0105:</p> <ol> <li>Private metodas:</li> <li><code>void isplesti()</code> - i\u0161ple\u010dia masyvo talp\u0105</li> <li> <p>Algoritmas:      <pre><code>1. Apskai\u010diuoti nauj\u0105 talp\u0105 (pvz., talpa + 5)\n2. I\u0161skirti nauj\u0105 didesn\u012f masyv\u0105\n3. Nukopijuoti senus duomenis\n4. Atlaisvinti sen\u0105 masyv\u0105\n5. Priskirti nauj\u0105 masyv\u0105\n</code></pre></p> </li> <li> <p>Modifikuoti <code>pridetiGala()</code>: <pre><code>void pridetiGala(int reiksme) {\n    if (dydis &gt;= talpa) {\n        isplesti();  // Automatinis i\u0161pl\u0117timas!\n    }\n    duomenys[dydis++] = reiksme;\n}\n</code></pre></p> </li> <li> <p>Logging <code>isplesti()</code> metode: <pre><code>cout &lt;&lt; \"[DEBUG] IntList isplesta (sena talpa=\" &lt;&lt; talpa \n     &lt;&lt; \", nauja talpa=\" &lt;&lt; naujaTalpa &lt;&lt; \")\" &lt;&lt; endl;\n</code></pre></p> </li> </ol> <p>Testas su ma\u017eu <code>talpa</code>: <pre><code>IntList sarasas(3);  // Pradinis talpa = 3\nfor(int i = 1; i &lt;= 10; i++) {\n    sarasas.pridetiGala(i * 10);  // Turi i\u0161sipl\u0117sti!\n}\nsarasas.spausdinti();\n</code></pre></p> <p>Pavyzdys: <pre><code>[DEBUG] IntList sukurtas (talpa=3)\n[DEBUG] IntList isplesta (sena talpa=3, nauja talpa=8)\n[DEBUG] IntList isplesta (sena talpa=8, nauja talpa=13)\nIntList dydis: 10\nElementai: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n[DEBUG] IntList naikinamas (dydis=10, talpa=13)\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/po%20U1/U2/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 U2/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 1 \u017eingsnis (basic class)\n    \u2502   \u251c\u2500\u2500 IntList.h\n    \u2502   \u251c\u2500\u2500 IntList.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 02/                \u2190 2 \u017eingsnis (dynamic memory)\n    \u2502   \u251c\u2500\u2500 IntList.h\n    \u2502   \u251c\u2500\u2500 IntList.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 03/                \u2190 3 \u017eingsnis (auto-expand) - FINAL\n        \u251c\u2500\u2500 IntList.h\n        \u251c\u2500\u2500 IntList.cpp\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/po%20U1/U2/#git-workflow","title":"Git workflow:","text":"<p>Po kiekvieno \u017eingsnio: <pre><code>git add U2/01/\ngit commit -m \"U2: 1 \u017eingsnis - Basic IntList klas\u0117\"\ngit push\n\ngit add U2/02/\ngit commit -m \"U2: 2 \u017eingsnis - Dynamic memory + RAII\"\ngit push\n\ngit add U2/03/\ngit commit -m \"U2: 3 \u017eingsnis - Automatinis i\u0161pl\u0117timas\"\ngit push\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2/#u2readmemd-sablonas","title":"U2/README.md \u0161ablonas:","text":"<p><pre><code># U2: IntList Klas\u0117 ir RAII\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-02-28\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Basic klas\u0117 (fiksuotas masyvas) |\n| 2 | `02/` | Dynamic memory + RAII |\n| 3 | `03/` | Automatinis i\u0161pl\u0117timas |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (be i\u0161pl\u0117timo)**:\n</code></pre> Input: talpa=10, prid\u0117ti 5 elementus Output: [10, 20, 30, 40, 50] \u2705 VEIKIA <pre><code>**Testas 2 (su i\u0161pl\u0117timu)**:\n</code></pre> Input: talpa=3, prid\u0117ti 10 element\u0173 Output: [10, 20, ... 100], automati\u0161kai i\u0161sipl\u0117t\u0117 2 kartus \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. RAII principas - konstruktorius i\u0161skiria, destruktorius atlaisvina\n2. Automatinis i\u0161pl\u0117timas - pana\u0161iai kaip `vector`\n3. Destruktoriaus logging padeda debug'inti\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U2/#moodle-pateikimas","title":"Moodle pateikimas:","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U2_VardasPavarde.zip HEAD U2/ README.md .gitignore\n</code></pre> <p>Detalios instrukcijos: \u017dr. U\u017eduo\u010di\u0173 Gidas</p>"},{"location":"Pratybos/po%20U1/U2/#vertinimo-kriterijai","title":"\u2705 Vertinimo kriterijai","text":"Kriterijus Balai Programa kompiliuojasi be klaid\u0173 15% Basic klas\u0117 (1 \u017eingsnis) veikia 15% Dynamic memory + RAII (2 \u017eingsnis) veikia 30% Automatinis i\u0161pl\u0117timas (3 \u017eingsnis) veikia 20% Destruktoriaus logging 5% Modulin\u0117 strukt\u016bra (<code>.h</code>/<code>.cpp</code>) 5% Git commit'ai po kiekvieno \u017eingsnio 5% README.md su testais 5% TOTAL 100%"},{"location":"Pratybos/po%20U1/U2/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Prad\u0117kite nuo 1 \u017eingsnio - basic klas\u0117 su fiksuotu masyvu</li> <li>Logging yra svarbus - matysite, kada destruktorius kvie\u010diamas</li> <li>Testuokite su ma\u017eu <code>talpa</code> (pvz., 3) - lengviau pamatyti i\u0161pl\u0117tim\u0105</li> <li><code>nullptr</code> po <code>delete[]</code> - gera praktika (safety)</li> <li>I\u0161saugokite sen\u0105 kod\u0105 - naujas \u017eingsnis = nauja direktorija</li> <li>Commit'inkite da\u017enai!</li> </ol>"},{"location":"Pratybos/po%20U1/U2/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ konstruktoriai</li> <li>C++ destruktoriai</li> <li>RAII idioma</li> <li>new/delete operators</li> </ul>"},{"location":"Pratybos/po%20U1/U2/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l <code>delete[]</code> o ne <code>delete</code>? A: <code>delete[]</code> naudojamas masyvams, <code>delete</code> - vienam objektui. Labai svarbu!</p> <p>K: Kod\u0117l reikia <code>nullptr</code> po <code>delete[]</code>? A: Safety - jei atsitiktinai bandysime <code>delete[]</code> dar kart\u0105, nekris programa.</p> <p>K: Kaip testuoti destruktori\u0173? A: Logging (<code>cout</code> destruktoriuje) + scope (<code>{ ... }</code> blokais).</p> <p>K: Kod\u0117l automatinis i\u0161pl\u0117timas reikalingas? A: Tai <code>vector</code> elgsena - dinamin\u0117 talpa. I\u0161 prad\u017ei\u0173 ne\u017einome, kiek element\u0173 bus.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/po%20U1/U3-solution/","title":"U3: Sprendimas - Kompozicija (has-a ry\u0161ys)","text":"<p>D\u0117stytojui: Pilnas sprendimas su kodu ir paai\u0161kinimais.</p>"},{"location":"Pratybos/po%20U1/U3-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U3/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 01/\n\u2502   \u251c\u2500\u2500 Langas.h, Langas.cpp\n\u2502   \u251c\u2500\u2500 Durys.h, Durys.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u251c\u2500\u2500 02/\n\u2502   \u251c\u2500\u2500 Langas.h, Langas.cpp\n\u2502   \u251c\u2500\u2500 Durys.h, Durys.cpp\n\u2502   \u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u2514\u2500\u2500 Makefile\n\u2514\u2500\u2500 03/\n    \u251c\u2500\u2500 Langas.h, Langas.cpp\n    \u251c\u2500\u2500 Durys.h, Durys.cpp\n    \u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n    \u251c\u2500\u2500 skaiciavimai.h, skaiciavimai.cpp\n    \u251c\u2500\u2500 main.cpp\n    \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#1-1-zingsnis-langas-ir-durys-klases","title":"1\ufe0f\u20e3 1 \u017eingsnis: Langas ir Durys klas\u0117s","text":""},{"location":"Pratybos/po%20U1/U3-solution/#langash","title":"Langas.h:","text":"<pre><code>#ifndef LANGAS_H\n#define LANGAS_H\n\nclass Langas {\nprivate:\n    float aukstis;\n    float plotis;\n    static int sukurtaLangu;  // Statinis skaitiklis\n\npublic:\n    // Konstruktorius\n    Langas(float a, float p);\n\n    // Destruktorius\n    ~Langas();\n\n    // Getters\n    float gautiAuksti() const;\n    float gautiPloti() const;\n    float apskaiciuotiPlota() const;\n\n    // Static getter\n    static int gautiSukurtaLangu();\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>static int sukurtaLangu</code> - klas\u0117s lygio (ne objekto!)</li> <li>\u2705 <code>static</code> metodas - gali b\u016bti kvie\u010diamas be objekto: <code>Langas::gautiSukurtaLangu()</code></li> <li>\u26a0\ufe0f Da\u017ena klaida: pamir\u0161ti inicializuoti <code>.cpp</code> faile</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#langascpp","title":"Langas.cpp:","text":"<pre><code>#include \"Langas.h\"\n#include &lt;iostream&gt;\n\n// SVARBU: Statinio nario inicializacija U\u017d klas\u0117s rib\u0173\nint Langas::sukurtaLangu = 0;\n\n// Konstruktorius\nLangas::Langas(float a, float p) : aukstis(a), plotis(p) {\n    sukurtaLangu++;\n    std::cout &lt;&lt; \"[DEBUG] Langas sukurtas (\" &lt;&lt; aukstis &lt;&lt; \"\u00d7\" &lt;&lt; plotis \n              &lt;&lt; \"). Viso langu: \" &lt;&lt; sukurtaLangu &lt;&lt; std::endl;\n}\n\n// Destruktorius\nLangas::~Langas() {\n    sukurtaLangu--;\n    std::cout &lt;&lt; \"[DEBUG] Langas sunaikintas. Liko langu: \" \n              &lt;&lt; sukurtaLangu &lt;&lt; std::endl;\n}\n\n// Getters\nfloat Langas::gautiAuksti() const {\n    return aukstis;\n}\n\nfloat Langas::gautiPloti() const {\n    return plotis;\n}\n\nfloat Langas::apskaiciuotiPlota() const {\n    return aukstis * plotis;\n}\n\n// Static getter\nint Langas::gautiSukurtaLangu() {\n    return sukurtaLangu;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>int Langas::sukurtaLangu = 0;</code> - B\u016aTINA inicializuoti .cpp!</li> <li>\u2705 Initialization list: <code>: aukstis(a), plotis(p)</code> - efektyvesn\u0117 nei assignment</li> <li>\u2705 Logging padeda matyti objekt\u0173 gyvavimo cikl\u0105</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>static int Langas::sukurtaLangu = 0;</code> - ne <code>static</code> .cpp faile!</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#durysh","title":"Durys.h:","text":"<pre><code>#ifndef DURYS_H\n#define DURYS_H\n\nclass Durys {\nprivate:\n    float aukstis;\n    float plotis;\n    static int sukurtaDuriu;\n\npublic:\n    Durys(float a, float p);\n    ~Durys();\n\n    float gautiAuksti() const;\n    float gautiPloti() const;\n    float apskaiciuotiPlota() const;\n\n    static int gautiSukurtaDuriu();\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#duryscpp","title":"Durys.cpp:","text":"<pre><code>#include \"Durys.h\"\n#include &lt;iostream&gt;\n\nint Durys::sukurtaDuriu = 0;\n\nDurys::Durys(float a, float p) : aukstis(a), plotis(p) {\n    sukurtaDuriu++;\n    std::cout &lt;&lt; \"[DEBUG] Durys sukurtos (\" &lt;&lt; aukstis &lt;&lt; \"\u00d7\" &lt;&lt; plotis \n              &lt;&lt; \"). Viso duriu: \" &lt;&lt; sukurtaDuriu &lt;&lt; std::endl;\n}\n\nDurys::~Durys() {\n    sukurtaDuriu--;\n    std::cout &lt;&lt; \"[DEBUG] Durys sunaikintos. Liko duriu: \" \n              &lt;&lt; sukurtaDuriu &lt;&lt; std::endl;\n}\n\nfloat Durys::gautiAuksti() const {\n    return aukstis;\n}\n\nfloat Durys::gautiPloti() const {\n    return plotis;\n}\n\nfloat Durys::apskaiciuotiPlota() const {\n    return aukstis * plotis;\n}\n\nint Durys::gautiSukurtaDuriu() {\n    return sukurtaDuriu;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#maincpp-1-zingsnis","title":"main.cpp (1 \u017eingsnis):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U3 \u017dingsnis 1: Langas ir Durys ===\\n\" &lt;&lt; endl;\n\n    // Testas 1: Static counter prad\u017eioje\n    cout &lt;&lt; \"--- Prad\u017eioje ---\" &lt;&lt; endl;\n    cout &lt;&lt; \"Langu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;\n    cout &lt;&lt; \"Duriu: \" &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // Testas 2: Sukurti langus\n    cout &lt;&lt; \"\\n--- Sukuriame 3 langus ---\" &lt;&lt; endl;\n    Langas l1(1.5, 1.0);\n    Langas l2(2.0, 1.5);\n    Langas l3(1.8, 1.2);\n\n    cout &lt;&lt; \"\\nLangu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;\n\n    // Testas 3: Langu plotai\n    cout &lt;&lt; \"\\n--- Langu plotai ---\" &lt;&lt; endl;\n    cout &lt;&lt; \"L1 plotas: \" &lt;&lt; l1.apskaiciuotiPlota() &lt;&lt; \" m\u00b2\" &lt;&lt; endl;\n    cout &lt;&lt; \"L2 plotas: \" &lt;&lt; l2.apskaiciuotiPlota() &lt;&lt; \" m\u00b2\" &lt;&lt; endl;\n    cout &lt;&lt; \"L3 plotas: \" &lt;&lt; l3.apskaiciuotiPlota() &lt;&lt; \" m\u00b2\" &lt;&lt; endl;\n\n    // Testas 4: Sukurti duris\n    cout &lt;&lt; \"\\n--- Sukuriame 2 duris ---\" &lt;&lt; endl;\n    Durys d1(2.0, 0.9);\n    Durys d2(2.1, 0.8);\n\n    cout &lt;&lt; \"\\nDuriu: \" &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // Testas 5: Scope test\n    cout &lt;&lt; \"\\n--- Scope testas (objektai sunaikinti scope pabaigoje) ---\" &lt;&lt; endl;\n    {\n        Langas temp(1.0, 1.0);\n        cout &lt;&lt; \"Scope viduje, langu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;\n    } // temp destruktorius \u010dia!\n    cout &lt;&lt; \"Po scope, langu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n=== Programa baigia darba (visi objektai bus sunaikinti) ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>=== U3 \u017dingsnis 1: Langas ir Durys ===\n\n--- Prad\u017eioje ---\nLangu: 0\nDuriu: 0\n\n--- Sukuriame 3 langus ---\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n[DEBUG] Langas sukurtas (2\u00d71.5). Viso langu: 2\n[DEBUG] Langas sukurtas (1.8\u00d71.2). Viso langu: 3\n\nLangu: 3\n\n--- Langu plotai ---\nL1 plotas: 1.5 m\u00b2\nL2 plotas: 3 m\u00b2\nL3 plotas: 2.16 m\u00b2\n\n--- Sukuriame 2 duris ---\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 1\n[DEBUG] Durys sukurtos (2.1\u00d70.8). Viso duriu: 2\n\nDuriu: 2\n\n--- Scope testas (objektai sunaikinti scope pabaigoje) ---\n[DEBUG] Langas sukurtas (1\u00d71). Viso langu: 4\nScope viduje, langu: 4\n[DEBUG] Langas sunaikintas. Liko langu: 3\nPo scope, langu: 3\n\n=== Programa baigia darba (visi objektai bus sunaikinti) ===\n[DEBUG] Durys sunaikintos. Liko duriu: 1\n[DEBUG] Durys sunaikintos. Liko duriu: 0\n[DEBUG] Langas sunaikintas. Liko langu: 2\n[DEBUG] Langas sunaikintas. Liko langu: 1\n[DEBUG] Langas sunaikintas. Liko langu: 0\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3-solution/#makefile","title":"Makefile:","text":"<pre><code>CXX = g++\nCXXFLAGS = -Wall -std=c++11\n\nOBJS = main.o Langas.o Durys.o\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\nmain.o: main.cpp Langas.h Durys.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nLangas.o: Langas.cpp Langas.h\n    $(CXX) $(CXXFLAGS) -c Langas.cpp\n\nDurys.o: Durys.cpp Durys.h\n    $(CXX) $(CXXFLAGS) -c Durys.cpp\n\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#2-2-zingsnis-kambarys-klase-kompozicija","title":"2\ufe0f\u20e3 2 \u017eingsnis: Kambarys klas\u0117 (kompozicija)","text":""},{"location":"Pratybos/po%20U1/U3-solution/#kambarysh","title":"Kambarys.h:","text":"<pre><code>#ifndef KAMBARYS_H\n#define KAMBARYS_H\n\n#include &lt;vector&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nclass Kambarys {\nprivate:\n    float ilgis;\n    float plotis;\n    float aukstis;\n\n    std::vector&lt;Langas&gt; langai;  // Value semantics (kopijos)\n    Durys* durys;                // Pointer semantics (dalijimasis)\n\npublic:\n    // Konstruktorius\n    Kambarys(float i, float p, float a);\n\n    // Destruktorius\n    ~Kambarys();\n\n    // Metodai\n    void pridetiLanga(const Langas&amp; langas);\n    void nustatytiDuris(Durys* d);\n\n    // Getters\n    float gautiIlgi() const;\n    float gautiPloti() const;\n    float gautiAuksti() const;\n    int gautiLanguKieki() const;\n    bool arTuriDuris() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>#include &lt;vector&gt;</code> - STL konteineris</li> <li>\u2705 <code>vector&lt;Langas&gt;</code> - saugo kopijas (value semantics)</li> <li>\u2705 <code>Durys*</code> - saugo rodykl\u0119 (pointer semantics)</li> <li>\ud83d\udca1 Kompozicija: Kambarys turi (owns) langus ir duris</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#kambaryscpp","title":"Kambarys.cpp:","text":"<pre><code>#include \"Kambarys.h\"\n#include &lt;iostream&gt;\n\n// Konstruktorius\nKambarys::Kambarys(float i, float p, float a) \n    : ilgis(i), plotis(p), aukstis(a), durys(nullptr) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sukurtas (\" &lt;&lt; ilgis &lt;&lt; \"\u00d7\" \n              &lt;&lt; plotis &lt;&lt; \"\u00d7\" &lt;&lt; aukstis &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n\n// Destruktorius\nKambarys::~Kambarys() {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys naikinamas\" &lt;&lt; std::endl;\n\n    // Sunaikinti duris (jei yra)\n    if (durys != nullptr) {\n        std::cout &lt;&lt; \"[DEBUG] Kambarys naikina savo duris\" &lt;&lt; std::endl;\n        delete durys;\n        durys = nullptr;\n    }\n\n    // I\u0161valyti lang\u0173 vektori\u0173 (ne b\u016btina, bet gera praktika)\n    langai.clear();\n\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sunaikintas\" &lt;&lt; std::endl;\n}\n\n// Prid\u0117ti lang\u0105\nvoid Kambarys::pridetiLanga(const Langas&amp; langas) {\n    langai.push_back(langas);  // KOPIJUOJA objekt\u0105 \u012f vektori\u0173\n    std::cout &lt;&lt; \"[DEBUG] Kambarys pridejo langa. Viso langu: \" \n              &lt;&lt; langai.size() &lt;&lt; std::endl;\n}\n\n// Nustatyti duris\nvoid Kambarys::nustatytiDuris(Durys* d) {\n    durys = d;  // Tik priskiria rodykl\u0119 (NE kopija!)\n    std::cout &lt;&lt; \"[DEBUG] Kambarys gavo duris\" &lt;&lt; std::endl;\n}\n\n// Getters\nfloat Kambarys::gautiIlgi() const {\n    return ilgis;\n}\n\nfloat Kambarys::gautiPloti() const {\n    return plotis;\n}\n\nfloat Kambarys::gautiAuksti() const {\n    return aukstis;\n}\n\nint Kambarys::gautiLanguKieki() const {\n    return langai.size();\n}\n\nbool Kambarys::arTuriDuris() const {\n    return durys != nullptr;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>durys(nullptr)</code> - initialization list (saugus pradinis b\u016bsenos)</li> <li>\u2705 <code>langai.push_back(langas)</code> - KOPIJUOJA (value semantics)</li> <li>\u2705 <code>durys = d</code> - tik priskiria rodykl\u0119 (pointer semantics)</li> <li>\u2705 Destruktorius patikrina <code>if (durys != nullptr)</code> prie\u0161 <code>delete</code></li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>delete langai</code> - BLOGAI! Vector destruktorius automati\u0161kai</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#maincpp-2-zingsnis","title":"main.cpp (2 \u017eingsnis):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n#include \"Kambarys.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U3 \u017dingsnis 2: Kambarys (kompozicija) ===\\n\" &lt;&lt; endl;\n\n    // Testas 1: Sukurti langus (lokal\u016bs objektai)\n    cout &lt;&lt; \"--- Sukuriame langus ---\" &lt;&lt; endl;\n    Langas l1(1.5, 1.0);\n    Langas l2(1.5, 1.0);\n    Langas l3(2.0, 1.5);\n\n    // Testas 2: Sukurti duris (dinami\u0161kai)\n    cout &lt;&lt; \"\\n--- Sukuriame duris (dynamic) ---\" &lt;&lt; endl;\n    Durys* d1 = new Durys(2.0, 0.9);\n\n    // Testas 3: Sukurti kambar\u012f\n    cout &lt;&lt; \"\\n--- Sukuriame kambari ---\" &lt;&lt; endl;\n    Kambarys kambarys(5.0, 4.0, 3.0);\n\n    // Testas 4: Prid\u0117ti langus\n    cout &lt;&lt; \"\\n--- Pridedame langus (kopijuoja!) ---\" &lt;&lt; endl;\n    kambarys.pridetiLanga(l1);\n    kambarys.pridetiLanga(l2);\n    kambarys.pridetiLanga(l3);\n\n    cout &lt;&lt; \"\\nStatistika:\" &lt;&lt; endl;\n    cout &lt;&lt; \"  Kambaryje langu: \" &lt;&lt; kambarys.gautiLanguKieki() &lt;&lt; endl;\n    cout &lt;&lt; \"  Viso langu sistemoje: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;\n\n    // Testas 5: Nustatyti duris\n    cout &lt;&lt; \"\\n--- Nustatome duris (pointer!) ---\" &lt;&lt; endl;\n    kambarys.nustatytiDuris(d1);\n\n    // Testas 6: Kambario info\n    cout &lt;&lt; \"\\n--- Kambario informacija ---\" &lt;&lt; endl;\n    cout &lt;&lt; \"Matmenys: \" &lt;&lt; kambarys.gautiIlgi() &lt;&lt; \" \u00d7 \" \n         &lt;&lt; kambarys.gautiPloti() &lt;&lt; \" \u00d7 \" \n         &lt;&lt; kambarys.gautiAuksti() &lt;&lt; \" m\" &lt;&lt; endl;\n    cout &lt;&lt; \"Langu: \" &lt;&lt; kambarys.gautiLanguKieki() &lt;&lt; endl;\n    cout &lt;&lt; \"Turi duris: \" &lt;&lt; (kambarys.arTuriDuris() ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n=== Programa baigia darba ===\" &lt;&lt; endl;\n    cout &lt;&lt; \"PASTABA: Kambarys destruktorius sunaikins duris!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>=== U3 \u017dingsnis 2: Kambarys (kompozicija) ===\n\n--- Sukuriame langus ---\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 2\n[DEBUG] Langas sukurtas (2\u00d71.5). Viso langu: 3\n\n--- Sukuriame duris (dynamic) ---\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 1\n\n--- Sukuriame kambari ---\n[DEBUG] Kambarys sukurtas (5\u00d74\u00d73)\n\n--- Pridedame langus (kopijuoja!) ---\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 4  \u2190 Kopija!\n[DEBUG] Kambarys pridejo langa. Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 5  \u2190 Kopija!\n[DEBUG] Kambarys pridejo langa. Viso langu: 2\n[DEBUG] Langas sukurtas (2\u00d71.5). Viso langu: 6  \u2190 Kopija!\n[DEBUG] Kambarys pridejo langa. Viso langu: 3\n\nStatistika:\n  Kambaryje langu: 3\n  Viso langu sistemoje: 6  \u2190 3 originalai + 3 kopijos!\n\n--- Nustatome duris (pointer!) ---\n[DEBUG] Kambarys gavo duris\n\n--- Kambario informacija ---\nMatmenys: 5 \u00d7 4 \u00d7 3 m\nLangu: 3\nTuri duris: Taip\n\n=== Programa baigia darba ===\nPASTABA: Kambarys destruktorius sunaikins duris!\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 0\n[DEBUG] Langas sunaikintas. Liko langu: 5  \u2190 Vector destruktorius\n[DEBUG] Langas sunaikintas. Liko langu: 4\n[DEBUG] Langas sunaikintas. Liko langu: 3\n[DEBUG] Kambarys sunaikintas\n[DEBUG] Langas sunaikintas. Liko langu: 2  \u2190 Originalai\n[DEBUG] Langas sunaikintas. Liko langu: 1\n[DEBUG] Langas sunaikintas. Liko langu: 0\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\ud83d\udca1 6 langai viso = 3 originalai + 3 kopijos vektoriuje!</li> <li>\ud83d\udca1 Vector destruktorius automati\u0161kai sunaikina kopijas</li> <li>\ud83d\udca1 Kambarys destruktorius sunaikina duris (pointer semantics)</li> <li>\u26a0\ufe0f Double-free bug jei studentas bandys <code>delete d1</code> main'e!</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#3-3-zingsnis-skaiciavimai-globalios-funkcijos","title":"3\ufe0f\u20e3 3 \u017eingsnis: Skai\u010diavimai (globalios funkcijos)","text":""},{"location":"Pratybos/po%20U1/U3-solution/#skaiciavimaih","title":"skaiciavimai.h:","text":"<pre><code>#ifndef SKAICIAVIMAI_H\n#define SKAICIAVIMAI_H\n\n#include \"Kambarys.h\"\n\n// Globalios funkcijos (ne metodai!)\nfloat apskaiciuotiSienuPlota(const Kambarys&amp; k);\nfloat apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#skaiciavimaicpp","title":"skaiciavimai.cpp:","text":"<pre><code>#include \"skaiciavimai.h\"\n#include &lt;iostream&gt;\n\n// Sien\u0173 ploto skai\u010diavimas\nfloat apskaiciuotiSienuPlota(const Kambarys&amp; k) {\n    // 1. Perimetras\n    float perimetras = 2 * (k.gautiIlgi() + k.gautiPloti());\n\n    // 2. Sien\u0173 plotas (be lang\u0173 ir dur\u0173)\n    float sienuPlotas = perimetras * k.gautiAuksti();\n\n    // 3. Atimti lang\u0173 plotus\n    // PASTABA: Reikia prieigos prie lang\u0173 - problemos!\n    // Sprendimas: prid\u0117ti Kambarys metod\u0105, kuris gr\u0105\u017eina lang\u0173 plot\u0173 sum\u0105\n\n    // Supaprastinta versija (be lang\u0173/dur\u0173 atskaitym\u0173)\n    std::cout &lt;&lt; \"[DEBUG] Sienu plotas (gross): \" &lt;&lt; sienuPlotas &lt;&lt; \" m\u00b2\" &lt;&lt; std::endl;\n\n    return sienuPlotas;\n}\n\n// Grindjuos\u010di\u0173 ilgio skai\u010diavimas\nfloat apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k) {\n    // Perimetras minus dur\u0173 plotis\n    float perimetras = 2 * (k.gautiIlgi() + k.gautiPloti());\n\n    // PASTABA: Reikia prieigos prie dur\u0173 plo\u010dio\n    // Supaprastinta versija\n    std::cout &lt;&lt; \"[DEBUG] Grindjusciu ilgis (full perimeter): \" \n              &lt;&lt; perimetras &lt;&lt; \" m\" &lt;&lt; std::endl;\n\n    return perimetras;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos-problema","title":"Pedagogin\u0117s pastabos - PROBLEMA!","text":"<p>Globalios funkcijos neturi prieigos prie <code>private</code> nari\u0173 (<code>langai</code>, <code>durys</code>)!</p> <p>Sprendimo b\u016bdai:</p> <p>1. Friend funkcijos (rekomenduojama \u0161iai u\u017eduo\u010diai): <pre><code>// Kambarys.h\nclass Kambarys {\n    // ...\n    friend float apskaiciuotiSienuPlota(const Kambarys&amp; k);\n    friend float apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n};\n</code></pre></p> <p>2. Public getter'iai: <pre><code>// Kambarys.h\nconst std::vector&lt;Langas&gt;&amp; gautiLangus() const;\nconst Durys* gautiDuris() const;\n</code></pre></p> <p>Naudosime friend (pirm\u0105 b\u016bd\u0105) - tai mokymo tikslais gerai!</p>"},{"location":"Pratybos/po%20U1/U3-solution/#kambarysh-atnaujintas-su-friend","title":"Kambarys.h (atnaujintas su friend):","text":"<pre><code>#ifndef KAMBARYS_H\n#define KAMBARYS_H\n\n#include &lt;vector&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nclass Kambarys {\nprivate:\n    float ilgis;\n    float plotis;\n    float aukstis;\n\n    std::vector&lt;Langas&gt; langai;\n    Durys* durys;\n\npublic:\n    Kambarys(float i, float p, float a);\n    ~Kambarys();\n\n    void pridetiLanga(const Langas&amp; langas);\n    void nustatytiDuris(Durys* d);\n\n    float gautiIlgi() const;\n    float gautiPloti() const;\n    float gautiAuksti() const;\n    int gautiLanguKieki() const;\n    bool arTuriDuris() const;\n\n    // Friend funkcijos (turi prieig\u0105 prie private!)\n    friend float apskaiciuotiSienuPlota(const Kambarys&amp; k);\n    friend float apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#skaiciavimaicpp-galutine-versija","title":"skaiciavimai.cpp (galutin\u0117 versija):","text":"<pre><code>#include \"skaiciavimai.h\"\n#include &lt;iostream&gt;\n\n// Sien\u0173 ploto skai\u010diavimas\nfloat apskaiciuotiSienuPlota(const Kambarys&amp; k) {\n    // 1. Perimetras\n    float perimetras = 2 * (k.ilgis + k.plotis);\n\n    // 2. Bruto sien\u0173 plotas\n    float sienuPlotas = perimetras * k.aukstis;\n\n    // 3. Atimti lang\u0173 plotus\n    for (int i = 0; i &lt; k.langai.size(); i++) {\n        sienuPlotas -= k.langai[i].apskaiciuotiPlota();\n    }\n\n    // 4. Atimti dur\u0173 plot\u0105\n    if (k.durys != nullptr) {\n        sienuPlotas -= k.durys-&gt;apskaiciuotiPlota();\n    }\n\n    return sienuPlotas;\n}\n\n// Grindjuos\u010di\u0173 ilgio skai\u010diavimas\nfloat apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k) {\n    float perimetras = 2 * (k.ilgis + k.plotis);\n\n    // Atimti dur\u0173 plot\u012f\n    if (k.durys != nullptr) {\n        perimetras -= k.durys-&gt;gautiPloti();\n    }\n\n    return perimetras;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-pastabos_5","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>friend</code> leid\u017eia prieig\u0105 prie <code>private</code> nari\u0173</li> <li>\u2705 Globalios funkcijos u\u017e klas\u0117s rib\u0173</li> <li>\u2705 <code>const Kambarys&amp;</code> - efektyvu (ne kopija)</li> <li>\ud83d\udca1 Diskusija: Ar <code>friend</code> - gera praktika? (encapsulation trade-off)</li> </ul>"},{"location":"Pratybos/po%20U1/U3-solution/#maincpp-galutinis-testas","title":"main.cpp (galutinis testas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n#include \"Kambarys.h\"\n#include \"skaiciavimai.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U3 \u017dingsnis 3: Skai\u010diavimai (globalios) ===\\n\" &lt;&lt; endl;\n\n    // Sukurti kambar\u012f\n    cout &lt;&lt; \"--- Kuriame kambari 5\u00d74\u00d73 m ---\" &lt;&lt; endl;\n    Kambarys kambarys(5.0, 4.0, 3.0);\n\n    // Prid\u0117ti 2 langus\n    cout &lt;&lt; \"\\n--- Pridedame 2 langus (1.5\u00d71.0 m kiekvienas) ---\" &lt;&lt; endl;\n    Langas l1(1.5, 1.0);\n    Langas l2(1.5, 1.0);\n    kambarys.pridetiLanga(l1);\n    kambarys.pridetiLanga(l2);\n\n    // Prid\u0117ti duris\n    cout &lt;&lt; \"\\n--- Pridedame duris (2.0\u00d70.9 m) ---\" &lt;&lt; endl;\n    Durys* durys = new Durys(2.0, 0.9);\n    kambarys.nustatytiDuris(durys);\n\n    // Skai\u010diavimai\n    cout &lt;&lt; \"\\n--- SKAI\u010cIAVIMAI ---\" &lt;&lt; endl;\n    float sienuPlotas = apskaiciuotiSienuPlota(kambarys);\n    float grindjusces = apskaiciuotiGrindjuscesIlgi(kambarys);\n\n    cout &lt;&lt; fixed;\n    cout.precision(2);\n    cout &lt;&lt; \"\\nRezultatai:\" &lt;&lt; endl;\n    cout &lt;&lt; \"  Sienu plotas (neto): \" &lt;&lt; sienuPlotas &lt;&lt; \" m\u00b2\" &lt;&lt; endl;\n    cout &lt;&lt; \"  Grindjusciu ilgis: \" &lt;&lt; grindjusces &lt;&lt; \" m\" &lt;&lt; endl;\n\n    // Patikrinkite rankiniu b\u016bdu:\n    // Perimetras = 2*(5+4) = 18 m\n    // Bruto sienos = 18*3 = 54 m\u00b2\n    // Lang\u0173 plotai = 2*(1.5*1.0) = 3 m\u00b2\n    // Dur\u0173 plotas = 2.0*0.9 = 1.8 m\u00b2\n    // Neto sienos = 54 - 3 - 1.8 = 49.2 m\u00b2\n    // Grindjuos\u010di\u0173 = 18 - 0.9 = 17.1 m\n\n    cout &lt;&lt; \"\\n=== Programa baigia darba ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>=== U3 \u017dingsnis 3: Skai\u010diavimai (globalios) ===\n\n--- Kuriame kambari 5\u00d74\u00d73 m ---\n[DEBUG] Kambarys sukurtas (5\u00d74\u00d73)\n\n--- Pridedame 2 langus (1.5\u00d71.0 m kiekvienas) ---\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 2\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 3\n[DEBUG] Kambarys pridejo langa. Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 4\n[DEBUG] Kambarys pridejo langa. Viso langu: 2\n\n--- Pridedame duris (2.0\u00d70.9 m) ---\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 1\n[DEBUG] Kambarys gavo duris\n\n--- SKAI\u010cIAVIMAI ---\n\nRezultatai:\n  Sienu plotas (neto): 49.20 m\u00b2\n  Grindjusciu ilgis: 17.10 m\n\n=== Programa baigia darba ===\n...\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3-solution/#makefile-galutinis","title":"Makefile (galutinis):","text":"<pre><code>CXX = g++\nCXXFLAGS = -Wall -std=c++11\n\nOBJS = main.o Langas.o Durys.o Kambarys.o skaiciavimai.o\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\nmain.o: main.cpp Langas.h Durys.h Kambarys.h skaiciavimai.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nLangas.o: Langas.cpp Langas.h\n    $(CXX) $(CXXFLAGS) -c Langas.cpp\n\nDurys.o: Durys.cpp Durys.h\n    $(CXX) $(CXXFLAGS) -c Durys.cpp\n\nKambarys.o: Kambarys.cpp Kambarys.h Langas.h Durys.h\n    $(CXX) $(CXXFLAGS) -c Kambarys.cpp\n\nskaiciavimai.o: skaiciavimai.cpp skaiciavimai.h Kambarys.h\n    $(CXX) $(CXXFLAGS) -c skaiciavimai.cpp\n\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/po%20U1/U3-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/po%20U1/U3-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas Pamir\u0161o statini\u0173 nari\u0173 inicializacij\u0105 .cpp \u2b50\u2b50\u2b50\u2b50\u2b50 Linker error: \"undefined reference\" <code>delete d1</code> main'e po kambarys destruktoriaus \u2b50\u2b50\u2b50\u2b50 Double-free! Segfault Globalios f-jos be <code>friend</code> \u2b50\u2b50\u2b50\u2b50 Compiler error: \"private\" <code>static</code> .cpp faile \u2b50\u2b50\u2b50 Compiler error <code>delete langai</code> destruktoriuje \u2b50\u2b50 Compiler error (ne pointer) Vector vs pointer painiava \u2b50\u2b50 Conceptual - paai\u0161kinti"},{"location":"Pratybos/po%20U1/U3-solution/#diskusijos-taskai","title":"Diskusijos ta\u0161kai:","text":"<ol> <li>Value vs Pointer semantics:</li> <li>Vector kopijuoja \u2192 6 langai viso (3 originalai + 3 kopijos)</li> <li>Pointer dalijasi \u2192 1 durys objektas</li> <li> <p>Trade-off: memory vs flexibility</p> </li> <li> <p>Static members:</p> </li> <li>Klas\u0117s lygio duomenys (ne objekto!)</li> <li>Shared across all instances</li> <li> <p>Inicializacija .cpp faile (ne .h!)</p> </li> <li> <p>Friend funkcijos:</p> </li> <li>Breaks encapsulation (trade-off!)</li> <li>Alternatyva: public getters</li> <li> <p>Diskusija: kada naudoti?</p> </li> <li> <p>Destruktori\u0173 tvarka:</p> </li> <li>Kambarys \u2192 durys (explicit delete)</li> <li>Kambarys \u2192 langai (vector automatic)</li> <li>Lokal\u016bs objektai (LIFO)</li> </ol>"},{"location":"Pratybos/po%20U1/U3-solution/#prapletimai-stipriesiems","title":"Prapl\u0117timai stipriesiems:","text":"<ol> <li> <p>Getter'iai vietoj friend: <pre><code>const vector&lt;Langas&gt;&amp; gautiLangus() const { return langai; }\nconst Durys* gautiDuris() const { return durys; }\n</code></pre></p> </li> <li> <p>Smart pointers vietoj raw: <pre><code>std::unique_ptr&lt;Durys&gt; durys;\n</code></pre></p> </li> <li> <p>Iteratoriai lang\u0173 vektoriuje: <pre><code>for(auto it = k.langai.begin(); it != k.langai.end(); ++it) { ... }\n</code></pre></p> </li> <li> <p>Konstitucin\u0117s funkcijos Kambarys: <pre><code>float apskaiciuotiGrinduPlota() const;\nfloat apskaiciuotiTuri() const;\n</code></pre></p> </li> </ol> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/po%20U1/U3/","title":"U3: Kompozicija (has-a ry\u0161ys)","text":"<p>Savait\u0117s: 5-6 Svoris: 1 balas Terminas: Savait\u0117s 6 pabaiga</p>"},{"location":"Pratybos/po%20U1/U3/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1-U2. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas</p>"},{"location":"Pratybos/po%20U1/U3/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti kurti sud\u0117tingesnes klases su kompozicija (has-a ry\u0161ys). Suprasti, kaip objektai gali tur\u0117ti kitus objektus. Praktikuoti statinius narius ir globalias funkcijas.</p>"},{"location":"Pratybos/po%20U1/U3/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Kurti klases, kurios \"turi\" kitas klases (kompozicija)</li> <li>\u2705 Dirbti su <code>vector&lt;Objektas&gt;</code> (objekt\u0173 kolekcija)</li> <li>\u2705 Dirbti su rodykl\u0117mis \u012f objektus (<code>Objektas*</code>)</li> <li>\u2705 Naudoti statinius narius (klas\u0117s lygio duomenys)</li> <li>\u2705 Kurti globalias funkcijas (ne metodus)</li> <li>\u2705 Suprasti kompozicijos vs agregacijos skirtumus</li> </ul>"},{"location":"Pratybos/po%20U1/U3/#kas-yra-kompozicija","title":"\ud83d\udca1 Kas yra kompozicija?","text":"<p>Kompozicija - tai santykis, kai vienas objektas turi (contains) kit\u0105 objekt\u0105.</p> <p>Pavyzdys: - \ud83c\udfe0 Kambarys HAS Lang\u0105 (has-a) - \ud83c\udfe0 Kambarys HAS Duris (has-a)</p> <p>Skirtumas nuo paveld\u0117jimo: - Paveld\u0117jimas: <code>Automobilis</code> IS-A <code>Transportas</code> (U6 tema) - Kompozicija: <code>Automobilis</code> HAS-A <code>Varikl\u012f</code> (\u0161i tema!)</p> <p>Realaus pasaulio analogija: <pre><code>Kambarys (container)\n  \u251c\u2500 Langai (components - value semantics)\n  \u2502   \u251c\u2500 Langas 1\n  \u2502   \u251c\u2500 Langas 2\n  \u2502   \u2514\u2500 ...\n  \u2514\u2500 Durys (component - pointer semantics)\n      \u2514\u2500 Durys*\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/po%20U1/U3/#1-zingsnis-langas-ir-durys-klases","title":"1 \u017eingsnis: Langas ir Durys klas\u0117s","text":"<p>Direktorija: <code>U3/01/</code></p> <p>Reikalavimai:</p> <p>Sukurkite 2 paprastas klases:</p>"},{"location":"Pratybos/po%20U1/U3/#langas-klase","title":"Langas klas\u0117:","text":"<p>Private nariai: - <code>float aukstis</code> - lango auk\u0161tis (metrais) - <code>float plotis</code> - lango plotis (metrais) - <code>static int sukurtaLangu</code> - statinis skaitiklis (kiek lang\u0173 sukurta)</p> <p>Public metodai: - <code>Langas(float a, float p)</code> - konstruktorius   - Inicializuoja <code>aukstis</code>, <code>plotis</code>   - Padidina <code>sukurtaLangu++</code>   - Logging: <code>[DEBUG] Langas sukurtas...</code> - <code>~Langas()</code> - destruktorius   - Suma\u017eina <code>sukurtaLangu--</code>   - Logging: <code>[DEBUG] Langas sunaikintas...</code> - <code>float gautiAuksti() const</code> - getter - <code>float gautiPloti() const</code> - getter - <code>float apskaiciuotiPlota() const</code> - auk\u0161tis \u00d7 plotis - <code>static int gautiSukurtaLangu()</code> - static getter</p>"},{"location":"Pratybos/po%20U1/U3/#durys-klase","title":"Durys klas\u0117:","text":"<p>Analogi\u0161kai kaip <code>Langas</code>: - Private: <code>aukstis</code>, <code>plotis</code>, <code>static int sukurtaDuriu</code> - Public: konstruktorius, destruktorius, getters, <code>apskaiciuotiPlota()</code>, static getter</p> <p>SVARBU - Statiniai nariai:</p> <p>Statiniai nariai priskiriami u\u017e klas\u0117s rib\u0173 <code>.cpp</code> faile:</p> <pre><code>// Langas.cpp\nint Langas::sukurtaLangu = 0;  // Inicializacija\n</code></pre> <p>Testas: <pre><code>cout &lt;&lt; \"Langu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;  // 0\n\nLangas l1(1.5, 1.0);\nLangas l2(2.0, 1.2);\n\ncout &lt;&lt; \"Langu: \" &lt;&lt; Langas::gautiSukurtaLangu() &lt;&lt; endl;  // 2\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U3/01/\n\u251c\u2500\u2500 Langas.h\n\u251c\u2500\u2500 Langas.cpp\n\u251c\u2500\u2500 Durys.h\n\u251c\u2500\u2500 Durys.cpp\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3/#2-zingsnis-kambarys-klase-kompozicija","title":"2 \u017eingsnis: Kambarys klas\u0117 (kompozicija)","text":"<p>Direktorija: <code>U3/02/</code></p> <p>Reikalavimai:</p> <p>Sukurkite Kambarys klas\u0119, kuri turi langus ir duris:</p>"},{"location":"Pratybos/po%20U1/U3/#kambarys-klase","title":"Kambarys klas\u0117:","text":"<p>Private nariai: - <code>float ilgis</code> - kambario ilgis (m) - <code>float plotis</code> - kambario plotis (m) - <code>float aukstis</code> - kambario auk\u0161tis (m) - <code>vector&lt;Langas&gt; langai</code> - kolekcija lang\u0173 (value semantics) - <code>Durys* durys</code> - rodykl\u0117 \u012f duris (pointer semantics)</p> <p>Public metodai: - <code>Kambarys(float i, float p, float a)</code> - konstruktorius   - Inicializuoja matmenis   - <code>durys = nullptr</code> (prad\u017eioje n\u0117ra dur\u0173) - <code>~Kambarys()</code> - destruktorius   - <code>delete durys</code> (jei <code>durys != nullptr</code>)   - <code>durys = nullptr</code>   - <code>langai.clear()</code> (nors vektorius ir taip nusivals) - <code>void pridetiLanga(const Langas&amp; langas)</code> - prid\u0117ti lang\u0105   - <code>langai.push_back(langas)</code> - kopijuoja \u012f vektori\u0173 - <code>void nustatytiDuris(Durys* d)</code> - nustatyti duris   - <code>durys = d</code> - Getters: <code>gautiIlgi()</code>, <code>gautiPloti()</code>, <code>gautiAuksti()</code></p> <p>Kompozicijos skirtumas: - Langai saugomi value (<code>vector&lt;Langas&gt;</code>) - kopijavimas - Durys saugomos pointer (<code>Durys*</code>) - dalijimasis nuoroda</p> <p>Testas: <pre><code>// Sukurti langus (lokal\u016bs objektai)\nLangas l1(1.5, 1.0);\nLangas l2(1.5, 1.0);\n\n// Sukurti duris (dynamic)\nDurys* d1 = new Durys(2.0, 0.9);\n\n// Sukurti kambar\u012f\nKambarys kambarys(5.0, 4.0, 3.0);\nkambarys.pridetiLanga(l1);  // Kopijuoja \u012f vektori\u0173\nkambarys.pridetiLanga(l2);\nkambarys.nustatytiDuris(d1);  // Priskiria rodykl\u0119\n\ncout &lt;&lt; \"Kambarys: \" &lt;&lt; kambarys.gautiIlgi() &lt;&lt; \"\u00d7\" \n     &lt;&lt; kambarys.gautiPloti() &lt;&lt; \"\u00d7\" \n     &lt;&lt; kambarys.gautiAuksti() &lt;&lt; endl;\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U3/02/\n\u251c\u2500\u2500 Langas.h, Langas.cpp\n\u251c\u2500\u2500 Durys.h, Durys.cpp\n\u251c\u2500\u2500 Kambarys.h       \u2190 NAUJAS\n\u251c\u2500\u2500 Kambarys.cpp     \u2190 NAUJAS\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3/#3-zingsnis-skaiciavimai-globalios-funkcijos-logging","title":"3 \u017eingsnis: Skai\u010diavimai (globalios funkcijos) + logging","text":"<p>Direktorija: <code>U3/03/</code></p> <p>Reikalavimai:</p> <p>Prid\u0117kite skai\u010diavimus ir i\u0161sam\u0173 logging:</p>"},{"location":"Pratybos/po%20U1/U3/#globalios-funkcijos","title":"Globalios funkcijos:","text":"<p>Sukurkite atskir\u0105 fail\u0105 <code>skaiciavimai.h</code> / <code>skaiciavimai.cpp</code>:</p> <p>1. Sien\u0173 ploto skai\u010diavimas: <pre><code>float apskaiciuotiSienuPlota(const Kambarys&amp; k);\n</code></pre></p> <p>Algoritmas: <pre><code>1. Perimetras = 2 \u00d7 (ilgis + plotis)\n2. Sien\u0173 plotas = perimetras \u00d7 auk\u0161tis\n3. Atimti vis\u0173 lang\u0173 plotus\n4. Atimti dur\u0173 plot\u0105\n5. Gr\u0105\u017einti rezultat\u0105\n</code></pre></p> <p>2. Grindjuos\u010di\u0173 ilgio skai\u010diavimas: <pre><code>float apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n</code></pre></p> <p>Algoritmas: <pre><code>1. Perimetras = 2 \u00d7 (ilgis + plotis)\n2. Atimti dur\u0173 plot\u012f\n3. Gr\u0105\u017einti rezultat\u0105\n</code></pre></p> <p>SVARBU: \u0160ios funkcijos ne metodai - jos globalios (u\u017e klas\u0117s rib\u0173).</p> <p>Kod\u0117l globalios? - Demonstruoja globalias vs metod\u0173 funkcijas - Kambarys neturi \"\u017einoti\" apie skai\u010diavimus (separation of concerns) - Galima skirtingi skai\u010diavimo algoritmai skirtingiems tikslams</p>"},{"location":"Pratybos/po%20U1/U3/#logging-patobulinimai","title":"Logging patobulinimai:","text":"<p>Vis\u0173 klasi\u0173 konstruktoriuose/destruktoriuose:</p> <pre><code>// Langas konstruktorius\nLangas::Langas(float a, float p) : aukstis(a), plotis(p) {\n    sukurtaLangu++;\n    cout &lt;&lt; \"[DEBUG] Langas sukurtas (\" &lt;&lt; aukstis &lt;&lt; \"\u00d7\" &lt;&lt; plotis \n         &lt;&lt; \"). Viso langu: \" &lt;&lt; sukurtaLangu &lt;&lt; endl;\n}\n\n// Langas destruktorius\nLangas::~Langas() {\n    sukurtaLangu--;\n    cout &lt;&lt; \"[DEBUG] Langas sunaikintas. Liko langu: \" \n         &lt;&lt; sukurtaLangu &lt;&lt; endl;\n}\n</code></pre> <p>Analogi\u0161kai <code>Durys</code> ir <code>Kambarys</code>.</p> <p>Testas: <pre><code>Kambarys kambarys(5.0, 4.0, 3.0);\n\nLangas l1(1.5, 1.0);\nLangas l2(1.5, 1.0);\nkambarys.pridetiLanga(l1);\nkambarys.pridetiLanga(l2);\n\nDurys* d1 = new Durys(2.0, 0.9);\nkambarys.nustatytiDuris(d1);\n\nfloat sienuPlotas = apskaiciuotiSienuPlota(kambarys);\nfloat grindjusces = apskaiciuotiGrindjuscesIlgi(kambarys);\n\ncout &lt;&lt; \"Sienu plotas: \" &lt;&lt; sienuPlotas &lt;&lt; \" m\u00b2\" &lt;&lt; endl;\ncout &lt;&lt; \"Grindjusciu ilgis: \" &lt;&lt; grindjusces &lt;&lt; \" m\" &lt;&lt; endl;\n</code></pre></p> <p>Pavyzdys: <pre><code>Sienu plotas: 48.5 m\u00b2\nGrindjusciu ilgis: 17.1 m\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U3/03/\n\u251c\u2500\u2500 Langas.h, Langas.cpp\n\u251c\u2500\u2500 Durys.h, Durys.cpp\n\u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n\u251c\u2500\u2500 skaiciavimai.h      \u2190 NAUJAS\n\u251c\u2500\u2500 skaiciavimai.cpp    \u2190 NAUJAS\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/po%20U1/U3/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/, U2/\n\u2514\u2500\u2500 U3/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Langas + Durys klas\u0117s\n    \u2502   \u251c\u2500\u2500 Langas.h, Langas.cpp\n    \u2502   \u251c\u2500\u2500 Durys.h, Durys.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 02/                \u2190 Kambarys (kompozicija)\n    \u2502   \u251c\u2500\u2500 Langas.h, Langas.cpp\n    \u2502   \u251c\u2500\u2500 Durys.h, Durys.cpp\n    \u2502   \u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u2514\u2500\u2500 03/                \u2190 Skai\u010diavimai (globalios) - FINAL\n        \u251c\u2500\u2500 Langas.h, Langas.cpp\n        \u251c\u2500\u2500 Durys.h, Durys.cpp\n        \u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n        \u251c\u2500\u2500 skaiciavimai.h, skaiciavimai.cpp\n        \u251c\u2500\u2500 main.cpp\n        \u2514\u2500\u2500 Makefile\n</code></pre>"},{"location":"Pratybos/po%20U1/U3/#git-workflow","title":"Git workflow:","text":"<pre><code>git add U3/01/\ngit commit -m \"U3: 1 \u017eingsnis - Langas ir Durys klas\u0117s\"\ngit push\n\ngit add U3/02/\ngit commit -m \"U3: 2 \u017eingsnis - Kambarys kompozicija\"\ngit push\n\ngit add U3/03/\ngit commit -m \"U3: 3 \u017eingsnis - Skai\u010diavimai ir logging\"\ngit push\n</code></pre>"},{"location":"Pratybos/po%20U1/U3/#u3readmemd-sablonas","title":"U3/README.md \u0161ablonas:","text":"<p><pre><code># U3: Kompozicija (has-a ry\u0161ys)\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-14\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Langas ir Durys klas\u0117s (static counter) |\n| 2 | `02/` | Kambarys kompozicija (vector + pointer) |\n| 3 | `03/` | Skai\u010diavimai (globalios funkcijos) |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (kompozicija)**:\n</code></pre> Kambarys: 5\u00d74\u00d73 Lang\u0173: 2 Dur\u0173: 1 \u2705 VEIKIA <pre><code>**Testas 2 (skai\u010diavimai)**:\n</code></pre> Sien\u0173 plotas: 48.5 m\u00b2 Grindjuos\u010di\u0173 ilgis: 17.1 m \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Kompozicija - vienas objektas \"turi\" kitus\n2. Vector vs pointer - skirtinga semantika\n3. Statiniai nariai - klas\u0117s lygio duomenys\n4. Globalios funkcijos vs metodai\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U3/#moodle-pateikimas","title":"Moodle pateikimas:","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U3_VardasPavarde.zip HEAD U3/ README.md .gitignore\n</code></pre>"},{"location":"Pratybos/po%20U1/U3/#vertinimo-kriterijai","title":"\u2705 Vertinimo kriterijai","text":"Kriterijus Balai Programa kompiliuojasi be klaid\u0173 15% Langas ir Durys klas\u0117s veikia 15% Static counter veikia 10% Kambarys kompozicija veikia 25% Destruktorius atlaisvina duris 10% Globalios funkcijos veikia 15% Logging ai\u0161kus 5% README.md su testais 5% TOTAL 100%"},{"location":"Pratybos/po%20U1/U3/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Statiniai nariai - inicializuoti u\u017e klas\u0117s rib\u0173 (<code>.cpp</code>)</li> <li>Vector vs pointer:</li> <li><code>vector&lt;Langas&gt;</code> - kopijuoja objektus (value)</li> <li><code>Durys*</code> - dalijasi nuoroda (pointer)</li> <li>Destruktorius - patikrinti <code>if (durys != nullptr)</code> prie\u0161 <code>delete</code></li> <li>Globalios funkcijos - perduoti <code>const Kambarys&amp;</code> (reference)</li> <li>Logging - padeda debug'inti (kada objektai kuriami/naikinami)</li> <li>Fail\u0173 skai\u010dius - U3/03 turi 8 failus (6 <code>.cpp</code> + Makefile + main)</li> </ol>"},{"location":"Pratybos/po%20U1/U3/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>C++ kompozicija</li> <li>Static members</li> <li>Vector container</li> </ul>"},{"location":"Pratybos/po%20U1/U3/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l <code>langai</code> - vector, o <code>durys</code> - pointer? A: Demonstruoti skirtingas kompozicijos formas. Lang\u0173 gali b\u016bti daug (vector), dur\u0173 - vienos (pointer).</p> <p>K: Kod\u0117l globalios funkcijos, ne metodai? A: Demonstruoti skirtumus. V\u0117liau (U4) gr\u012f\u0161ime prie metod\u0173.</p> <p>K: Ar reikia <code>langai.clear()</code> destruktoriuje? A: Ne (vector destruktorius automati\u0161kai), bet gera praktika.</p> <p>K: Kod\u0117l <code>sukurtaLangu</code> - static? A: Nes tai klas\u0117s lygio duomenys (bendri visiems objektams), ne objekto lygio.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/po%20U1/U4-solution/","title":"U4: Sprendimas - Gilus Kopijavimas (Deep Copy)","text":"<p>D\u0117stytojui: Pilnas sprendimas su shallow copy demo ir Rule of Three implementacija.</p>"},{"location":"Pratybos/po%20U1/U4-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U4/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 01/  \u2190 Shallow copy problema\n\u251c\u2500\u2500 02/  \u2190 Copy constructor\n\u2514\u2500\u2500 03/  \u2190 Copy assignment (Rule of Three)\n</code></pre> <p>Pastaba: Visi \u017eingsniai naudoja tas pa\u010dias klases i\u0161 U3 (Langas, Durys, Kambarys, skaiciavimai). Skiriasi tik <code>Kambarys.cpp</code> implementacija.</p>"},{"location":"Pratybos/po%20U1/U4-solution/#1-1-zingsnis-shallow-copy-problema","title":"1\ufe0f\u20e3 1 \u017eingsnis: Shallow copy problema","text":""},{"location":"Pratybos/po%20U1/U4-solution/#kambarysh-kaip-u3-be-copy-constructorassignment","title":"Kambarys.h (kaip U3 - be copy constructor/assignment):","text":"<pre><code>#ifndef KAMBARYS_H\n#define KAMBARYS_H\n\n#include &lt;vector&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nclass Kambarys {\nprivate:\n    float ilgis;\n    float plotis;\n    float aukstis;\n\n    std::vector&lt;Langas&gt; langai;\n    Durys* durys;\n\npublic:\n    Kambarys(float i, float p, float a);\n    ~Kambarys();\n\n    void pridetiLanga(const Langas&amp; langas);\n    void nustatytiDuris(Durys* d);\n\n    float gautiIlgi() const;\n    float gautiPloti() const;\n    float gautiAuksti() const;\n\n    // Friend funkcijos\n    friend float apskaiciuotiSienuPlota(const Kambarys&amp; k);\n    friend float apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u274c N\u0117ra copy constructor</li> <li>\u274c N\u0117ra copy assignment operator</li> <li>\u2705 Yra destruktorius</li> <li>\u26a0\ufe0f Problema: Rule of Three pa\u017eeidimas!</li> </ul>"},{"location":"Pratybos/po%20U1/U4-solution/#kambaryscpp-kaip-u3","title":"Kambarys.cpp (kaip U3):","text":"<pre><code>#include \"Kambarys.h\"\n#include &lt;iostream&gt;\n\nKambarys::Kambarys(float i, float p, float a) \n    : ilgis(i), plotis(p), aukstis(a), durys(nullptr) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sukurtas\" &lt;&lt; std::endl;\n}\n\nKambarys::~Kambarys() {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys naikinamas\" &lt;&lt; std::endl;\n    if (durys != nullptr) {\n        std::cout &lt;&lt; \"[DEBUG] Kambarys naikina savo duris\" &lt;&lt; std::endl;\n        delete durys;\n        durys = nullptr;\n    }\n    langai.clear();\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sunaikintas\" &lt;&lt; std::endl;\n}\n\n// ... kiti metodai kaip U3 ...\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#skaiciavimaih-su-testuotikopija-funkcija","title":"skaiciavimai.h (su testuotiKopija funkcija):","text":"<pre><code>#ifndef SKAICIAVIMAI_H\n#define SKAICIAVIMAI_H\n\n#include \"Kambarys.h\"\n\nfloat apskaiciuotiSienuPlota(const Kambarys&amp; k);\nfloat apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n\n// NAUJAS: Funkcija testui (pass-by-VALUE!)\nvoid testuotiKopija(Kambarys k);\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#skaiciavimaicpp","title":"skaiciavimai.cpp:","text":"<pre><code>#include \"skaiciavimai.h\"\n#include &lt;iostream&gt;\n\n// ... (apskaiciuotiSienuPlota, apskaiciuotiGrindjuscesIlgi kaip U3) ...\n\n// NAUJAS: Testuoti kopijavim\u0105\nvoid testuotiKopija(Kambarys k) {\n    // Parametras 'k' yra KOPIJA (pass-by-value)\n    std::cout &lt;&lt; \"[FUNKCIJOJE] Testuojame kopija\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"[FUNKCIJOJE] Sienu plotas = \" \n              &lt;&lt; apskaiciuotiSienuPlota(k) &lt;&lt; \" m\u00b2\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"[FUNKCIJOJE] Funkcija baigiasi (destruktorius bus i\u0161kvie\u010diamas)\" \n              &lt;&lt; std::endl;\n} // \u2190 k destruktorius \u010dia!\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>Kambarys k</code> - pass-by-value (ne <code>const Kambarys&amp;</code>)</li> <li>\u2705 Funkcijos pabaigoje <code>k</code> destruktorius automati\u0161kai kvie\u010diamas</li> <li>\u26a0\ufe0f Shallow copy: <code>k.durys</code> rodo \u012f t\u0105 pat\u012f objekt\u0105 kaip originalo <code>durys</code>!</li> </ul>"},{"location":"Pratybos/po%20U1/U4-solution/#maincpp-problema-demo","title":"main.cpp (problema demo):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n#include \"Kambarys.h\"\n#include \"skaiciavimai.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U4 \u017dingsnis 1: Shallow Copy Problema ===\\n\" &lt;&lt; endl;\n\n    // Setup\n    cout &lt;&lt; \"--- Sukuriame kambar\u012f ---\" &lt;&lt; endl;\n    Kambarys* k1 = new Kambarys(5.0, 4.0, 3.0);\n\n    Langas l1(1.5, 1.0);\n    k1-&gt;pridetiLanga(l1);\n\n    Durys* d1 = new Durys(2.0, 0.9);\n    k1-&gt;nustatytiDuris(d1);\n\n    cout &lt;&lt; \"\\nKambarys sukonfig\u016bruotas. Duriu counter: \" \n         &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // TESTAS 1: Pirmas kvietimas\n    cout &lt;&lt; \"\\n========================================\" &lt;&lt; endl;\n    cout &lt;&lt; \"TESTAS 1: Pirmas kvietimas (veiks OK)\" &lt;&lt; endl;\n    cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n    testuotiKopija(*k1);\n\n    cout &lt;&lt; \"\\nPo pirmo kvietimo. Duriu counter: \" \n         &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // TESTAS 2: Antras kvietimas (PROBLEMA!)\n    cout &lt;&lt; \"\\n========================================\" &lt;&lt; endl;\n    cout &lt;&lt; \"TESTAS 2: Antras kvietimas (CRASH/ERROR!)\" &lt;&lt; endl;\n    cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n\n    cout &lt;&lt; \"[\u012eSP\u0116JIMAS] \u0160is kvietimas tur\u0117t\u0173 sukelti problem\u0105...\" &lt;&lt; endl;\n    testuotiKopija(*k1);  // \u2190 CRASH arba undefined behavior!\n\n    cout &lt;&lt; \"\\nJei programa nepasuko, \u010dia matote blogus duomenis.\" &lt;&lt; endl;\n\n    delete k1;\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#isvestis-crash-scenario","title":"I\u0161vestis (CRASH scenario):","text":"<pre><code>=== U4 \u017dingsnis 1: Shallow Copy Problema ===\n\n--- Sukuriame kambar\u012f ---\n[DEBUG] Kambarys sukurtas\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 2\n[DEBUG] Kambarys pridejo langa. Viso langu: 1\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 1\n[DEBUG] Kambarys gavo duris\n\nKambarys sukonfig\u016bruotas. Duriu counter: 1\n\n========================================\nTESTAS 1: Pirmas kvietimas (veiks OK)\n========================================\n[FUNKCIJOJE] Testuojame kopija\n[FUNKCIJOJE] Sienu plotas = 49.20 m\u00b2\n[FUNKCIJOJE] Funkcija baigiasi (destruktorius bus i\u0161kvie\u010diamas)\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 0  \u2190 delete durys!\n[DEBUG] Langas sunaikintas. Liko langu: 1\n[DEBUG] Kambarys sunaikintas\n\nPo pirmo kvietimo. Duriu counter: 0  \u2190 Durys jau sunaikintos!\n\n========================================\nTESTAS 2: Antras kvietimas (CRASH/ERROR!)\n========================================\n[\u012eSP\u0116JIMAS] \u0160is kvietimas tur\u0117t\u0173 sukelti problem\u0105...\n[FUNKCIJOJE] Testuojame kopija\nSegmentation fault (core dumped)  \u2190 CRASH!\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#arba-jei-ne-crash-tai-blogai","title":"Arba (jei ne crash, tai blogai):","text":"<pre><code>...\nTESTAS 2: Antras kvietimas (CRASH/ERROR!)\n...\n[FUNKCIJOJE] Sienu plotas = -nan m\u00b2  \u2190 Blogas rezultatas!\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\ndouble free or corruption (out): 0x... \u2190 Double-free!\nAborted (core dumped)\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\ud83d\udca5 Pirmas kvietimas: Veikia, bet sunaikina <code>durys</code> objekt\u0105</li> <li>\ud83d\udca5 Antras kvietimas: <code>durys</code> jau <code>delete</code>'intos \u2192 dangling pointer!</li> <li>\ud83d\udca5 Rezultatas: Crash arba undefined behavior</li> <li>\ud83d\udca1 Prie\u017eastis: Default copy constructor daro shallow copy</li> </ul> <p>Vizualizacija:</p> <pre><code>Prie\u0161 pirma testuotiKopija():\nk1:     durys \u2192 [Durys @0x1234]\n\nPo kopijos (shallow):\nk1:     durys \u2192 [Durys @0x1234]\n                  \u2191\nkopija: durys \u2500\u2500\u2500\u2500\u2518  (ta pati rodykl\u0117!)\n\nPo pirmo destruktoriaus:\nk1:     durys \u2192 [DELETED @0x1234]  \u2190 dangling!\nkopija: (jau sunaikinta)\n\nAntro testuotiKopija():\nkopija: durys \u2192 [DELETED @0x1234]  \u2190 CRASH!\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#2-2-zingsnis-copy-constructor-deep-copy","title":"2\ufe0f\u20e3 2 \u017eingsnis: Copy constructor (deep copy)","text":""},{"location":"Pratybos/po%20U1/U4-solution/#kambarysh-papildymas","title":"Kambarys.h (papildymas):","text":"<pre><code>#ifndef KAMBARYS_H\n#define KAMBARYS_H\n\n#include &lt;vector&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nclass Kambarys {\nprivate:\n    float ilgis;\n    float plotis;\n    float aukstis;\n\n    std::vector&lt;Langas&gt; langai;\n    Durys* durys;\n\npublic:\n    Kambarys(float i, float p, float a);\n\n    // NAUJAS: Copy constructor\n    Kambarys(const Kambarys&amp; kitas);\n\n    ~Kambarys();\n\n    // ... kiti metodai ...\n\n    friend float apskaiciuotiSienuPlota(const Kambarys&amp; k);\n    friend float apskaiciuotiGrindjuscesIlgi(const Kambarys&amp; k);\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#kambaryscpp-su-copy-constructor","title":"Kambarys.cpp (su copy constructor):","text":"<pre><code>#include \"Kambarys.h\"\n#include &lt;iostream&gt;\n\n// Default konstruktorius (tas pats)\nKambarys::Kambarys(float i, float p, float a) \n    : ilgis(i), plotis(p), aukstis(a), durys(nullptr) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sukurtas (default konstruktorius)\" &lt;&lt; std::endl;\n}\n\n// NAUJAS: Copy constructor\nKambarys::Kambarys(const Kambarys&amp; kitas) \n    : ilgis(kitas.ilgis), \n      plotis(kitas.plotis), \n      aukstis(kitas.aukstis) {\n\n    std::cout &lt;&lt; \"[DEBUG] Kambarys kopijuojamas (copy constructor)\" &lt;&lt; std::endl;\n\n    // 1. Kopijuoti langus\n    // Vector automati\u0161kai daro deep copy!\n    langai = kitas.langai;\n    std::cout &lt;&lt; \"[DEBUG]   - Langai nukopijuoti (vector deep copy)\" &lt;&lt; std::endl;\n\n    // 2. Kopijuoti duris (DEEP COPY - naujas objektas!)\n    if (kitas.durys != nullptr) {\n        durys = new Durys(*kitas.durys);  // I\u0161kvie\u010dia Durys copy constructor\n        std::cout &lt;&lt; \"[DEBUG]   - Durys nukopijuotos (deep copy, naujas objektas)\" \n                  &lt;&lt; std::endl;\n    } else {\n        durys = nullptr;\n        std::cout &lt;&lt; \"[DEBUG]   - Durys: nullptr\" &lt;&lt; std::endl;\n    }\n}\n\n// Destruktorius (tas pats)\nKambarys::~Kambarys() {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys naikinamas\" &lt;&lt; std::endl;\n    if (durys != nullptr) {\n        std::cout &lt;&lt; \"[DEBUG] Kambarys naikina savo duris\" &lt;&lt; std::endl;\n        delete durys;\n        durys = nullptr;\n    }\n    langai.clear();\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sunaikintas\" &lt;&lt; std::endl;\n}\n\n// ... kiti metodai kaip anks\u010diau ...\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>Kambarys(const Kambarys&amp; kitas)</code> - copy constructor signature</li> <li>\u2705 <code>: ilgis(kitas.ilgis), ...</code> - initialization list (kopijuoti primityvus)</li> <li>\u2705 <code>langai = kitas.langai</code> - vector automati\u0161kai daro deep copy!</li> <li>\u2705 <code>new Durys(*kitas.durys)</code> - naujas Durys objektas (deep copy!)</li> <li>\u2705 <code>*kitas.durys</code> - dereferencing pointer (gauti Durys objekt\u0105)</li> <li>\ud83d\udca1 Durys turi tur\u0117ti copy constructor - default veiks, jei n\u0117ra pointeri\u0173</li> </ul>"},{"location":"Pratybos/po%20U1/U4-solution/#maincpp-testas-dabar-veikia","title":"main.cpp (testas dabar veikia):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n#include \"Kambarys.h\"\n#include \"skaiciavimai.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U4 \u017dingsnis 2: Copy Constructor (Deep Copy) ===\\n\" &lt;&lt; endl;\n\n    // Setup\n    cout &lt;&lt; \"--- Sukuriame kambar\u012f ---\" &lt;&lt; endl;\n    Kambarys* k1 = new Kambarys(5.0, 4.0, 3.0);\n\n    Langas l1(1.5, 1.0);\n    k1-&gt;pridetiLanga(l1);\n\n    Durys* d1 = new Durys(2.0, 0.9);\n    k1-&gt;nustatytiDuris(d1);\n\n    cout &lt;&lt; \"\\nDuriu counter prad\u017eioje: \" &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // TESTAS 1: Pirmas kvietimas\n    cout &lt;&lt; \"\\n========================================\" &lt;&lt; endl;\n    cout &lt;&lt; \"TESTAS 1: Pirmas kvietimas\" &lt;&lt; endl;\n    cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n    testuotiKopija(*k1);\n\n    cout &lt;&lt; \"\\nDuriu counter po pirmo: \" &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // TESTAS 2: Antras kvietimas (dabar tur\u0117t\u0173 veikti!)\n    cout &lt;&lt; \"\\n========================================\" &lt;&lt; endl;\n    cout &lt;&lt; \"TESTAS 2: Antras kvietimas (dabar OK!)\" &lt;&lt; endl;\n    cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n    testuotiKopija(*k1);\n\n    cout &lt;&lt; \"\\nDuriu counter po antro: \" &lt;&lt; Durys::gautiSukurtaDuriu() &lt;&lt; endl;\n\n    // TESTAS 3: Tre\u010dias kvietimas (dar kart\u0105!)\n    cout &lt;&lt; \"\\n========================================\" &lt;&lt; endl;\n    cout &lt;&lt; \"TESTAS 3: Tre\u010dias kvietimas (vis dar OK!)\" &lt;&lt; endl;\n    cout &lt;&lt; \"========================================\" &lt;&lt; endl;\n    testuotiKopija(*k1);\n\n    cout &lt;&lt; \"\\nVisi testai pra\u0117jo! Copy constructor veikia.\" &lt;&lt; endl;\n\n    delete k1;\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#isvestis-veikia","title":"I\u0161vestis (VEIKIA!):","text":"<pre><code>=== U4 \u017dingsnis 2: Copy Constructor (Deep Copy) ===\n\n--- Sukuriame kambar\u012f ---\n[DEBUG] Kambarys sukurtas (default konstruktorius)\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 2\n[DEBUG] Kambarys pridejo langa. Viso langu: 1\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 1\n[DEBUG] Kambarys gavo duris\n\nDuriu counter prad\u017eioje: 1\n\n========================================\nTESTAS 1: Pirmas kvietimas\n========================================\n[DEBUG] Kambarys kopijuojamas (copy constructor)\n[DEBUG]   - Langai nukopijuoti (vector deep copy)\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 2  \u2190 Nauja kopija!\n[DEBUG]   - Durys nukopijuotos (deep copy, naujas objektas)\n[FUNKCIJOJE] Testuojame kopija\n[FUNKCIJOJE] Sienu plotas = 49.20 m\u00b2\n[FUNKCIJOJE] Funkcija baigiasi (destruktorius bus i\u0161kvie\u010diamas)\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 1  \u2190 Kopija sunaikinta\n[DEBUG] Langas sunaikintas. Liko langu: 1\n[DEBUG] Kambarys sunaikintas\n\nDuriu counter po pirmo: 1  \u2190 Originalo durys vis dar gyvi!\n\n========================================\nTESTAS 2: Antras kvietimas (dabar OK!)\n========================================\n[DEBUG] Kambarys kopijuojamas (copy constructor)\n[DEBUG]   - Langai nukopijuoti (vector deep copy)\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 2  \u2190 Dar viena kopija!\n[DEBUG]   - Durys nukopijuotos (deep copy, naujas objektas)\n[FUNKCIJOJE] Testuojame kopija\n[FUNKCIJOJE] Sienu plotas = 49.20 m\u00b2\n[FUNKCIJOJE] Funkcija baigiasi (destruktorius bus i\u0161kvie\u010diamas)\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 1\n[DEBUG] Langas sunaikintas. Liko langu: 1\n[DEBUG] Kambarys sunaikintas\n\nDuriu counter po antro: 1  \u2190 OK!\n\n========================================\nTESTAS 3: Tre\u010dias kvietimas (vis dar OK!)\n========================================\n...\n\nVisi testai pra\u0117jo! Copy constructor veikia.\n...\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 Dur\u0173 counter: 1 originalas + 1 kopija (bet ne vienu metu!)</li> <li>\u2705 Kiekvienas copy sukuria nauj\u0105 Durys objekt\u0105</li> <li>\u2705 Destruktoriai: Kiekviena kopija sunaikina savo duris</li> <li>\ud83d\udca1 Originalo durys i\u0161lieka nepaliesti!</li> </ul>"},{"location":"Pratybos/po%20U1/U4-solution/#3-3-zingsnis-copy-assignment-operator","title":"3\ufe0f\u20e3 3 \u017eingsnis: Copy assignment operator","text":""},{"location":"Pratybos/po%20U1/U4-solution/#kambarysh-papildymas_1","title":"Kambarys.h (papildymas):","text":"<pre><code>#ifndef KAMBARYS_H\n#define KAMBARYS_H\n\n#include &lt;vector&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n\nclass Kambarys {\nprivate:\n    float ilgis;\n    float plotis;\n    float aukstis;\n\n    std::vector&lt;Langas&gt; langai;\n    Durys* durys;\n\npublic:\n    Kambarys(float i, float p, float a);\n    Kambarys(const Kambarys&amp; kitas);\n\n    // NAUJAS: Copy assignment operator\n    Kambarys&amp; operator=(const Kambarys&amp; kitas);\n\n    ~Kambarys();\n\n    // ... kiti metodai ...\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#kambaryscpp-galutine-versija-rule-of-three","title":"Kambarys.cpp (galutin\u0117 versija - Rule of Three):","text":"<pre><code>#include \"Kambarys.h\"\n#include &lt;iostream&gt;\n\n// Default konstruktorius\nKambarys::Kambarys(float i, float p, float a) \n    : ilgis(i), plotis(p), aukstis(a), durys(nullptr) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sukurtas (default konstruktorius)\" &lt;&lt; std::endl;\n}\n\n// Copy constructor\nKambarys::Kambarys(const Kambarys&amp; kitas) \n    : ilgis(kitas.ilgis), plotis(kitas.plotis), aukstis(kitas.aukstis) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys kopijuojamas (copy constructor)\" &lt;&lt; std::endl;\n\n    langai = kitas.langai;\n\n    if (kitas.durys != nullptr) {\n        durys = new Durys(*kitas.durys);\n    } else {\n        durys = nullptr;\n    }\n}\n\n// NAUJAS: Copy assignment operator\nKambarys&amp; Kambarys::operator=(const Kambarys&amp; kitas) {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys kopijuojamas (operator=)\" &lt;&lt; std::endl;\n\n    // 1. Self-assignment check\n    if (this == &amp;kitas) {\n        std::cout &lt;&lt; \"[DEBUG]   - Self-assignment aptiktas, praleidziama\" &lt;&lt; std::endl;\n        return *this;\n    }\n\n    // 2. Atlaisvinti senus resursus\n    std::cout &lt;&lt; \"[DEBUG]   - Atlaisvinami seni resursai\" &lt;&lt; std::endl;\n    if (durys != nullptr) {\n        delete durys;\n        durys = nullptr;\n    }\n    langai.clear();\n\n    // 3. Kopijuoti naujus duomenis\n    std::cout &lt;&lt; \"[DEBUG]   - Kopijuojami nauji duomenys\" &lt;&lt; std::endl;\n    ilgis = kitas.ilgis;\n    plotis = kitas.plotis;\n    aukstis = kitas.aukstis;\n\n    langai = kitas.langai;  // Vector deep copy\n\n    if (kitas.durys != nullptr) {\n        durys = new Durys(*kitas.durys);  // Deep copy\n    } else {\n        durys = nullptr;\n    }\n\n    return *this;\n}\n\n// Destruktorius\nKambarys::~Kambarys() {\n    std::cout &lt;&lt; \"[DEBUG] Kambarys naikinamas\" &lt;&lt; std::endl;\n    if (durys != nullptr) {\n        delete durys;\n        durys = nullptr;\n    }\n    langai.clear();\n    std::cout &lt;&lt; \"[DEBUG] Kambarys sunaikintas\" &lt;&lt; std::endl;\n}\n\n// ... kiti metodai ...\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-pastabos_5","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>Kambarys&amp; operator=(...)</code> - return reference (chaining)</li> <li>\u2705 Step 1: Self-assignment check (<code>if (this == &amp;kitas)</code>)</li> <li>\u2705 Step 2: Delete old resources BEFORE copying</li> <li>\u2705 Step 3: Copy new data (deep copy!)</li> <li>\u2705 <code>return *this</code> - enable chaining (<code>a = b = c</code>)</li> <li>\u26a0\ufe0f Kritin\u0117 klaida: Jei pamir\u0161ti self-check \u2192 sunaikini objekt\u0105 prie\u0161 kopijuojant!</li> </ul>"},{"location":"Pratybos/po%20U1/U4-solution/#maincpp-galutinis-testas","title":"main.cpp (galutinis testas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Langas.h\"\n#include \"Durys.h\"\n#include \"Kambarys.h\"\n#include \"skaiciavimai.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U4 \u017dingsnis 3: Copy Assignment (Rule of Three) ===\\n\" &lt;&lt; endl;\n\n    // TESTAS 1: Assignment\n    cout &lt;&lt; \"--- TESTAS 1: Assignment (k2 = k1) ---\" &lt;&lt; endl;\n\n    Kambarys k1(5.0, 4.0, 3.0);\n    Langas l1(1.5, 1.0);\n    k1.pridetiLanga(l1);\n    Durys* d1 = new Durys(2.0, 0.9);\n    k1.nustatytiDuris(d1);\n\n    Kambarys k2(3.0, 3.0, 2.5);  // Skirtingi matmenys\n\n    cout &lt;&lt; \"\\nPrie\u0161 assignment:\" &lt;&lt; endl;\n    cout &lt;&lt; \"k1 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k1) &lt;&lt; endl;\n    cout &lt;&lt; \"k2 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k2) &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\nDarome: k2 = k1\" &lt;&lt; endl;\n    k2 = k1;  // \u2190 operator= i\u0161kvie\u010diamas!\n\n    cout &lt;&lt; \"\\nPo assignment:\" &lt;&lt; endl;\n    cout &lt;&lt; \"k1 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k1) &lt;&lt; endl;\n    cout &lt;&lt; \"k2 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k2) &lt;&lt; endl;\n\n    // TESTAS 2: Self-assignment\n    cout &lt;&lt; \"\\n--- TESTAS 2: Self-assignment (k2 = k2) ---\" &lt;&lt; endl;\n    k2 = k2;  // \u2190 Tur\u0117t\u0173 aptikti ir praleisti!\n\n    cout &lt;&lt; \"Po self-assignment:\" &lt;&lt; endl;\n    cout &lt;&lt; \"k2 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k2) &lt;&lt; endl;\n\n    // TESTAS 3: Chaining\n    cout &lt;&lt; \"\\n--- TESTAS 3: Chaining (k3 = k2 = k1) ---\" &lt;&lt; endl;\n    Kambarys k3(2.0, 2.0, 2.0);\n    k3 = k2 = k1;  // \u2190 Tur\u0117t\u0173 veikti (de\u0161in\u0117 \u012f kair\u0119)!\n\n    cout &lt;&lt; \"k3 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k3) &lt;&lt; endl;\n\n    cout &lt;&lt; \"\\n=== Visi testai pra\u0117jo! ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#isvestis","title":"I\u0161vestis:","text":"<pre><code>=== U4 \u017dingsnis 3: Copy Assignment (Rule of Three) ===\n\n--- TESTAS 1: Assignment (k2 = k1) ---\n[DEBUG] Kambarys sukurtas (default konstruktorius)\n[DEBUG] Langas sukurtas (1.5\u00d71). Viso langu: 1\n...\n[DEBUG] Kambarys sukurtas (default konstruktorius)\n\nPrie\u0161 assignment:\nk1 sienu plotas: 49.20\nk2 sienu plotas: 54.00\n\nDarome: k2 = k1\n[DEBUG] Kambarys kopijuojamas (operator=)\n[DEBUG]   - Atlaisvinami seni resursai\n[DEBUG]   - Kopijuojami nauji duomenys\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 2  \u2190 Nauja kopija!\n\nPo assignment:\nk1 sienu plotas: 49.20\nk2 sienu plotas: 49.20  \u2190 Dabar vienodi!\n\n--- TESTAS 2: Self-assignment (k2 = k2) ---\n[DEBUG] Kambarys kopijuojamas (operator=)\n[DEBUG]   - Self-assignment aptiktas, praleidziama  \u2190 Saugumas!\n\nPo self-assignment:\nk2 sienu plotas: 49.20\n\n--- TESTAS 3: Chaining (k3 = k2 = k1) ---\n[DEBUG] Kambarys sukurtas (default konstruktorius)\n[DEBUG] Kambarys kopijuojamas (operator=)\n...\n[DEBUG] Kambarys kopijuojamas (operator=)\n...\nk3 sienu plotas: 49.20\n\n=== Visi testai pra\u0117jo! ===\n...\n</code></pre>"},{"location":"Pratybos/po%20U1/U4-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/po%20U1/U4-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas Pamir\u0161o self-assignment check \u2b50\u2b50\u2b50\u2b50\u2b50 Sunaikina objekt\u0105 prie\u0161 kopijuojant! Neatlaisvino sen\u0173 resurs\u0173 operator= \u2b50\u2b50\u2b50\u2b50 Memory leak Shallow copy (nesuprasti problem\u0105) \u2b50\u2b50\u2b50\u2b50 Demo su 01/ Pamir\u0161o <code>return *this</code> \u2b50\u2b50\u2b50 Chaining neveiks <code>new Durys(kitas.durys)</code> vietoj <code>(*kitas.durys)</code> \u2b50\u2b50\u2b50 Compiler error Delete po copy (ne prie\u0161!) \u2b50\u2b50 Duomen\u0173 praradimas"},{"location":"Pratybos/po%20U1/U4-solution/#diskusijos-taskai","title":"Diskusijos ta\u0161kai:","text":"<ol> <li>Shallow vs Deep Copy visualization - pie\u0161ti lentel\u0117je!</li> <li>Rule of Three - kod\u0117l trys (destruktorius + 2 copy)?</li> <li>Self-assignment - demo: <code>k = k</code> be check \u2192 crash</li> <li>Chaining - <code>a = b = c</code> kaip veikia? (right-to-left)</li> <li>Vector automatic deep copy - kod\u0117l lengviau u\u017e pointer?</li> </ol>"},{"location":"Pratybos/po%20U1/U4-solution/#prapletimai-stipriesiems","title":"Prapl\u0117timai stipriesiems:","text":"<ol> <li> <p>Move semantics (Rule of Five):    <pre><code>Kambarys(Kambarys&amp;&amp; kitas) noexcept;  // Move constructor\nKambarys&amp; operator=(Kambarys&amp;&amp; kitas) noexcept;  // Move assignment\n</code></pre></p> </li> <li> <p>Copy-and-swap idiom:    <pre><code>Kambarys&amp; operator=(Kambarys kitas) {  // Pass-by-value!\n    swap(*this, kitas);\n    return *this;\n}\n</code></pre></p> </li> <li> <p>Smart pointers vietoj raw:    <pre><code>std::unique_ptr&lt;Durys&gt; durys;  // Automatic deep copy!\n</code></pre></p> </li> </ol> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/po%20U1/U4/","title":"U4: Gilus Kopijavimas (Deep Copy)","text":"<p>Savait\u0117s: 7-8 Svoris: 1 balas Terminas: Savait\u0117s 8 pabaiga</p>"},{"location":"Pratybos/po%20U1/U4/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1-U3. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas</p> <p>SVARBU: \u0160i u\u017eduotis t\u0119sia U3 (Kambarys/Langas/Durys). Jei nepadar\u0117te U3, pirmiausia u\u017ebaikite j\u0105!</p>"},{"location":"Pratybos/po%20U1/U4/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti teisingai kopijuoti objektus, kurie turi dinaminius resursus (rodykles). Suprasti shallow copy vs deep copy problem\u0105. \u012egyvendinti Rule of Three (destruktorius, copy constructor, copy assignment operator).</p>"},{"location":"Pratybos/po%20U1/U4/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Suprasti shallow copy problem\u0105 (dangling pointer)</li> <li>\u2705 Ra\u0161yti copy constructor su deep copy</li> <li>\u2705 Ra\u0161yti copy assignment operator (<code>operator=</code>)</li> <li>\u2705 Taikyti Rule of Three princip\u0105</li> <li>\u2705 Testuoti kopijavim\u0105 su pass-by-value</li> <li>\u2705 Debug'inti memory problemas su logging</li> </ul>"},{"location":"Pratybos/po%20U1/U4/#kas-yra-shallow-vs-deep-copy","title":"\ud83d\udca1 Kas yra Shallow vs Deep Copy?","text":""},{"location":"Pratybos/po%20U1/U4/#shallow-copy-seklus-kopijavimas","title":"Shallow Copy (Seklus kopijavimas):","text":"<p>Default behavior - C++ kompiliatorius automati\u0161kai sukuria: <pre><code>Kambarys k2 = k1;  // Default copy constructor\n</code></pre></p> <p>Problema: Kopijuoja tik rodykl\u0117s reik\u0161m\u0119 (memory address), ne objekt\u0105!</p> <pre><code>k1:  durys \u2192 [Durys objektas @0x1234]\n              \u2191\nk2:  durys \u2500\u2500\u2518  (ta pati rodykl\u0117!)\n</code></pre> <p>Rezultatas: - Abu objektai dalijasi tuo pa\u010diu <code>Durys</code> objektu - Destruktorius bando <code>delete</code> du kartus \u2192 CRASH! \ud83d\udca5</p>"},{"location":"Pratybos/po%20U1/U4/#deep-copy-gilus-kopijavimas","title":"Deep Copy (Gilus kopijavimas):","text":"<p>M\u016bs\u0173 sprendimas: Kopijuoti pat\u012f objekt\u0105, ne tik rodykl\u0119!</p> <pre><code>k1:  durys \u2192 [Durys objektas @0x1234]\n\nk2:  durys \u2192 [Durys objektas @0x5678]  (NAUJA kopija!)\n</code></pre> <p>Rezultatas: - Kiekvienas objektas turi savo <code>Durys</code> kopij\u0105 - Destruktorius <code>delete</code> skirtingus objektus \u2192 SAFE! \u2705</p>"},{"location":"Pratybos/po%20U1/U4/#rule-of-three","title":"\ud83d\udca1 Rule of Three","text":"<p>Jei j\u016bs\u0173 klas\u0117 turi bent vien\u0105 i\u0161 \u0161i\u0173: 1. Destruktorius 2. Copy constructor 3. Copy assignment operator</p> <p>...tai privalote tur\u0117ti visus tris!</p> <p>Kod\u0117l? - Destruktorius \u2192 klas\u0117 valdo resursus - Valdo resursus \u2192 reikia deep copy - Reikia deep copy \u2192 reikia copy constructor IR copy assignment</p> <p>Kambarys klasei: 1. \u2705 <code>~Kambarys()</code> - destruktorius (tur\u0117jome U3) 2. \u2705 <code>Kambarys(const Kambarys&amp;)</code> - copy constructor (prid\u0117sime U4) 3. \u2705 <code>Kambarys&amp; operator=(const Kambarys&amp;)</code> - copy assignment (prid\u0117sime U4)</p>"},{"location":"Pratybos/po%20U1/U4/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/po%20U1/U4/#1-zingsnis-shallow-copy-problema-demo","title":"1 \u017eingsnis: Shallow copy problema (demo)","text":"<p>Direktorija: <code>U4/01/</code></p> <p>Reikalavimai:</p> <ol> <li>Kopijuokite U3/03/ kod\u0105 \u012f <code>U4/01/</code></li> <li>Visos klas\u0117s: <code>Langas</code>, <code>Durys</code>, <code>Kambarys</code></li> <li> <p>Visi failai: <code>.h</code>, <code>.cpp</code>, <code>skaiciavimai.*</code>, <code>main.cpp</code>, <code>Makefile</code></p> </li> <li> <p>Sukurkite globali\u0105 funkcij\u0105 <code>skaiciavimai.h</code>/<code>.cpp</code>:    <pre><code>void testuotiKopija(Kambarys k);  // Pass-by-VALUE (kopija!)\n</code></pre></p> </li> </ol> <p>Funkcijos turinys:    <pre><code>void testuotiKopija(Kambarys k) {\n    cout &lt;&lt; \"Funkcijoje: sienu plotas = \" \n         &lt;&lt; apskaiciuotiSienuPlota(k) &lt;&lt; endl;\n}\n</code></pre></p> <ol> <li>Main funkcijoje - demonstruoti problem\u0105: <pre><code>// Sukurti kambar\u012f su langais ir durimis\nKambarys* k1 = new Kambarys(5.0, 4.0, 3.0);\n// ... prid\u0117ti langus, duris ...\n\n// TESTAS 1: Pirmas kvietimas (veiks)\ncout &lt;&lt; \"Pirmas kvietimas:\" &lt;&lt; endl;\ntestuotiKopija(*k1);\n\n// TESTAS 2: Antras kvietimas (CRASH arba blogas rezultatas!)\ncout &lt;&lt; \"Antras kvietimas:\" &lt;&lt; endl;\ntestuotiKopija(*k1);  // \u2190 PROBLEMA \u010dia!\n\ndelete k1;\n</code></pre></li> </ol> <p>Rezultatas: - 1-as kvietimas: Veikia OK - 2-as kvietimas: CRASH arba neteisingi rezultatai - Kod\u0117l? Shallow copy \u2192 dangling pointer!</p> <p>Pavyzdys (galimas i\u0161vesties fragmentas): <pre><code>Pirmas kvietimas:\nFunkcijoje: sienu plotas = 49.20 m\u00b2\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 0  \u2190 delete durys!\n\nAntras kvietimas:\n[CRASH] Segmentation fault  \u2190 durys jau delete'intos!\n</code></pre></p> <p>U\u017eduotis studentui: - \u2705 Paleisti program\u0105 - \u2705 Pamatyti CRASH arba blogus rezultatus - \u2705 Suprasti problem\u0105 (shallow copy) - \u2705 README.md - apra\u0161yti, kas nutiko</p>"},{"location":"Pratybos/po%20U1/U4/#2-zingsnis-copy-constructor","title":"2 \u017eingsnis: Copy constructor","text":"<p>Direktorija: <code>U4/02/</code></p> <p>Reikalavimai:</p> <ol> <li> <p>Prid\u0117ti copy constructor \u012f <code>Kambarys.h</code>:    <pre><code>// Copy constructor\nKambarys(const Kambarys&amp; kitas);\n</code></pre></p> </li> <li> <p>Implementuoti copy constructor <code>Kambarys.cpp</code>:    <pre><code>Kambarys::Kambarys(const Kambarys&amp; kitas) \n    : ilgis(kitas.ilgis), \n      plotis(kitas.plotis), \n      aukstis(kitas.aukstis) {\n\n    cout &lt;&lt; \"[DEBUG] Kambarys kopijuojamas (copy constructor)\" &lt;&lt; endl;\n\n    // 1. Kopijuoti langus (vector daro deep copy automati\u0161kai!)\n    langai = kitas.langai;\n\n    // 2. Kopijuoti duris (DEEP COPY - naujas objektas!)\n    if (kitas.durys != nullptr) {\n        durys = new Durys(*kitas.durys);  // Sukurti NAUJ\u0104 Durys objekt\u0105\n    } else {\n        durys = nullptr;\n    }\n}\n</code></pre></p> </li> <li> <p>Testuoti su ta pa\u010dia <code>testuotiKopija()</code> funkcija: <pre><code>// Dabar tur\u0117t\u0173 veikti!\ncout &lt;&lt; \"Pirmas kvietimas:\" &lt;&lt; endl;\ntestuotiKopija(*k1);\n\ncout &lt;&lt; \"Antras kvietimas:\" &lt;&lt; endl;\ntestuotiKopija(*k1);  // \u2190 Dabar OK!\n</code></pre></p> </li> </ol> <p>Rezultatas: - \u2705 Abu kvietimai veikia! - \u2705 Logging rodo copy constructor kvietimus - \u2705 Kiekvienas <code>Kambarys</code> turi savo dur\u0173 kopij\u0105</p> <p>Pavyzdys (i\u0161vestis): <pre><code>Pirmas kvietimas:\n[DEBUG] Kambarys kopijuojamas (copy constructor)\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 2  \u2190 Nauja kopija!\nFunkcijoje: sienu plotas = 49.20 m\u00b2\n[DEBUG] Kambarys naikinamas\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 1\n\nAntras kvietimas:\n[DEBUG] Kambarys kopijuojamas (copy constructor)\n[DEBUG] Durys sukurtos (2\u00d70.9). Viso duriu: 2  \u2190 Dar viena kopija!\nFunkcijoje: sienu plotas = 49.20 m\u00b2\n[DEBUG] Kambarys naikinamos\n[DEBUG] Kambarys naikina savo duris\n[DEBUG] Durys sunaikintos. Liko duriu: 1\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U4/#3-zingsnis-copy-assignment-operator-rule-of-three","title":"3 \u017eingsnis: Copy assignment operator (Rule of Three)","text":"<p>Direktorija: <code>U4/03/</code></p> <p>Reikalavimai:</p> <ol> <li> <p>Prid\u0117ti copy assignment operator \u012f <code>Kambarys.h</code>:    <pre><code>// Copy assignment operator\nKambarys&amp; operator=(const Kambarys&amp; kitas);\n</code></pre></p> </li> <li> <p>Implementuoti operator= <code>Kambarys.cpp</code>:    <pre><code>Kambarys&amp; Kambarys::operator=(const Kambarys&amp; kitas) {\n    cout &lt;&lt; \"[DEBUG] Kambarys kopijuojamas (operator=)\" &lt;&lt; endl;\n\n    // 1. Patikrinti self-assignment\n    if (this == &amp;kitas) {\n        cout &lt;&lt; \"[DEBUG] Self-assignment aptiktas, praleidziama\" &lt;&lt; endl;\n        return *this;\n    }\n\n    // 2. Atlaisvinti senus resursus\n    if (durys != nullptr) {\n        cout &lt;&lt; \"[DEBUG] Atlaisvinamos senos durys\" &lt;&lt; endl;\n        delete durys;\n        durys = nullptr;\n    }\n    langai.clear();  // I\u0161valyti lang\u0173 vektori\u0173\n\n    // 3. Kopijuoti naujus duomenis\n    ilgis = kitas.ilgis;\n    plotis = kitas.plotis;\n    aukstis = kitas.aukstis;\n\n    langai = kitas.langai;  // Vector deep copy\n\n    if (kitas.durys != nullptr) {\n        durys = new Durys(*kitas.durys);  // Deep copy\n    } else {\n        durys = nullptr;\n    }\n\n    return *this;\n}\n</code></pre></p> </li> <li> <p>Testuoti su assignment: <pre><code>Kambarys k1(5.0, 4.0, 3.0);\n// ... prid\u0117ti langus, duris ...\n\nKambarys k2(3.0, 3.0, 2.5);\n\n// Assignment\ncout &lt;&lt; \"--- Priskyrimas: k2 = k1 ---\" &lt;&lt; endl;\nk2 = k1;\n\n// Testuoti k2\ncout &lt;&lt; \"k2 sienu plotas: \" &lt;&lt; apskaiciuotiSienuPlota(k2) &lt;&lt; endl;\n\n// Self-assignment testas\ncout &lt;&lt; \"--- Self-assignment: k2 = k2 ---\" &lt;&lt; endl;\nk2 = k2;  // Tur\u0117t\u0173 aptikti ir praleisti\n</code></pre></p> </li> <li> <p>Ekstremalus testas: <pre><code>Kambarys k1(5.0, 4.0, 3.0);\n// ... setup ...\n\nKambarys k2(3.0, 3.0, 2.5);\nk2 = k1;\n\n// Delete k1, bet k2 tur\u0117t\u0173 veikti!\ndelete &amp;k1;  // (jei dynamic)\n\ncout &lt;&lt; \"Po k1 delete, k2 sienu plotas: \" \n     &lt;&lt; apskaiciuotiSienuPlota(k2) &lt;&lt; endl;  // \u2190 Tur\u0117t\u0173 veikti!\n</code></pre></p> </li> </ol> <p>Rezultatas: - \u2705 Copy assignment veikia - \u2705 Self-assignment aptiktas - \u2705 k2 veikia net po k1 sunaikinimo (deep copy!)</p>"},{"location":"Pratybos/po%20U1/U4/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/po%20U1/U4/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 U1/, U2/, U3/\n\u2514\u2500\u2500 U4/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Shallow copy problema\n    \u2502   \u251c\u2500\u2500 Langas.h, Langas.cpp\n    \u2502   \u251c\u2500\u2500 Durys.h, Durys.cpp\n    \u2502   \u251c\u2500\u2500 Kambarys.h, Kambarys.cpp\n    \u2502   \u251c\u2500\u2500 skaiciavimai.h, skaiciavimai.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 02/                \u2190 Copy constructor\n    \u2502   \u251c\u2500\u2500 [visi failai kaip 01/]\n    \u2502   \u2514\u2500\u2500 Kambarys.cpp (modifikuotas)\n    \u2514\u2500\u2500 03/                \u2190 Copy assignment (Rule of Three) - FINAL\n        \u251c\u2500\u2500 [visi failai]\n        \u2514\u2500\u2500 Kambarys.cpp (modifikuotas)\n</code></pre>"},{"location":"Pratybos/po%20U1/U4/#git-workflow","title":"Git workflow:","text":"<pre><code>git add U4/01/\ngit commit -m \"U4: 1 \u017eingsnis - Shallow copy problema (demo)\"\ngit push\n\ngit add U4/02/\ngit commit -m \"U4: 2 \u017eingsnis - Copy constructor (deep copy)\"\ngit push\n\ngit add U4/03/\ngit commit -m \"U4: 3 \u017eingsnis - Copy assignment operator (Rule of Three)\"\ngit push\n</code></pre>"},{"location":"Pratybos/po%20U1/U4/#u4readmemd-sablonas","title":"U4/README.md \u0161ablonas:","text":"<p><pre><code># U4: Gilus Kopijavimas (Deep Copy)\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-03-28\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Shallow copy problema (crash demo) |\n| 2 | `02/` | Copy constructor (deep copy) |\n| 3 | `03/` | Copy assignment operator (Rule of Three) |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (shallow copy - 01/)**:\n</code></pre> Pirmas kvietimas: \u2705 VEIKIA Antras kvietimas: \u274c CRASH (dangling pointer) <pre><code>**Testas 2 (copy constructor - 02/)**:\n</code></pre> Pirmas kvietimas: \u2705 VEIKIA Antras kvietimas: \u2705 VEIKIA (deep copy!) <pre><code>**Testas 3 (copy assignment - 03/)**:\n</code></pre> k2 = k1 Po k1 delete: k2 vis dar veikia \u2705 <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Shallow copy \u2192 dangling pointer \u2192 crash\n2. Deep copy \u2192 naujas objektas \u2192 safe\n3. Rule of Three: destruktorius + copy constructor + operator=\n4. Self-assignment check svarbus!\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U4/#moodle-pateikimas","title":"Moodle pateikimas:","text":"<pre><code>cd cpp-2026\ngit archive --format=zip --output=U4_VardasPavarde.zip HEAD U4/ README.md .gitignore\n</code></pre>"},{"location":"Pratybos/po%20U1/U4/#vertinimo-kriterijai","title":"\u2705 Vertinimo kriterijai","text":"Kriterijus Balai Programa kompiliuojasi be klaid\u0173 15% Shallow copy problema pademonstruota 15% Copy constructor implementuotas 25% Copy assignment operator implementuotas 25% Self-assignment check 10% Testai veikia (pass-by-value, assignment) 5% README.md su problem\u0173 apra\u0161ymu 5% TOTAL 100%"},{"location":"Pratybos/po%20U1/U4/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Shallow copy testas - paleiskite 01/ ir pamatykite crash!</li> <li>Logging - padeda suprasti, kada copy constructor kvie\u010diamas</li> <li>Self-assignment - <code>if (this == &amp;kitas)</code> - B\u016aTINA patikra!</li> <li>Delete before copy - operator= turi atlaisvinti senus resursus</li> <li>Return *this - operator= turi gr\u0105\u017einti nuorod\u0105 (chaining: <code>a=b=c</code>)</li> <li>Vector deep copy - automatinis! (nereikia ra\u0161yti rankiniu b\u016bdu)</li> </ol>"},{"location":"Pratybos/po%20U1/U4/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>Rule of Three</li> <li>Copy constructor</li> <li>Copy assignment</li> </ul>"},{"location":"Pratybos/po%20U1/U4/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l reikia <code>if (this == &amp;kitas)</code> operator= ? A: Self-assignment (<code>k = k</code>) be \u0161ios patikros gali sunaikinti objekt\u0105 prie\u0161 kopijuojant!</p> <p>K: Kod\u0117l <code>return *this</code> operator= ? A: Kad veikt\u0173 chaining: <code>a = b = c</code> (de\u0161in\u0117 \u012f kair\u0119).</p> <p>K: Ar vector automati\u0161kai daro deep copy? A: Taip! <code>langai = kitas.langai</code> - vector kopijuoja visus elementus.</p> <p>K: Kod\u0117l <code>new Durys(*kitas.durys)</code>? A: <code>*kitas.durys</code> - dereferencing (gauti objekt\u0105), tada Durys copy constructor.</p> <p>K: Ar reikia <code>langai.clear()</code> operator= ? A: Ne (assignment perkraus), bet gera praktika (explicit cleanup).</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"Pratybos/po%20U1/U5-solution/","title":"U5: Sprendimas - Operatori\u0173 Perkrovimas ir I\u0161imtys","text":"<p>D\u0117stytojui: Pilnas sprendimas su operatoriais ir exceptions.</p>"},{"location":"Pratybos/po%20U1/U5-solution/#galutine-failu-struktura","title":"\ud83d\udcc1 Galutin\u0117 fail\u0173 strukt\u016bra","text":"<pre><code>U5/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 01/  \u2190 Basic + exceptions\n\u251c\u2500\u2500 02/  \u2190 Operatoriai\n\u2514\u2500\u2500 03/  \u2190 Paprastinimas + operator&lt;&lt;\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#1-1-zingsnis-basic-trupmena-isimtys","title":"1\ufe0f\u20e3 1 \u017eingsnis: Basic Trupmena + I\u0161imtys","text":""},{"location":"Pratybos/po%20U1/U5-solution/#trupmenah","title":"Trupmena.h:","text":"<pre><code>#ifndef TRUPMENA_H\n#define TRUPMENA_H\n\n#include &lt;stdexcept&gt;  // invalid_argument\n\nclass Trupmena {\nprivate:\n    int skaitiklis;\n    int vardiklis;\n\npublic:\n    // Konstruktorius (su validacija!)\n    Trupmena(int s, int v);\n\n    // Getters\n    int gautiSkaitikli() const;\n    int gautiVardikli() const;\n\n    // Spausdinimas\n    void spausdinti() const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>#include &lt;stdexcept&gt;</code> - b\u016btinas i\u0161imtims!</li> <li>\u2705 <code>invalid_argument</code> - standartin\u0117 C++ i\u0161imtis</li> <li>\u26a0\ufe0f Da\u017ena klaida: pamir\u0161ti <code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#trupmenacpp","title":"Trupmena.cpp:","text":"<pre><code>#include \"Trupmena.h\"\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Konstruktorius su validacija\nTrupmena::Trupmena(int s, int v) {\n    // VALIDACIJA: Vardiklis negali b\u016bti 0!\n    if (v == 0) {\n        throw invalid_argument(\"Vardiklis negali b\u016bti 0!\");\n    }\n\n    skaitiklis = s;\n    vardiklis = v;\n}\n\n// Getters\nint Trupmena::gautiSkaitikli() const {\n    return skaitiklis;\n}\n\nint Trupmena::gautiVardikli() const {\n    return vardiklis;\n}\n\n// Spausdinimas\nvoid Trupmena::spausdinti() const {\n    cout &lt;&lt; skaitiklis &lt;&lt; \"/\" &lt;&lt; vardiklis;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos_1","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>throw invalid_argument(\"...\")</code> - mesti i\u0161imt\u012f</li> <li>\u2705 Konstruktorius - geriausias vieta validacijai</li> <li>\ud83d\udca1 I\u0161imtis nutraukia konstruktori\u0173 \u2192 objektas nesukuriamas!</li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#maincpp","title":"main.cpp:","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Trupmena.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U5 \u017dingsnis 1: Basic + Exceptions ===\\n\" &lt;&lt; endl;\n\n    // TESTAS 1: Teisinga trupmena\n    cout &lt;&lt; \"--- Testas 1: Teisinga trupmena ---\" &lt;&lt; endl;\n    try {\n        Trupmena a(1, 2);\n        cout &lt;&lt; \"Sukurta trupmena: \";\n        a.spausdinti();\n        cout &lt;&lt; endl;\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"KLAIDA: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    // TESTAS 2: Blogas vardiklis (0)\n    cout &lt;&lt; \"\\n--- Testas 2: Blogas vardiklis (0) ---\" &lt;&lt; endl;\n    try {\n        Trupmena b(1, 0);  // Turi mesti i\u0161imt\u012f!\n        cout &lt;&lt; \"Sukurta trupmena: \";\n        b.spausdinti();\n        cout &lt;&lt; endl;\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"Sugauta i\u0161imtis: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    // TESTAS 3: Kelios trupmenos\n    cout &lt;&lt; \"\\n--- Testas 3: Kelios trupmenos ---\" &lt;&lt; endl;\n    try {\n        Trupmena x(3, 4);\n        Trupmena y(5, 6);\n\n        cout &lt;&lt; \"x = \";\n        x.spausdinti();\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; \"y = \";\n        y.spausdinti();\n        cout &lt;&lt; endl;\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"KLAIDA: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"\\n=== Programa t\u0119siasi po i\u0161im\u010di\u0173 ===\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#isvestis","title":"I\u0161vestis:","text":"<pre><code>=== U5 \u017dingsnis 1: Basic + Exceptions ===\n\n--- Testas 1: Teisinga trupmena ---\nSukurta trupmena: 1/2\n\n--- Testas 2: Blogas vardiklis (0) ---\nSugauta i\u0161imtis: Vardiklis negali b\u016bti 0!\n\n--- Testas 3: Kelios trupmenos ---\nx = 3/4\ny = 5/6\n\n=== Programa t\u0119siasi po i\u0161im\u010di\u0173 ===\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos_2","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>try { ... } catch (invalid_argument&amp; e) { ... }</code> - gaudymo sintaks\u0117</li> <li>\u2705 <code>e.what()</code> - gr\u0105\u017eina klaidos prane\u0161im\u0105</li> <li>\u2705 Programa nesustoja po i\u0161imties (jei catch'inama!)</li> <li>\ud83d\udca1 Be try-catch - programa kris (unhandled exception)</li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#makefile","title":"Makefile:","text":"<pre><code>CXX = g++\nCXXFLAGS = -Wall -std=c++11\n\nOBJS = main.o Trupmena.o\nTARGET = programa\n\nall: $(TARGET)\n\n$(TARGET): $(OBJS)\n    $(CXX) $(OBJS) -o $(TARGET)\n\nmain.o: main.cpp Trupmena.h\n    $(CXX) $(CXXFLAGS) -c main.cpp\n\nTrupmena.o: Trupmena.cpp Trupmena.h\n    $(CXX) $(CXXFLAGS) -c Trupmena.cpp\n\nclean:\n    rm -f $(OBJS) $(TARGET)\n\n.PHONY: all clean\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#2-2-zingsnis-operatoriai","title":"2\ufe0f\u20e3 2 \u017eingsnis: Operatoriai (+, +=, &lt;, ==)","text":""},{"location":"Pratybos/po%20U1/U5-solution/#trupmenah-papildymas","title":"Trupmena.h (papildymas):","text":"<pre><code>#ifndef TRUPMENA_H\n#define TRUPMENA_H\n\n#include &lt;stdexcept&gt;\n\nclass Trupmena {\nprivate:\n    int skaitiklis;\n    int vardiklis;\n\npublic:\n    Trupmena(int s, int v);\n\n    int gautiSkaitikli() const;\n    int gautiVardikli() const;\n    void spausdinti() const;\n\n    // NAUJI: Operatoriai\n    Trupmena operator+(const Trupmena&amp; kita) const;\n    Trupmena&amp; operator+=(const Trupmena&amp; kita);\n    bool operator&lt;(const Trupmena&amp; kita) const;\n    bool operator==(const Trupmena&amp; kita) const;\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#trupmenacpp-papildymas","title":"Trupmena.cpp (papildymas):","text":"<pre><code>// ... (ankstesni metodai) ...\n\n// operator+ (sud\u0117tis)\nTrupmena Trupmena::operator+(const Trupmena&amp; kita) const {\n    // a/b + c/d = (a*d + c*b) / (b*d)\n    int naujasSk = skaitiklis * kita.vardiklis + kita.skaitiklis * vardiklis;\n    int naujasVard = vardiklis * kita.vardiklis;\n\n    return Trupmena(naujasSk, naujasVard);\n}\n\n// operator+= (compound assignment)\nTrupmena&amp; Trupmena::operator+=(const Trupmena&amp; kita) {\n    // Naudojame operator+\n    *this = *this + kita;\n    return *this;\n}\n\n// operator&lt; (ma\u017eiau)\nbool Trupmena::operator&lt;(const Trupmena&amp; kita) const {\n    // a/b &lt; c/d  \u27fa  a*d &lt; c*b\n    return (skaitiklis * kita.vardiklis) &lt; (kita.skaitiklis * vardiklis);\n}\n\n// operator== (lygyb\u0117)\nbool Trupmena::operator==(const Trupmena&amp; kita) const {\n    // a/b == c/d  \u27fa  a*d == c*b\n    return (skaitiklis * kita.vardiklis) == (kita.skaitiklis * vardiklis);\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos_3","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>operator+</code> - const (nekei\u010dia objekto)</li> <li>\u2705 <code>operator+=</code> - ne const, gr\u0105\u017eina <code>&amp;</code> (nuorod\u0105)</li> <li>\u2705 Palyginimo operatoriai - const, gr\u0105\u017eina <code>bool</code></li> <li>\ud83d\udca1 Kry\u017eminis dauginimas - i\u0161vengia division by zero</li> <li>\u26a0\ufe0f Da\u017ena klaida: <code>operator+=</code> gr\u0105\u017eina <code>Trupmena</code> (ne <code>&amp;</code>)</li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#maincpp-testas","title":"main.cpp (testas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Trupmena.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U5 \u017dingsnis 2: Operatoriai ===\\n\" &lt;&lt; endl;\n\n    try {\n        // TESTAS 1: operator+\n        cout &lt;&lt; \"--- Testas 1: operator+ ---\" &lt;&lt; endl;\n        Trupmena a(1, 2);  // 1/2\n        Trupmena b(1, 4);  // 1/4\n\n        Trupmena c = a + b;  // operator+ !\n\n        cout &lt;&lt; \"a = \";\n        a.spausdinti();\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; \"b = \";\n        b.spausdinti();\n        cout &lt;&lt; endl;\n\n        cout &lt;&lt; \"a + b = \";\n        c.spausdinti();\n        cout &lt;&lt; \" (kol kas nepaprastinta)\" &lt;&lt; endl;\n\n        // TESTAS 2: operator+=\n        cout &lt;&lt; \"\\n--- Testas 2: operator+= ---\" &lt;&lt; endl;\n        Trupmena x(1, 3);  // 1/3\n        cout &lt;&lt; \"Prad\u017eioje x = \";\n        x.spausdinti();\n        cout &lt;&lt; endl;\n\n        Trupmena y(1, 6);  // 1/6\n        x += y;  // operator+= !\n\n        cout &lt;&lt; \"Po x += 1/6, x = \";\n        x.spausdinti();\n        cout &lt;&lt; endl;\n\n        // TESTAS 3: operator&lt;\n        cout &lt;&lt; \"\\n--- Testas 3: operator&lt; ---\" &lt;&lt; endl;\n        Trupmena p(1, 3);\n        Trupmena q(1, 2);\n\n        cout &lt;&lt; \"1/3 &lt; 1/2? \" &lt;&lt; (p &lt; q ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n        cout &lt;&lt; \"1/2 &lt; 1/3? \" &lt;&lt; (q &lt; p ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n\n        // TESTAS 4: operator==\n        cout &lt;&lt; \"\\n--- Testas 4: operator== ---\" &lt;&lt; endl;\n        Trupmena r(1, 2);\n        Trupmena s(2, 4);  // Tas pats kaip 1/2\n        Trupmena t(1, 3);  // Skirtingas\n\n        cout &lt;&lt; \"1/2 == 2/4? \" &lt;&lt; (r == s ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n        cout &lt;&lt; \"1/2 == 1/3? \" &lt;&lt; (r == t ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"KLAIDA: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#isvestis_1","title":"I\u0161vestis:","text":"<pre><code>=== U5 \u017dingsnis 2: Operatoriai ===\n\n--- Testas 1: operator+ ---\na = 1/2\nb = 1/4\na + b = 6/8 (kol kas nepaprastinta)\n\n--- Testas 2: operator+= ---\nPrad\u017eioje x = 1/3\nPo x += 1/6, x = 3/6\n\n--- Testas 3: operator&lt; ---\n1/3 &lt; 1/2? Taip\n1/2 &lt; 1/3? Ne\n\n--- Testas 4: operator== ---\n1/2 == 2/4? Taip  \u2190 Kry\u017eminis dauginimas veikia!\n1/2 == 1/3? Ne\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#3-3-zingsnis-paprastinimas-operator","title":"3\ufe0f\u20e3 3 \u017eingsnis: Paprastinimas + operator&lt;&lt;","text":""},{"location":"Pratybos/po%20U1/U5-solution/#trupmenah-galutine-versija","title":"Trupmena.h (galutin\u0117 versija):","text":"<pre><code>#ifndef TRUPMENA_H\n#define TRUPMENA_H\n\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\nclass Trupmena {\nprivate:\n    int skaitiklis;\n    int vardiklis;\n\n    // Private helper\n    int dbd(int a, int b) const;  // Did\u017eiausias bendrasis daliklis\n\npublic:\n    Trupmena(int s, int v);\n\n    int gautiSkaitikli() const;\n    int gautiVardikli() const;\n\n    void paprastinti();  // NAUJAS\n\n    // Operatoriai\n    Trupmena operator+(const Trupmena&amp; kita) const;\n    Trupmena&amp; operator+=(const Trupmena&amp; kita);\n    bool operator&lt;(const Trupmena&amp; kita) const;\n    bool operator==(const Trupmena&amp; kita) const;\n\n    // Friend funkcija operator&lt;&lt; (U\u017d klas\u0117s rib\u0173!)\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Trupmena&amp; t);\n};\n\n#endif\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos_4","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>dbd()</code> - private helper (internal)</li> <li>\u2705 <code>friend ostream&amp; operator&lt;&lt;(...)</code> - friend deklaracija</li> <li>\u2705 <code>std::ostream</code> - visas vardas (arba <code>using</code>)</li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#trupmenacpp-galutine-versija","title":"Trupmena.cpp (galutin\u0117 versija):","text":"<pre><code>#include \"Trupmena.h\"\n#include &lt;cmath&gt;  // abs()\n\nusing namespace std;\n\n// Private: DBD (Euklido algoritmas)\nint Trupmena::dbd(int a, int b) const {\n    a = abs(a);  // Absoliu\u010dios reik\u0161m\u0117s\n    b = abs(b);\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n\n    return a;\n}\n\n// Public: Paprastinimas\nvoid Trupmena::paprastinti() {\n    int d = dbd(skaitiklis, vardiklis);\n\n    if (d &gt; 1) {\n        skaitiklis /= d;\n        vardiklis /= d;\n    }\n}\n\n// Konstruktorius (su automatiniu paprastinimu!)\nTrupmena::Trupmena(int s, int v) {\n    if (v == 0) {\n        throw invalid_argument(\"Vardiklis negali b\u016bti 0!\");\n    }\n\n    skaitiklis = s;\n    vardiklis = v;\n\n    paprastinti();  // Automatinis paprastinimas!\n}\n\n// Getters (tie patys)\nint Trupmena::gautiSkaitikli() const {\n    return skaitiklis;\n}\n\nint Trupmena::gautiVardikli() const {\n    return vardiklis;\n}\n\n// Operatoriai (tie patys)\nTrupmena Trupmena::operator+(const Trupmena&amp; kita) const {\n    int naujasSk = skaitiklis * kita.vardiklis + kita.skaitiklis * vardiklis;\n    int naujasVard = vardiklis * kita.vardiklis;\n    return Trupmena(naujasSk, naujasVard);  // Automati\u0161kai paprastins!\n}\n\nTrupmena&amp; Trupmena::operator+=(const Trupmena&amp; kita) {\n    *this = *this + kita;\n    return *this;\n}\n\nbool Trupmena::operator&lt;(const Trupmena&amp; kita) const {\n    return (skaitiklis * kita.vardiklis) &lt; (kita.skaitiklis * vardiklis);\n}\n\nbool Trupmena::operator==(const Trupmena&amp; kita) const {\n    return (skaitiklis * kita.vardiklis) == (kita.skaitiklis * vardiklis);\n}\n\n// NAUJAS: operator&lt;&lt; (U\u017d klas\u0117s rib\u0173, friend!)\nostream&amp; operator&lt;&lt;(ostream&amp; out, const Trupmena&amp; t) {\n    out &lt;&lt; t.skaitiklis &lt;&lt; \"/\" &lt;&lt; t.vardiklis;\n    return out;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-pastabos_5","title":"Pedagogin\u0117s pastabos:","text":"<ul> <li>\u2705 <code>dbd()</code> - Euklido algoritmas (iteratyvus)</li> <li>\u2705 <code>abs()</code> - absoliu\u010dios reik\u0161m\u0117s (<code>#include &lt;cmath&gt;</code>)</li> <li>\u2705 <code>paprastinti()</code> kvie\u010diamas konstruktoriuje (automatinis!)</li> <li>\u2705 <code>operator&lt;&lt;</code> - u\u017e klas\u0117s rib\u0173 (ne <code>Trupmena::operator&lt;&lt;</code>)</li> <li>\u2705 Gr\u0105\u017eina <code>ostream&amp;</code> (chain'inimui: <code>cout &lt;&lt; a &lt;&lt; b</code>)</li> <li>\u26a0\ufe0f Kritin\u0117 klaida: <code>ostream&amp; Trupmena::operator&lt;&lt;(...)</code> - BLOGAI!</li> </ul>"},{"location":"Pratybos/po%20U1/U5-solution/#maincpp-galutinis-testas","title":"main.cpp (galutinis testas):","text":"<pre><code>#include &lt;iostream&gt;\n#include \"Trupmena.h\"\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"=== U5 \u017dingsnis 3: Paprastinimas + operator&lt;&lt; ===\\n\" &lt;&lt; endl;\n\n    try {\n        // TESTAS 1: Automatinis paprastinimas\n        cout &lt;&lt; \"--- Testas 1: Automatinis paprastinimas ---\" &lt;&lt; endl;\n        Trupmena a(6, 8);  // Tur\u0117t\u0173 paprastinti \u2192 3/4\n        cout &lt;&lt; \"6/8 = \" &lt;&lt; a &lt;&lt; \" (paprastinta)\" &lt;&lt; endl;  // operator&lt;&lt; !\n\n        Trupmena b(10, 15);  // \u2192 2/3\n        cout &lt;&lt; \"10/15 = \" &lt;&lt; b &lt;&lt; endl;\n\n        // TESTAS 2: Sud\u0117tis su paprastinimu\n        cout &lt;&lt; \"\\n--- Testas 2: Sud\u0117tis su paprastinimu ---\" &lt;&lt; endl;\n        Trupmena x(1, 2);\n        Trupmena y(1, 4);\n        Trupmena z = x + y;\n        cout &lt;&lt; \"1/2 + 1/4 = \" &lt;&lt; z &lt;&lt; \" (automati\u0161kai paprastinta)\" &lt;&lt; endl;\n\n        // TESTAS 3: Palyginimas po paprastinimo\n        cout &lt;&lt; \"\\n--- Testas 3: Palyginimas po paprastinimo ---\" &lt;&lt; endl;\n        Trupmena p(1, 2);\n        Trupmena q(2, 4);  // Paprastins \u2192 1/2\n\n        cout &lt;&lt; \"p = \" &lt;&lt; p &lt;&lt; endl;\n        cout &lt;&lt; \"q = \" &lt;&lt; q &lt;&lt; \" (i\u0161 2/4)\" &lt;&lt; endl;\n        cout &lt;&lt; \"p == q? \" &lt;&lt; (p == q ? \"Taip\" : \"Ne\") &lt;&lt; endl;\n\n        // TESTAS 4: Compound assignment\n        cout &lt;&lt; \"\\n--- Testas 4: Compound assignment ---\" &lt;&lt; endl;\n        Trupmena m(1, 3);\n        Trupmena n(1, 6);\n\n        cout &lt;&lt; \"m = \" &lt;&lt; m &lt;&lt; endl;\n        cout &lt;&lt; \"n = \" &lt;&lt; n &lt;&lt; endl;\n\n        m += n;  // 1/3 + 1/6 = 1/2\n        cout &lt;&lt; \"Po m += n, m = \" &lt;&lt; m &lt;&lt; endl;\n\n        // TESTAS 5: Chain output\n        cout &lt;&lt; \"\\n--- Testas 5: Chain output ---\" &lt;&lt; endl;\n        cout &lt;&lt; \"Kelios trupmenos: \" &lt;&lt; Trupmena(1, 2) &lt;&lt; \", \" \n             &lt;&lt; Trupmena(2, 3) &lt;&lt; \", \" &lt;&lt; Trupmena(3, 4) &lt;&lt; endl;\n\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"KLAIDA: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#isvestis_2","title":"I\u0161vestis:","text":"<pre><code>=== U5 \u017dingsnis 3: Paprastinimas + operator&lt;&lt; ===\n\n--- Testas 1: Automatinis paprastinimas ---\n6/8 = 3/4 (paprastinta)\n10/15 = 2/3\n\n--- Testas 2: Sud\u0117tis su paprastinimu ---\n1/2 + 1/4 = 3/4 (automati\u0161kai paprastinta)\n\n--- Testas 3: Palyginimas po paprastinimo ---\np = 1/2\nq = 1/2 (i\u0161 2/4)\np == q? Taip\n\n--- Testas 4: Compound assignment ---\nm = 1/3\nn = 1/6\nPo m += n, m = 1/2\n\n--- Testas 5: Chain output ---\nKelios trupmenos: 1/2, 2/3, 3/4\n</code></pre>"},{"location":"Pratybos/po%20U1/U5-solution/#pedagogines-gaires-destytojui","title":"\ud83c\udf93 Pedagogin\u0117s gair\u0117s d\u0117stytojui","text":""},{"location":"Pratybos/po%20U1/U5-solution/#tiketinos-studentu-klaidos","title":"Tik\u0117tinos student\u0173 klaidos:","text":"Klaida Da\u017enumas Sprendimas Pamir\u0161o <code>#include &lt;stdexcept&gt;</code> \u2b50\u2b50\u2b50\u2b50\u2b50 Compiler error: <code>invalid_argument</code> unknown <code>operator&lt;&lt;</code> kaip metodas (ne friend) \u2b50\u2b50\u2b50\u2b50\u2b50 Compiler error: prieiga prie private Pamir\u0161o <code>return out</code> operator&lt;&lt; \u2b50\u2b50\u2b50\u2b50 Chain neveikia: <code>cout &lt;&lt; a &lt;&lt; b</code> <code>operator+=</code> gr\u0105\u017eina <code>Trupmena</code> (ne <code>&amp;</code>) \u2b50\u2b50\u2b50 Neefektyvu, chain neveiks DBD be <code>abs()</code> \u2b50\u2b50\u2b50 Blogai su neigiamais skai\u010diais Try-catch sintaks\u0117 (<code>;</code> vietoj <code>{</code>) \u2b50\u2b50 Compiler error"},{"location":"Pratybos/po%20U1/U5-solution/#diskusijos-taskai","title":"Diskusijos ta\u0161kai:","text":"<ol> <li>I\u0161imtys vs error codes:</li> <li>I\u0161imtys: lengviau skaityti, nepraleisi klaidos</li> <li> <p>Error codes: senesnis stilius, manual checking</p> </li> <li> <p>Friend funkcijos:</p> </li> <li>Breaks encapsulation (trade-off!)</li> <li> <p>Alternatyva: getters (bet verbose: <code>out &lt;&lt; t.gautiSkaitikli()</code>)</p> </li> <li> <p>Operatori\u0173 konvencijos:</p> </li> <li>Member vs non-member (kada kuris?)</li> <li> <p><code>operator+</code> - const, <code>operator+=</code> - ne const</p> </li> <li> <p>DBD algoritmas:</p> </li> <li>Euklidas: eleganti\u0161ka, efektyvu (O(log n))</li> <li> <p>Iteratyvus vs rekursyvus</p> </li> <li> <p>Automatinis paprastinimas:</p> </li> <li>Trade-off: efektyvumas vs paprastumas</li> <li>Konstruktoriuje vs po operacij\u0173</li> </ol>"},{"location":"Pratybos/po%20U1/U5-solution/#prapletimai-stipriesiems","title":"Prapl\u0117timai stipriesiems:","text":"<ol> <li> <p>Daugiau operatori\u0173: <pre><code>Trupmena operator-(const Trupmena&amp; kita) const;  // Atimtis\nTrupmena operator*(const Trupmena&amp; kita) const;  // Daugyba\nTrupmena operator/(const Trupmena&amp; kita) const;  // Dalyba\n</code></pre></p> </li> <li> <p>I\u0161imtys dalyba i\u0161 0: <pre><code>Trupmena operator/(const Trupmena&amp; kita) const {\n    if (kita.skaitiklis == 0) {\n        throw invalid_argument(\"Dalyba i\u0161 0!\");\n    }\n    // ...\n}\n</code></pre></p> </li> <li> <p>Konvertavimas \u012f double: <pre><code>operator double() const {\n    return static_cast&lt;double&gt;(skaitiklis) / vardiklis;\n}\n</code></pre></p> </li> <li> <p>Neigiamos trupmenos: <pre><code>// Normalizuoti: neigiamas \u017eenklas tik skaitiklyje\nif (vardiklis &lt; 0) {\n    skaitiklis = -skaitiklis;\n    vardiklis = -vardiklis;\n}\n</code></pre></p> </li> <li> <p>operator&gt;&gt; (\u012fvestis):    <pre><code>friend istream&amp; operator&gt;&gt;(istream&amp; in, Trupmena&amp; t);\n</code></pre></p> </li> </ol>"},{"location":"Pratybos/po%20U1/U5-solution/#exception-handling-demonstracija","title":"\ud83d\udca1 Exception handling demonstracija","text":""},{"location":"Pratybos/po%20U1/U5-solution/#testas-be-try-catch-programa-krinta","title":"Testas be try-catch (programa krinta):","text":"<pre><code>int main() {\n    Trupmena a(1, 0);  // CRASH! (unhandled exception)\n    cout &lt;&lt; \"\u0160i eilut\u0117 NIEKADA nebus pasiekta\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>terminate called after throwing an instance of 'std::invalid_argument'\n  what():  Vardiklis negali b\u016bti 0!\nAborted (core dumped)\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5-solution/#testas-su-try-catch-programa-tesiasi","title":"Testas su try-catch (programa t\u0119siasi):","text":"<pre><code>int main() {\n    try {\n        Trupmena a(1, 0);  // Klaida!\n    } catch (invalid_argument&amp; e) {\n        cout &lt;&lt; \"Sugauta: \" &lt;&lt; e.what() &lt;&lt; endl;\n    }\n\n    cout &lt;&lt; \"Programa t\u0119siasi!\" &lt;&lt; endl;  // \u2190 Pasiekiama!\n    return 0;\n}\n</code></pre> <p>I\u0161vestis: <pre><code>Sugauta: Vardiklis negali b\u016bti 0!\nPrograma t\u0119siasi!\n</code></pre></p> <p>S\u0117km\u0117s d\u0117stant! \ud83c\udf93</p>"},{"location":"Pratybos/po%20U1/U5/","title":"U5: Operatori\u0173 Perkrovimas ir I\u0161imtys","text":"<p>Savait\u0117s: 9-10 Svoris: 1 balas Terminas: Savait\u0117s 10 pabaiga</p>"},{"location":"Pratybos/po%20U1/U5/#pries-pradedant","title":"\ud83d\udcda Prie\u0161 pradedant","text":"<p>Priminimas: Taikomi tie patys reikalavimai kaip U1-U4. \ud83d\udc49 \u017dr. U\u017eduo\u010di\u0173 Gidas</p>"},{"location":"Pratybos/po%20U1/U5/#uzduoties-tikslas","title":"\ud83c\udfaf U\u017eduoties tikslas","text":"<p>I\u0161mokti perkrauti operatorius (<code>+</code>, <code>+=</code>, <code>&lt;</code>, <code>==</code>, <code>&lt;&lt;</code>). Pirm\u0105 kart\u0105 naudoti i\u0161imtis (exceptions) validacijai ir klaid\u0173 tvarkymui. Dirbti su friend funkcijomis.</p>"},{"location":"Pratybos/po%20U1/U5/#mokymosi-tikslai","title":"\ud83d\udcda Mokymosi tikslai","text":"<p>Atlik\u0119 \u0161i\u0105 u\u017eduot\u012f, mok\u0117site:</p> <ul> <li>\u2705 Perkrauti aritmetinius operatorius (<code>+</code>, <code>+=</code>)</li> <li>\u2705 Perkrauti palyginimo operatorius (<code>&lt;</code>, <code>==</code>)</li> <li>\u2705 Perkrauti i\u0161vedimo operatori\u0173 (<code>&lt;&lt;</code>)</li> <li>\u2705 Naudoti friend funkcijas operatoriams</li> <li>\u2705 Mesti i\u0161imtis (<code>throw</code>) klaid\u0173 atvejais</li> <li>\u2705 Gaudyti i\u0161imtis (<code>try-catch</code>) saugiai</li> <li>\u2705 Implementuoti paprast\u0105 algoritm\u0105 (DBD - did\u017eiausias bendrasis daliklis)</li> </ul>"},{"location":"Pratybos/po%20U1/U5/#kas-yra-trupmena","title":"\ud83d\udca1 Kas yra Trupmena?","text":"<p>Trupmena - matematinis skai\u010dius \\(\\frac{skaitiklis}{vardiklis}\\).</p> <p>Pavyzd\u017eiai: - \\(\\frac{1}{2}\\) (viena pus\u0117) - \\(\\frac{3}{4}\\) (trys ketvirtadaliai) - \\(\\frac{5}{3}\\) (neteisinga trupmena)</p> <p>Operacijos: - Sud\u0117tis: \\(\\frac{1}{2} + \\frac{1}{4} = \\frac{3}{4}\\) - Palyginimas: \\(\\frac{1}{2} &lt; \\frac{3}{4}\\) - Paprastinimas: \\(\\frac{6}{8} = \\frac{3}{4}\\) (dalinti i\u0161 DBD=2)</p>"},{"location":"Pratybos/po%20U1/U5/#operatoriu-perkrovimas","title":"\ud83d\udca1 Operatori\u0173 perkrovimas","text":"<p>Operatori\u0173 perkrovimas - galimyb\u0117 naudoti standartin\u012f C++ operatori\u0173 (<code>+</code>, <code>==</code>, <code>&lt;&lt;</code>) su savomis klas\u0117mis.</p> <p>Pavyzdys: <pre><code>Trupmena a(1, 2);  // 1/2\nTrupmena b(1, 4);  // 1/4\n\nTrupmena c = a + b;  // Naudojame + operatori\u0173!\ncout &lt;&lt; c;           // Naudojame &lt;&lt; operatori\u0173!\n</code></pre></p> <p>Kod\u0117l naudinga? - Nat\u016brali sintaks\u0117 (kaip su <code>int</code>, <code>float</code>) - Lengviau skaityti kod\u0105 - Intuityvu matematikai</p>"},{"location":"Pratybos/po%20U1/U5/#kas-yra-exceptions-isimtys","title":"\ud83d\udca1 Kas yra Exceptions (I\u0161imtys)?","text":"<p>I\u0161imtys - mechanizmas prane\u0161ti apie klaidas programos vykdymo metu.</p> <p>Pavyzdys: <pre><code>Trupmena a(1, 0);  // KLAIDA: vardiklis negali b\u016bti 0!\n</code></pre></p> <p>Be i\u0161im\u010di\u0173: <pre><code>if (vardiklis == 0) {\n    cout &lt;&lt; \"KLAIDA!\" &lt;&lt; endl;\n    return;  // Bet kaip prane\u0161ti?\n}\n</code></pre></p> <p>Su i\u0161imtimis: <pre><code>if (vardiklis == 0) {\n    throw invalid_argument(\"Vardiklis negali b\u016bti 0!\");\n}\n</code></pre></p> <p>Gaudymas: <pre><code>try {\n    Trupmena a(1, 0);  // Klaida!\n} catch (invalid_argument&amp; e) {\n    cout &lt;&lt; \"Sugauta klaida: \" &lt;&lt; e.what() &lt;&lt; endl;\n}\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5/#uzduoties-zingsniai","title":"\ud83d\udccb U\u017eduoties \u017eingsniai","text":""},{"location":"Pratybos/po%20U1/U5/#1-zingsnis-basic-trupmena-isimtys","title":"1 \u017eingsnis: Basic Trupmena + I\u0161imtys","text":"<p>Direktorija: <code>U5/01/</code></p> <p>Reikalavimai:</p> <p>Sukurti Trupmena klas\u0119 su:</p> <p>Private nariai: <pre><code>int skaitiklis;\nint vardiklis;\n</code></pre></p> <p>Public metodai: <pre><code>// Konstruktorius\nTrupmena(int s, int v);\n\n// Getters\nint gautiSkaitikli() const;\nint gautiVardikli() const;\n\n// Spausdinimas\nvoid spausdinti() const;  // I\u0161veda: \"skaitiklis/vardiklis\"\n</code></pre></p> <p>Konstruktorius su validacija: <pre><code>Trupmena::Trupmena(int s, int v) {\n    // VALIDACIJA: Vardiklis negali b\u016bti 0!\n    if (v == 0) {\n        throw invalid_argument(\"Vardiklis negali b\u016bti 0!\");\n    }\n\n    skaitiklis = s;\n    vardiklis = v;\n}\n</code></pre></p> <p>main.cpp testas: <pre><code>// Testas 1: Teisingi parametrai\ncout &lt;&lt; \"--- Testas 1: Teisinga trupmena ---\" &lt;&lt; endl;\ntry {\n    Trupmena a(1, 2);\n    a.spausdinti();  // 1/2\n} catch (invalid_argument&amp; e) {\n    cout &lt;&lt; \"Klaida: \" &lt;&lt; e.what() &lt;&lt; endl;\n}\n\n// Testas 2: Neteisingi parametrai (vardiklis = 0)\ncout &lt;&lt; \"\\n--- Testas 2: Blogas vardiklis ---\" &lt;&lt; endl;\ntry {\n    Trupmena b(1, 0);  // Turi mesti i\u0161imt\u012f!\n    b.spausdinti();\n} catch (invalid_argument&amp; e) {\n    cout &lt;&lt; \"Sugauta klaida: \" &lt;&lt; e.what() &lt;&lt; endl;\n}\n\ncout &lt;&lt; \"\\nPrograma t\u0119siasi...\" &lt;&lt; endl;\n</code></pre></p> <p>Pavyzdys: <pre><code>--- Testas 1: Teisinga trupmena ---\n1/2\n\n--- Testas 2: Blogas vardiklis ---\nSugauta klaida: Vardiklis negali b\u016bti 0!\n\nPrograma t\u0119siasi...\n</code></pre></p> <p>Fail\u0173 strukt\u016bra: <pre><code>U5/01/\n\u251c\u2500\u2500 Trupmena.h\n\u251c\u2500\u2500 Trupmena.cpp\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 Makefile\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5/#2-zingsnis-operatoriai","title":"2 \u017eingsnis: Operatoriai (+, +=, &lt;, ==)","text":"<p>Direktorija: <code>U5/02/</code></p> <p>Reikalavimai:</p> <p>Prid\u0117ti operatorius:</p> <p>1. Sud\u0117ties operatorius (<code>+</code>): <pre><code>// Trupmena.h\nTrupmena operator+(const Trupmena&amp; kita) const;\n</code></pre></p> <p>Algoritmas: <pre><code>a/b + c/d = (a*d + c*b) / (b*d)\n</code></pre></p> <p>Implementacija: <pre><code>Trupmena Trupmena::operator+(const Trupmena&amp; kita) const {\n    int naujasSk = skaitiklis * kita.vardiklis + kita.skaitiklis * vardiklis;\n    int naujasVard = vardiklis * kita.vardiklis;\n    return Trupmena(naujasSk, naujasVard);\n}\n</code></pre></p> <p>2. Compound assignment (<code>+=</code>): <pre><code>// Trupmena.h\nTrupmena&amp; operator+=(const Trupmena&amp; kita);\n</code></pre></p> <p>Implementacija: <pre><code>Trupmena&amp; Trupmena::operator+=(const Trupmena&amp; kita) {\n    *this = *this + kita;  // Naudojame operator+\n    return *this;\n}\n</code></pre></p> <p>3. Palyginimo operatoriai: <pre><code>// Trupmena.h\nbool operator&lt;(const Trupmena&amp; kita) const;\nbool operator==(const Trupmena&amp; kita) const;\n</code></pre></p> <p>Algoritmas: <pre><code>a/b &lt; c/d  \u27fa  a*d &lt; c*b\na/b == c/d  \u27fa  a*d == c*b\n</code></pre></p> <p>Testas: <pre><code>Trupmena a(1, 2);  // 1/2\nTrupmena b(1, 4);  // 1/4\n\n// operator+\nTrupmena c = a + b;\ncout &lt;&lt; \"1/2 + 1/4 = \";\nc.spausdinti();  // 6/8 (v\u0117liau paprastinsime)\n\n// operator+=\na += b;\ncout &lt;&lt; \"Po += : \";\na.spausdinti();  // 6/8\n\n// Palyginimas\nTrupmena x(1, 2);\nTrupmena y(2, 4);\ncout &lt;&lt; \"1/2 == 2/4? \" &lt;&lt; (x == y ? \"Taip\" : \"Ne\") &lt;&lt; endl;  // Ne (kol kas!)\n\nTrupmena z(1, 3);\ncout &lt;&lt; \"1/3 &lt; 1/2? \" &lt;&lt; (z &lt; x ? \"Taip\" : \"Ne\") &lt;&lt; endl;  // Taip\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5/#3-zingsnis-paprastinimas-dbd-operator","title":"3 \u017eingsnis: Paprastinimas (DBD) + operator&lt;&lt;","text":"<p>Direktorija: <code>U5/03/</code></p> <p>Reikalavimai:</p> <p>1. DBD (Did\u017eiausias Bendrasis Daliklis):</p> <pre><code>// Private helper funkcija\nint Trupmena::dbd(int a, int b) const {\n    // Euklido algoritmas\n    a = abs(a);  // Absoliu\u010dios reik\u0161m\u0117s\n    b = abs(b);\n\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n</code></pre> <p>2. Paprastinimo metodas: <pre><code>// Public metodas\nvoid Trupmena::paprastinti() {\n    int d = dbd(skaitiklis, vardiklis);\n    skaitiklis /= d;\n    vardiklis /= d;\n}\n</code></pre></p> <p>3. Papildyti konstruktori\u0173: <pre><code>Trupmena::Trupmena(int s, int v) {\n    if (v == 0) {\n        throw invalid_argument(\"Vardiklis negali b\u016bti 0!\");\n    }\n\n    skaitiklis = s;\n    vardiklis = v;\n    paprastinti();  // Automatinis paprastinimas!\n}\n</code></pre></p> <p>4. operator&lt;&lt; (friend funkcija!):</p> <pre><code>// Trupmena.h\nclass Trupmena {\n    // ...\n\n    // Friend funkcija (ne metodas!)\n    friend ostream&amp; operator&lt;&lt;(ostream&amp; out, const Trupmena&amp; t);\n};\n\n// Trupmena.cpp (U\u017d klas\u0117s rib\u0173!)\nostream&amp; operator&lt;&lt;(ostream&amp; out, const Trupmena&amp; t) {\n    out &lt;&lt; t.skaitiklis &lt;&lt; \"/\" &lt;&lt; t.vardiklis;\n    return out;\n}\n</code></pre> <p>Testas: <pre><code>Trupmena a(6, 8);   // Automati\u0161kai paprastins \u2192 3/4\ncout &lt;&lt; \"6/8 paprastinta: \" &lt;&lt; a &lt;&lt; endl;  // operator&lt;&lt; !\n\nTrupmena b(1, 2);\nTrupmena c(1, 4);\nTrupmena d = b + c;\ncout &lt;&lt; \"1/2 + 1/4 = \" &lt;&lt; d &lt;&lt; endl;  // 3/4 (paprastinta!)\n\n// Palyginimas po paprastinimo\nTrupmena x(1, 2);\nTrupmena y(2, 4);  // Paprastins \u2192 1/2\ncout &lt;&lt; \"1/2 == 2/4? \" &lt;&lt; (x == y ? \"Taip\" : \"Ne\") &lt;&lt; endl;  // Taip!\n</code></pre></p> <p>Pavyzdys: <pre><code>6/8 paprastinta: 3/4\n1/2 + 1/4 = 3/4\n1/2 == 2/4? Taip\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5/#pateikimas","title":"\ud83d\udce6 Pateikimas","text":""},{"location":"Pratybos/po%20U1/U5/#gitlab-direktoriju-struktura","title":"GitLab direktorij\u0173 strukt\u016bra:","text":"<pre><code>cpp-2026/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 U1/, U2/, U3/, U4/\n\u2514\u2500\u2500 U5/\n    \u251c\u2500\u2500 README.md          \u2190 U\u017eduoties santrauka (PRIVALOMA)\n    \u251c\u2500\u2500 01/                \u2190 Basic + exceptions\n    \u2502   \u251c\u2500\u2500 Trupmena.h\n    \u2502   \u251c\u2500\u2500 Trupmena.cpp\n    \u2502   \u251c\u2500\u2500 main.cpp\n    \u2502   \u2514\u2500\u2500 Makefile\n    \u251c\u2500\u2500 02/                \u2190 Operatoriai (+, +=, &lt;, ==)\n    \u2502   \u2514\u2500\u2500 ... (visi failai)\n    \u2514\u2500\u2500 03/                \u2190 Paprastinimas + operator&lt;&lt; - FINAL\n        \u2514\u2500\u2500 ... (visi failai)\n</code></pre>"},{"location":"Pratybos/po%20U1/U5/#u5readmemd-sablonas","title":"U5/README.md \u0161ablonas:","text":"<p><pre><code># U5: Operatori\u0173 Perkrovimas ir I\u0161imtys\n\n**B\u016bsena**: \u2705 Atlikta  \n**Pateikta**: 2026-04-11\n\n---\n\n## \ud83d\udcdd \u017dingsniai\n\n| \u017dingsnis | Direktorija | Apra\u0161ymas |\n|----------|-------------|-----------|\n| 1 | `01/` | Basic Trupmena + exceptions validacijai |\n| 2 | `02/` | Operatoriai (+, +=, &lt;, ==) |\n| 3 | `03/` | Paprastinimas (DBD) + operator&lt;&lt; |\n\n---\n\n## \ud83e\uddea Testavimas\n\n**Testas 1 (I\u0161imtys)**:\n</code></pre> Trupmena(1, 0) \u2192 Sugauta klaida: Vardiklis negali b\u016bti 0! \u2705 VEIKIA <pre><code>**Testas 2 (Operatoriai)**:\n</code></pre> 1/2 + 1/4 = 3/4 1/2 &lt; 3/4 = Taip \u2705 VEIKIA <pre><code>**Testas 3 (Paprastinimas)**:\n</code></pre> 6/8 \u2192 3/4 (automati\u0161kai) 1/2 == 2/4 \u2192 Taip \u2705 VEIKIA <pre><code>---\n\n## \ud83d\udcad Pagrindin\u0117s \u012f\u017evalgos\n\n1. Operatori\u0173 perkrovimas - nat\u016brali sintaks\u0117\n2. I\u0161imtys - saugus klaid\u0173 tvarkymas\n3. Friend funkcijos - operator&lt;&lt; u\u017e klas\u0117s rib\u0173\n4. DBD algoritmas - Euklido metodas\n5. Automatinis paprastinimas konstruktoriuje\n</code></pre></p>"},{"location":"Pratybos/po%20U1/U5/#vertinimo-kriterijai","title":"\u2705 Vertinimo kriterijai","text":"Kriterijus Balai Programa kompiliuojasi be klaid\u0173 10% I\u0161imtys veikia (validacija) 20% operator+ veikia 15% operator+= veikia 10% operator&lt; ir operator== veikia 10% operator&lt;&lt; veikia (friend) 15% Paprastinimas (DBD) veikia 15% README.md su testais 5% TOTAL 100%"},{"location":"Pratybos/po%20U1/U5/#patarimai","title":"\ud83d\udca1 Patarimai","text":"<ol> <li>Exceptions:</li> <li><code>throw invalid_argument(\"message\")</code> - mesti</li> <li><code>try { ... } catch (invalid_argument&amp; e) { ... }</code> - gaudyti</li> <li> <p><code>#include &lt;stdexcept&gt;</code> - reikalingas!</p> </li> <li> <p>Operatoriai:</p> </li> <li>Member funkcijos: <code>+</code>, <code>+=</code>, <code>&lt;</code>, <code>==</code></li> <li> <p>Friend funkcija: <code>&lt;&lt;</code> (reikia prieigos prie private)</p> </li> <li> <p>DBD algoritmas:</p> </li> <li>Euklido metodas: while loop su <code>%</code></li> <li> <p>Naudoti <code>abs()</code> (absoliu\u010dios reik\u0161m\u0117s)</p> </li> <li> <p>operator&lt;&lt; formatas:</p> </li> <li><code>friend ostream&amp; operator&lt;&lt;(ostream&amp;, const Trupmena&amp;);</code></li> <li> <p>Implementuoti u\u017e klas\u0117s rib\u0173!</p> </li> <li> <p>Paprastinimas:</p> </li> <li>Kviesti <code>paprastinti()</code> konstruktoriuje</li> <li>Automatinis po kiekvienos operacijos</li> </ol>"},{"location":"Pratybos/po%20U1/U5/#naudingos-nuorodos","title":"\ud83d\udd17 Naudingos nuorodos","text":"<ul> <li>Operator overloading</li> <li>Exception handling</li> <li>Friend functions</li> </ul>"},{"location":"Pratybos/po%20U1/U5/#daznai-uzduodami-klausimai","title":"\u2753 Da\u017enai u\u017eduodami klausimai","text":"<p>K: Kod\u0117l operator&lt;&lt; - friend, o operator+ - ne? A: operator&lt;&lt; - u\u017e klas\u0117s rib\u0173 (<code>cout &lt;&lt; trupmena</code>), reikia prieigos prie private. operator+ - metodas (<code>trupmena1 + trupmena2</code>).</p> <p>K: Kas yra invalid_argument? A: Standartin\u0117 C++ i\u0161imties klas\u0117 (<code>&lt;stdexcept&gt;</code>). Naudojama neteisingiems argumentams.</p> <p>K: Kod\u0117l operator+= gr\u0105\u017eina nuorod\u0105 (<code>&amp;</code>)? A: Leid\u017eia chain'inim\u0105: <code>a += b += c;</code></p> <p>K: Ar reikia paprastinti po kiekvienos operacijos? A: Konstruktorius paprastina automati\u0161kai, bet gera praktika paprastinti ir po <code>operator+</code>.</p> <p>K: Kaip veikia DBD (Euklidas)? A: Iteratyviai: <code>a % b</code>, kol likutis 0. Pavyzdys: DBD(6,8) = 2.</p> <p>Daugiau klausim\u0173? \u2192 \u017dr. U\u017eduo\u010di\u0173 Gidas - DUK</p> <p>S\u0117km\u0117s! \ud83d\ude80</p>"},{"location":"arrays/array-evoliucija/","title":"Objekt\u0173 masyv\u0173 evoliucija C++: Nuo C masyv\u0173 iki STL konteineri\u0173","text":""},{"location":"arrays/array-evoliucija/#ivadas-kodel-objektu-masyvai-sudetingi","title":"\u012evadas: Kod\u0117l objekt\u0173 masyvai sud\u0117tingi?","text":"<p>Objekt\u0173 masyvai C++ kalboje yra viena i\u0161 sud\u0117tingiausi\u0173 tem\u0173, nes \u010dia susipina:</p> <ul> <li>Atminties valdymas (stekas vs heap)</li> <li>Objekt\u0173 gyvavimo ciklas (konstruktoriai/destruktoriai)</li> <li>Rodykli\u0173 semantika (rodykl\u0117 \u012f masyv\u0105 vs rodykli\u0173 masyvas)</li> <li>Polimorfizmas (virtual\u016bs metodai masyvo elementams)</li> <li>STL abstrakcijos (array, vector, smart_ptr)</li> </ul> <p>\u0160is vadovas naudoja evoliucin\u012f metod\u0105 - kiekvienas etapas sprend\u017eia ankstesnio problemas ir pristato nauj\u0105 koncept\u0105.</p>"},{"location":"arrays/array-evoliucija/#1-etapas-c-stiliaus-masyvai-su-objektais","title":"1 etapas: C stiliaus masyvai su objektais","text":""},{"location":"arrays/array-evoliucija/#koncepcija","title":"Koncepcija","text":"<p>Pradedame nuo papras\u010diausio - C stiliaus masyv\u0173 su objektais. \u010cia i\u0161kart matome pirm\u0105sias problemas.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_1.cpp - C stiliaus masyvas su objektais\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass Student {\npublic:\n    char name[50];\n    int age;\n    double grade;\n\n    // Konstruktorius\n    Student() {\n        strcpy(name, \"Unknown\");\n        age = 0;\n        grade = 0.0;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius\n    Student(const char* n, int a, double g) {\n        strcpy(name, n);\n        age = a;\n        grade = g;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== C stiliaus masyvas su objektais ===\\n\";\n\n    // \ud83d\udca5 PROBLEMA #1: Tik default konstruktorius!\n    Student students[3];  // Visi objektai sukurti su default konstruktoriumi\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // Reikia rankiniu b\u016bdu keisti duomenis\n    strcpy(students[0].name, \"Jonas\");\n    students[0].age = 20;\n    students[0].grade = 8.5;\n\n    strcpy(students[1].name, \"Petras\");\n    students[1].age = 21;\n    students[1].grade = 9.0;\n\n    strcpy(students[2].name, \"Marija\");\n    students[2].age = 19;\n    students[2].grade = 8.8;\n\n    std::cout &lt;&lt; \"\\n--- Po duomen\u0173 keitimo ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // \ud83d\udca5 PROBLEMA #2: Negalima perduoti \u012f funkcij\u0105 kaip objekto\n    // void process_students(Student students[3]) - neteisingas tipas!\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;  // \u010cia i\u0161kvie\u010diami destruktoriai\n}\n</code></pre> <p>Rezultatas: <pre><code>=== C stiliaus masyvas su objektais ===\n\ud83d\udcda Student konstruktorius: Unknown\n\ud83d\udcda Student konstruktorius: Unknown\n\ud83d\udcda Student konstruktorius: Unknown\n\n--- Pradinis masyvas ---\nStudent: Unknown, Age: 0, Grade: 0\nStudent: Unknown, Age: 0, Grade: 0\nStudent: Unknown, Age: 0, Grade: 0\n\n--- Po duomen\u0173 keitimo ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Destruktoriai ---\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#problemos-analize","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kkinimas Pasekm\u0117s Tik default konstruktorius <code>Student arr[3]</code> kvie\u010dia tik default konstruktori\u0173 Reikia rankiniu b\u016bdu keisti duomenis Masyvo tipo painiava <code>Student arr[3]</code> vs <code>Student* arr</code> Neteisingas funkcij\u0173 parametr\u0173 tipas N\u0117ra inicializacijos kontrol\u0117s Negalima sukurti su konkre\u010diais duomenimis Dvigubas darbas: sukurti + keisti C stiliaus stringai <code>char name[50]</code> + <code>strcpy</code> Nesaugus, riboto dyd\u017eio"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti, kad objekt\u0173 masyvas kvie\u010dia konstruktorius</li> <li>Matyti C stiliaus masyv\u0173 apribojimus</li> <li>Pa\u017einti destruktori\u0173 i\u0161kvietimo tvark\u0105 (atvirk\u0161\u010diai)</li> </ul>"},{"location":"arrays/array-evoliucija/#2-etapas-inicializacijos-sarasas-c11","title":"2 etapas: Inicializacijos s\u0105ra\u0161as (C++11)","text":""},{"location":"arrays/array-evoliucija/#koncepcija_1","title":"Koncepcija","text":"<p>C++11 \u012fved\u0117 inicializacijos s\u0105ra\u0161us, kurie leid\u017eia sukurti masyv\u0105 su konkre\u010diais duomenimis.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_1","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_2.cpp - Inicializacijos s\u0105ra\u0161as\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    // Default konstruktorius\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Copy konstruktorius\n    Student(const Student&amp; other) \n        : name(other.name), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\udccb Copy konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    const std::string&amp; get_name() const { return name; }\n};\n\n// Funkcija, kuri priima masyv\u0105\nvoid print_students(const Student students[], int count) {\n    std::cout &lt;&lt; \"\\n--- Funkcijoje print_students ---\\n\";\n    for (int i = 0; i &lt; count; i++) {\n        students[i].print();\n    }\n}\n\n// \ud83d\udca5 PROBLEMA: Neteisingas masyvo perdavimas\nvoid wrong_function(Student students[3]) {  // I\u0161 tikr\u0173j\u0173 Student*\n    std::cout &lt;&lt; \"sizeof(students) = \" &lt;&lt; sizeof(students) &lt;&lt; std::endl;  // 8 bytes (pointer)\n    std::cout &lt;&lt; \"Tikrasis sizeof(Student[3]) = \" &lt;&lt; sizeof(Student) * 3 &lt;&lt; std::endl;\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Inicializacijos s\u0105ra\u0161as ===\\n\";\n\n    // \u2705 C++11 inicializacijos s\u0105ra\u0161as\n    Student students[] = {\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8)\n    };\n\n    const int count = sizeof(students) / sizeof(students[0]);\n    std::cout &lt;&lt; \"Masyvo dydis: \" &lt;&lt; count &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (int i = 0; i &lt; count; i++) {\n        students[i].print();\n    }\n\n    // Funkcijos i\u0161kvietimas\n    print_students(students, count);\n\n    // Masyvo tipo demonstracija\n    std::cout &lt;&lt; \"\\n--- Masyvo tipo problema ---\\n\";\n    std::cout &lt;&lt; \"sizeof(students) main'e = \" &lt;&lt; sizeof(students) &lt;&lt; std::endl;\n    wrong_function(students);\n\n    // \ud83d\udca5 PROBLEMA: Negalima keisti masyvo dyd\u017eio\n    // students[3] = Student(\"Ona\", 22, 7.5);  // KLAIDA!\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Inicializacijos s\u0105ra\u0161as ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\nMasyvo dydis: 3\n\n--- Pradinis masyvas ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Funkcijoje print_students ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\n\n--- Masyvo tipo problema ---\nsizeof(students) main'e = 96\nsizeof(students) = 8\nTikrasis sizeof(Student[3]) = 96\n\n--- Destruktoriai ---\n\ud83d\uddd1\ufe0f Destruktorius: Marija\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#pagerejimai-ir-likusios-problemos","title":"\ud83d\udd0d Pager\u0117jimai ir likusios problemos","text":"Pager\u0117jimas Likusios problemos \u2705 Inicializacija su parametrais \u274c Fiksuotas dydis compile time \u2705 std::string vietoj char[] \u274c Masyvas \"virsta\" rodykle funkcijose \u2705 Automatinis dyd\u017eio skai\u010diavimas \u274c Negalima keisti dyd\u017eio runtime"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_1","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti inicializacijos s\u0105ra\u0161\u0173 sintaks\u0119</li> <li>Matyti masyvo \"virsmo\" rodykle problem\u0105</li> <li>Pa\u017einti sizeof trik\u012f masyvo dyd\u017eiui skai\u010diuoti</li> </ul>"},{"location":"arrays/array-evoliucija/#3-etapas-dinaminiai-masyvai-newdelete","title":"3 etapas: Dinaminiai masyvai (new/delete)","text":""},{"location":"arrays/array-evoliucija/#koncepcija_2","title":"Koncepcija","text":"<p>Kai reikia keisti masyvo dyd\u012f runtime, naudojame dinamin\u012f atminties paskirstym\u0105.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_2","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_3.cpp - Dinaminiai masyvai\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    // Setter metodai dinaminiam u\u017epildymui\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n;\n        age = a;\n        grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;  // Rodykl\u0117 \u012f dinamin\u012f masyv\u0105\n    int capacity;\n    int count;\n\npublic:\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: \" &lt;&lt; capacity &lt;&lt; std::endl;\n        students = new Student[capacity];  // \ud83d\udca5 Tik default konstruktoriai!\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;  // \u2705 Automati\u0161kai i\u0161kvie\u010dia vis\u0173 objekt\u0173 destruktorius\n    }\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- Visi studentai (\" &lt;&lt; count &lt;&lt; \"/\" &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n\n    // \ud83d\udca5 PROBLEMA: N\u0117ra copy konstruktoriaus ir assignment operatoriaus\n    // Shallow copy problema!\n};\n\n// Demonstracija su funkcija\nvoid test_dynamic_array() {\n    std::cout &lt;&lt; \"\\n=== Funkcijos scope testas ===\\n\";\n\n    StudentManager manager(2);\n    manager.add_student(\"Tomas\", 22, 7.8);\n    manager.add_student(\"Ona\", 20, 9.2);\n    manager.print_all();\n\n    // manager sunaikinamas \u010dia\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Dinaminiai masyvai ===\\n\";\n\n    // Paprastas dinaminis masyvas\n    int size;\n    std::cout &lt;&lt; \"\u012eveskite student\u0173 skai\u010di\u0173: \";\n    std::cin &gt;&gt; size;\n\n    Student* students = new Student[size];  // Default konstruktoriai\n\n    // U\u017epildymas duomenimis\n    for (int i = 0; i &lt; size; i++) {\n        std::string name = \"Student\" + std::to_string(i + 1);\n        students[i].set_data(name, 20 + i, 7.0 + i * 0.5);\n    }\n\n    std::cout &lt;&lt; \"\\n--- Dinaminis masyvas ---\\n\";\n    for (int i = 0; i &lt; size; i++) {\n        students[i].print();\n    }\n\n    delete[] students;  // \u2705 Destruktoriai i\u0161kvie\u010diami\n\n    // Objekto su dinaminiu masyvu testas\n    test_dynamic_array();\n\n    // \ud83d\udca5 SHALLOW COPY PROBLEMA\n    std::cout &lt;&lt; \"\\n=== Shallow copy problema ===\\n\";\n    {\n        StudentManager manager1(2);\n        manager1.add_student(\"Originalus\", 25, 8.0);\n\n        // StudentManager manager2 = manager1;  // \ud83d\udca5 CRASH! Double delete\n        // \u0160i eilut\u0117 sukelt\u0173 crash'\u0105, nes abu objektai bandyt\u0173 i\u0161trinti t\u0105 pat\u012f masyv\u0105\n    }\n\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Dinaminiai masyvai ===\n\u012eveskite student\u0173 skai\u010di\u0173: 3\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- Dinaminis masyvas ---\nStudent: Student1, Age: 20, Grade: 7\nStudent: Student2, Age: 21, Grade: 7.5\nStudent: Student3, Age: 22, Grade: 8\n\n\ud83d\uddd1\ufe0f Destruktorius: Student3\n\ud83d\uddd1\ufe0f Destruktorius: Student2\n\ud83d\uddd1\ufe0f Destruktorius: Student1\n\n=== Funkcijos scope testas ===\n\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: 2\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- Visi studentai (2/2) ---\nStudent: Tomas, Age: 22, Grade: 7.8\nStudent: Ona, Age: 20, Grade: 9.2\n\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Ona\n\ud83d\uddd1\ufe0f Destruktorius: Tomas\n\n=== Shallow copy problema ===\n\ud83c\udfd7\ufe0f Kuriamas StudentManager su capacity: 2\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Originalus\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#problemos-analize_1","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kkinimas Sprendimas Tik default konstruktoriai <code>new Student[n]</code> kvie\u010dia tik default Naudoti placement new arba vector Shallow copy Kompiliatorius sukuria shallow copy Implementuoti Rule of Three Memory leak rizika Pamir\u0161us <code>delete[]</code> - memory leak Naudoti RAII arba smart pointers Double delete Kopijavimas sukelia double delete Rule of Three arba delete copy"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_2","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Suprasti new[] ir delete[] sintaks\u0119</li> <li>Matyti shallow copy problem\u0105</li> <li>Pa\u017einti RAII princip\u0105 su dinaminiais masyvais</li> </ul>"},{"location":"arrays/array-evoliucija/#4-etapas-rule-of-three-implementacija","title":"4 etapas: Rule of Three implementacija","text":""},{"location":"arrays/array-evoliucija/#koncepcija_3","title":"Koncepcija","text":"<p>Kai klas\u0117 valdo dinaminius i\u0161teklius, reikia implementuoti Rule of Three: destruktori\u0173, copy konstruktori\u0173 ir assignment operatori\u0173.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_3","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_4.cpp - Rule of Three\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n; age = a; grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;\n    int capacity;\n    int count;\n\npublic:\n    // Konstruktorius\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: \" &lt;&lt; capacity &lt;&lt; \")\\n\";\n        students = new Student[capacity];\n    }\n\n    // 1. Destruktorius\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;\n    }\n\n    // 2. Copy konstruktorius (deep copy)\n    StudentManager(const StudentManager&amp; other) \n        : capacity(other.capacity), count(other.count) {\n        std::cout &lt;&lt; \"\ud83d\udccb StudentManager copy konstruktorius\\n\";\n\n        students = new Student[capacity];  // Naujas masyvas\n\n        // Kopijuojame duomenis\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];  // Student assignment\n        }\n    }\n\n    // 3. Assignment operatorius\n    StudentManager&amp; operator=(const StudentManager&amp; other) {\n        std::cout &lt;&lt; \"\ud83d\udcdd StudentManager assignment operatorius\\n\";\n\n        if (this == &amp;other) {  // Self-assignment apsauga\n            return *this;\n        }\n\n        // I\u0161valome sen\u0105 atmint\u012f\n        delete[] students;\n\n        // Kopijuojame nauj\u0105\n        capacity = other.capacity;\n        count = other.count;\n        students = new Student[capacity];\n\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];\n        }\n\n        return *this;\n    }\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; count &lt;&lt; \"/\" &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n\n    int get_count() const { return count; }\n};\n\n// Funkcija, kuri testuoja kopijavim\u0105\nStudentManager create_test_manager() {\n    std::cout &lt;&lt; \"\\n=== Funkcijoje create_test_manager ===\\n\";\n    StudentManager manager(3);\n    manager.add_student(\"Funkcijos studentas\", 23, 8.5);\n    return manager;  // Copy konstruktorius arba move (C++11)\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Rule of Three ===\\n\";\n\n    // Originalus objektas\n    StudentManager manager1(2);\n    manager1.add_student(\"Jonas\", 20, 8.5);\n    manager1.add_student(\"Petras\", 21, 9.0);\n    manager1.print_all();\n\n    // Copy konstruktorius testas\n    std::cout &lt;&lt; \"\\n=== Copy konstruktorius ===\\n\";\n    StudentManager manager2 = manager1;  // Copy konstruktorius\n    manager2.print_all();\n\n    // Assignment operatorius testas\n    std::cout &lt;&lt; \"\\n=== Assignment operatorius ===\\n\";\n    StudentManager manager3(1);\n    manager3.add_student(\"Marija\", 19, 8.8);\n    manager3.print_all();\n\n    manager3 = manager1;  // Assignment operatorius\n    manager3.print_all();\n\n    // Self-assignment testas\n    std::cout &lt;&lt; \"\\n=== Self-assignment testas ===\\n\";\n    manager1 = manager1;  // Turi b\u016bti saugus\n    manager1.print_all();\n\n    // Return by value testas\n    std::cout &lt;&lt; \"\\n=== Return by value testas ===\\n\";\n    StudentManager manager4 = create_test_manager();\n    manager4.print_all();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Rule of Three ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 2)\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Copy konstruktorius ===\n\ud83d\udccb StudentManager copy konstruktorius\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Assignment operatorius ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 1)\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (1/1) ---\nStudent: Marija, Age: 19, Grade: 8.8\n\n\ud83d\udcdd StudentManager assignment operatorius\n\ud83d\uddd1\ufe0f Destruktorius: Marija\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Self-assignment testas ===\n\ud83d\udcdd StudentManager assignment operatorius\n\n--- StudentManager (2/2) ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\n\n=== Return by value testas ===\n\n=== Funkcijoje create_test_manager ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: 3)\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\ud83d\udcda Default konstruktorius: Unknown\n\n--- StudentManager (1/3) ---\nStudent: Funkcijos studentas, Age: 23, Grade: 8.5\n\n=== Destruktoriai ===\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Funkcijos studentas\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n\ud83d\uddd1\ufe0f Destruktorius: Unknown\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f StudentManager destruktorius\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#rule-of-three-analize","title":"\ud83d\udd0d Rule of Three analiz\u0117","text":"Komponentas Paskirtis Kada i\u0161kvie\u010diamas Destruktorius Atlaisvina dinamin\u0119 atmint\u012f Objekto sunaikinimas Copy konstruktorius Deep copy suk\u016brimas <code>Type obj2 = obj1;</code> Assignment operatorius Deep copy priskyrimas <code>obj2 = obj1;</code>"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_3","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Implementuoti Rule of Three</li> <li>Suprasti deep copy vs shallow copy</li> <li>Matyti self-assignment apsaugos poreik\u012f</li> </ul>"},{"location":"arrays/array-evoliucija/#5-etapas-rodykliu-masyvas-vs-masyvo-rodykle","title":"5 etapas: Rodykli\u0173 masyvas vs masyvo rodykl\u0117","text":""},{"location":"arrays/array-evoliucija/#koncepcija_4","title":"Koncepcija","text":"<p>Viena i\u0161 did\u017eiausi\u0173 painiav\u0173 - skirtumas tarp \"rodykl\u0117s \u012f masyv\u0105\" ir \"rodykli\u0173 masyvo\". Ypa\u010d svarbu polimorfiniams objektams.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_4","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_5.cpp - Rodykli\u0173 semantika\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n\npublic:\n    Student(const std::string&amp; n, int a) : name(n), age(a) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, const std::string&amp; topic) \n        : Student(n, a), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nvoid demonstrate_array_types() {\n    std::cout &lt;&lt; \"\\n=== 1. Objekt\u0173 masyvas (stekas) ===\\n\";\n\n    // Objekt\u0173 masyvas - visi objektai sukurti steke\n    Student students_array[3] = {\n        Student(\"Jonas\", 20),\n        Student(\"Petras\", 21),\n        Student(\"Marija\", 19)\n    };\n\n    std::cout &lt;&lt; \"Masyvo dydis: \" &lt;&lt; sizeof(students_array) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Vieno objekto dydis: \" &lt;&lt; sizeof(Student) &lt;&lt; \" bytes\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        students_array[i].print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 2. Rodykl\u0117 \u012f masyv\u0105 ===\\n\";\n\n    // Rodykl\u0117 \u012f masyv\u0105 - rodo \u012f vis\u0105 masyv\u0105\n    Student (*ptr_to_array)[3] = &amp;students_array;\n\n    std::cout &lt;&lt; \"ptr_to_array dydis: \" &lt;&lt; sizeof(ptr_to_array) &lt;&lt; \" bytes (rodykl\u0117)\\n\";\n    std::cout &lt;&lt; \"(*ptr_to_array) dydis: \" &lt;&lt; sizeof(*ptr_to_array) &lt;&lt; \" bytes (masyvas)\\n\";\n\n    // Prieiga per rodykl\u0119 \u012f masyv\u0105\n    for (int i = 0; i &lt; 3; i++) {\n        (*ptr_to_array)[i].print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 3. Rodykli\u0173 masyvas (stekas) ===\\n\";\n\n    // Rodykli\u0173 masyvas - masyvas rodykli\u0173\n    Student* ptr_array[3];\n    ptr_array[0] = &amp;students_array[0];\n    ptr_array[1] = &amp;students_array[1];\n    ptr_array[2] = &amp;students_array[2];\n\n    std::cout &lt;&lt; \"ptr_array dydis: \" &lt;&lt; sizeof(ptr_array) &lt;&lt; \" bytes (3 rodykl\u0117s)\\n\";\n    std::cout &lt;&lt; \"Vienos rodykl\u0117s dydis: \" &lt;&lt; sizeof(Student*) &lt;&lt; \" bytes\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        ptr_array[i]-&gt;print();\n    }\n\n    std::cout &lt;&lt; \"\\n=== 4. Dinaminis rodykli\u0173 masyvas ===\\n\";\n\n    // Dinaminis rodykli\u0173 masyvas\n    Student** dynamic_ptr_array = new Student*[3];\n    dynamic_ptr_array[0] = new Student(\"Tomas\", 22);\n    dynamic_ptr_array[1] = new Student(\"Ona\", 20);\n    dynamic_ptr_array[2] = new Student(\"Lukas\", 23);\n\n    std::cout &lt;&lt; \"dynamic_ptr_array dydis: \" &lt;&lt; sizeof(dynamic_ptr_array) &lt;&lt; \" bytes (rodykl\u0117)\\n\";\n\n    for (int i = 0; i &lt; 3; i++) {\n        dynamic_ptr_array[i]-&gt;print();\n    }\n\n    // I\u0161valymas\n    for (int i = 0; i &lt; 3; i++) {\n        delete dynamic_ptr_array[i];\n    }\n    delete[] dynamic_ptr_array;\n}\n\nvoid demonstrate_polymorphism() {\n    std::cout &lt;&lt; \"\\n=== POLIMORFIZMAS ===\\n\";\n\n    // \ud83d\udca5 PROBLEMA: Objekt\u0173 masyvas su polimorfizmu\n    std::cout &lt;&lt; \"\\n--- Objekt\u0173 masyvas (object slicing!) ---\\n\";\n    Student mixed_array[3] = {\n        Student(\"Jonas\", 20),\n        GraduateStudent(\"Petras\", 25, \"AI Research\"),  // \ud83d\udca5 Object slicing!\n        Student(\"Marija\", 19)\n    };\n\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; mixed_array[i].get_type() &lt;&lt; \" - \";\n        mixed_array[i].print();  // Neteisingas polimorfizmas!\n    }\n\n    // \u2705 SPRENDIMAS: Rodykli\u0173 masyvas\n    std::cout &lt;&lt; \"\\n--- Rodykli\u0173 masyvas (teisingas polimorfizmas) ---\\n\";\n    Student* polymorphic_array[3];\n    polymorphic_array[0] = new Student(\"Jonas\", 20);\n    polymorphic_array[1] = new GraduateStudent(\"Petras\", 25, \"AI Research\");\n    polymorphic_array[2] = new Student(\"Marija\", 19);\n\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; polymorphic_array[i]-&gt;get_type() &lt;&lt; \" - \";\n        polymorphic_array[i]-&gt;print();  // \u2705 Teisingas polimorfizmas!\n    }\n\n    // I\u0161valymas\n    for (int i = 0; i &lt; 3; i++) {\n        delete polymorphic_array[i];\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Rodykli\u0173 semantika ===\\n\";\n\n    demonstrate_array_types();\n    demonstrate_polymorphism();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== Rodykli\u0173 semantika ===\n\n=== 1. Objekt\u0173 masyvas (stekas) ===\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\nMasyvo dydis: 96 bytes\nVieno objekto dydis: 32 bytes\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 2. Rodykl\u0117 \u012f masyv\u0105 ===\nptr_to_array dydis: 8 bytes (rodykl\u0117)\n(*ptr_to_array) dydis: 96 bytes (masyvas)\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 3. Rodykli\u0173 masyvas (stekas) ===\nptr_array dydis: 24 bytes (3 rodykl\u0117s)\nVienos rodykl\u0117s dydis: 8 bytes\n\nStudent: Jonas, Age: 20\nStudent: Petras, Age: 21\nStudent: Marija, Age: 19\n\n=== 4. Dinaminis rodykli\u0173 masyvas ===\n\ud83d\udcda Student konstruktorius: Tomas\n\ud83d\udcda Student konstruktorius: Ona\n\ud83d\udcda Student konstruktorius: Lukas\ndynamic_ptr_array dydis: 8 bytes (rodykl\u0117)\n\nStudent: Tomas, Age: 22\nStudent: Ona, Age: 20\nStudent: Lukas, Age: 23\n\n\ud83d\uddd1\ufe0f Student destruktorius: Lukas\n\ud83d\uddd1\ufe0f Student destruktorius: Ona\n\ud83d\uddd1\ufe0f Student destruktorius: Tomas\n\n=== POLIMORFIZMAS ===\n\n--- Objekt\u0173 masyvas (object slicing!) ---\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\n\nTipas: Student - Student: Jonas, Age: 20\nTipas: Student - Student: Petras, Age: 25\nTipas: Student - Student: Marija, Age: 19\n\n--- Rodykli\u0173 masyvas (teisingas polimorfizmas) ---\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\ud83d\udcda Student konstruktorius: Marija\n\nTipas: Student - Student: Jonas, Age: 20\nTipas: GraduateStudent - Graduate Student: Petras, Age: 25, Thesis: AI Research\nTipas: Student - Student: Marija, Age: 19\n\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n\n=== Destruktoriai ===\n\ud83d\uddd1\ufe0f Student destruktorius: Marija\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#rodykliu-semantikos-analize","title":"\ud83d\udd0d Rodykli\u0173 semantikos analiz\u0117","text":"Tipas Sintaks\u0117 Atminties vieta Polimorfizmas Naudojimas Objekt\u0173 masyvas <code>Student arr[3]</code> Stekas \u274c Object slicing Vienodo tipo objektai Rodykl\u0117 \u012f masyv\u0105 <code>Student (*ptr)[3]</code> Stekas \u274c Object slicing Retai naudojama Rodykli\u0173 masyvas <code>Student* arr[3]</code> Stekas/Heap \u2705 Veikia Polimorfizmas Dinaminis rodykli\u0173 masyvas <code>Student** arr</code> Heap \u2705 Veikia Dinaminis polimorfizmas"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_4","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Atskirti rodykl\u0119 \u012f masyv\u0105 nuo rodykli\u0173 masyvo</li> <li>Suprasti object slicing problem\u0105</li> <li>Matyti polimorfizmo poreik\u012f rodykli\u0173 masyvams</li> </ul>"},{"location":"arrays/array-evoliucija/#6-etapas-stl-stdarray","title":"6 etapas: STL std::array","text":""},{"location":"arrays/array-evoliucija/#koncepcija_5","title":"Koncepcija","text":"<p>C++11 \u012fved\u0117 <code>std::array</code> - saug\u0173 C masyv\u0173 pakaital\u0105 su STL funkcionalumu.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_5","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_6.cpp - std::array\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n\n    // Operatoriai palyginimui\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n\n    bool operator&gt;(const Student&amp; other) const {\n        return grade &gt; other.grade;\n    }\n};\n\nvoid demonstrate_std_array() {\n    std::cout &lt;&lt; \"\\n=== std::array demonstracija ===\\n\";\n\n    // \u2705 std::array su inicializacijos s\u0105ra\u0161u\n    std::array&lt;Student, 4&gt; students = {{\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8),\n        Student(\"Tomas\", 22, 7.5)\n    }};\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (const auto&amp; student : students) {  // Range-based for loop\n        student.print();\n    }\n\n    // STL algoritmai\n    std::cout &lt;&lt; \"\\n--- R\u016b\u0161iavimas pagal pa\u017eym\u012f ---\\n\";\n    std::sort(students.begin(), students.end());  // R\u016b\u0161iuoja pagal operator&lt;\n\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i + 1 &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // Paie\u0161ka\n    std::cout &lt;&lt; \"\\n--- Paie\u0161ka ---\\n\";\n    auto it = std::find_if(students.begin(), students.end(), \n        [](const Student&amp; s) { return s.get_grade() &gt; 8.7; });\n\n    if (it != students.end()) {\n        std::cout &lt;&lt; \"Rastas studentas su pa\u017eymiu &gt; 8.7: \";\n        it-&gt;print();\n    }\n\n    // Saugus prieigos metodas\n    std::cout &lt;&lt; \"\\n--- Saugi prieiga ---\\n\";\n    try {\n        std::cout &lt;&lt; \"students.at(2): \";\n        students.at(2).print();\n\n        // std::cout &lt;&lt; \"students.at(10): \";\n        // students.at(10).print();  // Mest\u0173 std::out_of_range\n    } catch (const std::out_of_range&amp; e) {\n        std::cout &lt;&lt; \"Klaida: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // Array informacija\n    std::cout &lt;&lt; \"\\n--- Array informacija ---\\n\";\n    std::cout &lt;&lt; \"Dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Maksimalus dydis: \" &lt;&lt; students.max_size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Tu\u0161\u010dias: \" &lt;&lt; (students.empty() ? \"Taip\" : \"Ne\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Duomen\u0173 rodykl\u0117: \" &lt;&lt; students.data() &lt;&lt; std::endl;\n}\n\n// Funkcija, kuri priima std::array\nvoid process_students(const std::array&lt;Student, 4&gt;&amp; students) {\n    std::cout &lt;&lt; \"\\n--- Funkcijoje process_students ---\\n\";\n    std::cout &lt;&lt; \"Gauto masyvo dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n\n    double total_grade = 0.0;\n    for (const auto&amp; student : students) {\n        total_grade += student.get_grade();\n    }\n\n    std::cout &lt;&lt; \"Vidutinis pa\u017eymys: \" &lt;&lt; total_grade / students.size() &lt;&lt; std::endl;\n}\n\n// Template funkcija bet kokio dyd\u017eio array\ntemplate&lt;size_t N&gt;\nvoid print_array_info(const std::array&lt;Student, N&gt;&amp; arr) {\n    std::cout &lt;&lt; \"\\n--- Template funkcija (dydis: \" &lt;&lt; N &lt;&lt; \") ---\\n\";\n    std::cout &lt;&lt; \"Array dydis: \" &lt;&lt; arr.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pirmasis studentas: \";\n    if (!arr.empty()) {\n        arr.front().print();\n    }\n    std::cout &lt;&lt; \"Paskutinis studentas: \";\n    if (!arr.empty()) {\n        arr.back().print();\n    }\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::array ===\\n\";\n\n    demonstrate_std_array();\n\n    // Funkcijos i\u0161kvietimas\n    std::array&lt;Student, 4&gt; test_students = {{\n        Student(\"A\", 20, 8.0),\n        Student(\"B\", 21, 9.0),\n        Student(\"C\", 19, 7.0),\n        Student(\"D\", 22, 8.5)\n    }};\n\n    process_students(test_students);\n\n    // Template funkcijos testas\n    std::array&lt;Student, 2&gt; small_array = {{\n        Student(\"X\", 25, 9.5),\n        Student(\"Y\", 24, 8.9)\n    }};\n\n    print_array_info(test_students);  // N = 4\n    print_array_info(small_array);   // N = 2\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas: <pre><code>=== STL std::array ===\n\n=== std::array demonstracija ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\n\ud83d\udcda Parametrinis konstruktorius: Tomas\n\n--- Pradinis masyvas ---\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nStudent: Marija, Age: 19, Grade: 8.8\nStudent: Tomas, Age: 22, Grade: 7.5\n\n--- R\u016b\u0161iavimas pagal pa\u017eym\u012f ---\n1. Student: Tomas, Age: 22, Grade: 7.5\n2. Student: Jonas, Age: 20, Grade: 8.5\n3. Student: Marija, Age: 19, Grade: 8.8\n4. Student: Petras, Age: 21, Grade: 9\n\n--- Paie\u0161ka ---\nRastas studentas su pa\u017eymiu &gt; 8.7: Student: Marija, Age: 19, Grade: 8.8\n\n--- Saugi prieiga ---\nstudents.at(2): Student: Marija, Age: 19, Grade: 8.8\n\n--- Array informacija ---\nDydis: 4\nMaksimalus dydis: 4\nTu\u0161\u010dias: Ne\nDuomen\u0173 rodykl\u0117: 0x7fff5fbff040\n\n\ud83d\udcda Parametrinis konstruktorius: A\n\ud83d\udcda Parametrinis konstruktorius: B\n\ud83d\udcda Parametrinis konstruktorius: C\n\ud83d\udcda Parametrinis konstruktorius: D\n\n--- Funkcijoje process_students ---\nGauto masyvo dydis: 4\nVidutinis pa\u017eymys: 8.125\n\n\ud83d\udcda Parametrinis konstruktorius: X\n\ud83d\udcda Parametrinis konstruktorius: Y\n\n--- Template funkcija (dydis: 4) ---\nArray dydis: 4\nPirmasis studentas: Student: A, Age: 20, Grade: 8\nPaskutinis studentas: Student: D, Age: 22, Grade: 8.5\n\n--- Template funkcija (dydis: 2) ---\nArray dydis: 2\nPirmasis studentas: Student: X, Age: 25, Grade: 9.5\nPaskutinis studentas: Student: Y, Age: 24, Grade: 8.9\n\n=== Destruktoriai ===\n[Destruktori\u0173 seka...]\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#stdarray-privalumai","title":"\ud83d\udd0d std::array privalumai","text":"Funkcija C masyvas std::array Dyd\u017eio \u017einojimas <code>sizeof(arr)/sizeof(arr[0])</code> <code>arr.size()</code> Saugi prieiga \u274c N\u0117ra \u2705 <code>at()</code> metodas STL algoritmai \u274c Reikia rodykli\u0173 \u2705 <code>begin()/end()</code> Range-based for \u274c Neveikia \u2705 Veikia Funkcij\u0173 parametrai Virsta rodykle I\u0161laiko tip\u0105 Template palaikymas \u274c Sud\u0117tinga \u2705 Nat\u016bralus"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_5","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti std::array vietoj C masyv\u0173</li> <li>Taikyti STL algoritmus</li> <li>Suprasti template funkcij\u0173 privalumus</li> </ul>"},{"location":"arrays/array-evoliucija/#7-etapas-stl-stdvector","title":"7 etapas: STL std::vector","text":""},{"location":"arrays/array-evoliucija/#koncepcija_6","title":"Koncepcija","text":"<p><code>std::vector</code> - dinaminis masyvas su automati\u0161ku dyd\u017eio valdymu ir RAII principais.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_6","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_7.cpp - std::vector\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;memory&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Copy konstruktorius\n    Student(const Student&amp; other) \n        : name(other.name), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\udccb Copy konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Move konstruktorius (C++11)\n    Student(Student&amp;&amp; other) noexcept\n        : name(std::move(other.name)), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\ude9a Move konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n        other.name = \"Moved\";\n        other.age = 0;\n        other.grade = 0.0;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n};\n\nvoid demonstrate_vector_basics() {\n    std::cout &lt;&lt; \"\\n=== Vector pagrindai ===\\n\";\n\n    // Tu\u0161\u010dias vector\n    std::vector&lt;Student&gt; students;\n    std::cout &lt;&lt; \"Pradinis dydis: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Pradinis capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Prid\u0117jimas su emplace_back (C++11)\n    std::cout &lt;&lt; \"\\n--- emplace_back ---\\n\";\n    students.emplace_back(\"Jonas\", 20, 8.5);    // Konstruojama vietoje\n    students.emplace_back(\"Petras\", 21, 9.0);\n    students.emplace_back(\"Marija\", 19, 8.8);\n\n    std::cout &lt;&lt; \"Po prid\u0117jimo - dydis: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Prid\u0117jimas su push_back\n    std::cout &lt;&lt; \"\\n--- push_back ---\\n\";\n    Student temp_student(\"Tomas\", 22, 7.5);\n    students.push_back(temp_student);  // Copy\n    students.push_back(Student(\"Ona\", 20, 9.2));  // Move\n\n    std::cout &lt;&lt; \"Po push_back - dydis: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Spausdinimas\n    std::cout &lt;&lt; \"\\n--- Visi studentai ---\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i + 1 &lt;&lt; \". \";\n        students[i].print();\n    }\n}\n\nvoid demonstrate_vector_operations() {\n    std::cout &lt;&lt; \"\\n=== Vector operacijos ===\\n\";\n\n    // Inicializacija su dyd\u017eiu\n    std::vector&lt;Student&gt; students(3);  // 3 default objektai\n    std::cout &lt;&lt; \"Vector su 3 default objektais sukurtas\\n\";\n\n    // U\u017epildymas duomenimis\n    students[0] = Student(\"A\", 20, 8.0);  // Assignment\n    students[1] = Student(\"B\", 21, 9.0);\n    students[2] = Student(\"C\", 19, 7.0);\n\n    std::cout &lt;&lt; \"\\n--- Po assignment ---\\n\";\n    for (const auto&amp; student : students) {\n        student.print();\n    }\n\n    // \u012eterpimas\n    std::cout &lt;&lt; \"\\n--- Insert operacija ---\\n\";\n    auto it = students.begin() + 1;  // Antra pozicija\n    students.insert(it, Student(\"Inserted\", 23, 8.7));\n\n    std::cout &lt;&lt; \"Po insert:\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // \u0160alinimas\n    std::cout &lt;&lt; \"\\n--- Erase operacija ---\\n\";\n    students.erase(students.begin() + 2);  // \u0160aliname tre\u010di\u0105 element\u0105\n\n    std::cout &lt;&lt; \"Po erase:\\n\";\n    for (const auto&amp; student : students) {\n        student.print();\n    }\n\n    // Dyd\u017eio keitimas\n    std::cout &lt;&lt; \"\\n--- Resize operacija ---\\n\";\n    std::cout &lt;&lt; \"Prie\u0161 resize: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    students.resize(6);  // Prid\u0117s 3 default objektus\n    std::cout &lt;&lt; \"Po resize(6): \" &lt;&lt; students.size() &lt;&lt; std::endl;\n\n    students.resize(2);  // Pa\u0161alins 4 objektus\n    std::cout &lt;&lt; \"Po resize(2): \" &lt;&lt; students.size() &lt;&lt; std::endl;\n}\n\nvoid demonstrate_vector_memory() {\n    std::cout &lt;&lt; \"\\n=== Vector atminties valdymas ===\\n\";\n\n    std::vector&lt;Student&gt; students;\n    students.reserve(10);  // Rezervuojame viet\u0105 10 objekt\u0173\n\n    std::cout &lt;&lt; \"Po reserve(10) - size: \" &lt;&lt; students.size() \n              &lt;&lt; \", capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n\n    // Stebime capacity poky\u010dius\n    for (int i = 0; i &lt; 15; i++) {\n        size_t old_capacity = students.capacity();\n        students.emplace_back(\"Student\" + std::to_string(i), 20 + i, 7.0 + i * 0.1);\n\n        if (students.capacity() != old_capacity) {\n            std::cout &lt;&lt; \"Capacity pakito: \" &lt;&lt; old_capacity \n                      &lt;&lt; \" -&gt; \" &lt;&lt; students.capacity() \n                      &lt;&lt; \" (size: \" &lt;&lt; students.size() &lt;&lt; \")\\n\";\n        }\n    }\n\n    // Atminties optimizacija\n    std::cout &lt;&lt; \"\\n--- Atminties optimizacija ---\\n\";\n    std::cout &lt;&lt; \"Prie\u0161 shrink_to_fit - capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n    students.shrink_to_fit();\n    std::cout &lt;&lt; \"Po shrink_to_fit - capacity: \" &lt;&lt; students.capacity() &lt;&lt; std::endl;\n}\n\n// Vector su polimorfizmu\nvoid demonstrate_polymorphic_vector() {\n    std::cout &lt;&lt; \"\\n=== Polimorfinis vector ===\\n\";\n\n    // Vector su smart pointers polimorfizmui\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; polymorphic_students;\n\n    polymorphic_students.push_back(std::make_unique&lt;Student&gt;(\"Jonas\", 20, 8.5));\n    polymorphic_students.push_back(std::make_unique&lt;Student&gt;(\"Petras\", 21, 9.0));\n\n    std::cout &lt;&lt; \"Polimorfinis vector su smart pointers:\\n\";\n    for (const auto&amp; student_ptr : polymorphic_students) {\n        student_ptr-&gt;print();\n    }\n\n    // Automatinis cleanup su unique_ptr\n    std::cout &lt;&lt; \"Smart pointers automati\u0161kai i\u0161valys atmint\u012f\\n\";\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::vector ===\\n\";\n\n    demonstrate_vector_basics();\n    demonstrate_vector_operations();\n    demonstrate_vector_memory();\n    demonstrate_polymorphic_vector();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas (sutrumpinta): <pre><code>=== STL std::vector ===\n\n=== Vector pagrindai ===\nPradinis dydis: 0\nPradinis capacity: 0\n\n--- emplace_back ---\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\n\ud83d\udcda Parametrinis konstruktorius: Marija\nPo prid\u0117jimo - dydis: 3, capacity: 4\n\n--- push_back ---\n\ud83d\udcda Parametrinis konstruktorius: Tomas\n\ud83d\udccb Copy konstruktorius: Tomas\n\ud83d\udcda Parametrinis konstruktorius: Ona\n\ud83d\ude9a Move konstruktorius: Ona\nPo push_back - dydis: 5, capacity: 8\n\n=== Vector atminties valdymas ===\nPo reserve(10) - size: 0, capacity: 10\nCapacity pakito: 10 -&gt; 20 (size: 11)\n\n--- Atminties optimizacija ---\nPrie\u0161 shrink_to_fit - capacity: 20\nPo shrink_to_fit - capacity: 15\n\n=== Polimorfinis vector ===\n\ud83d\udcda Parametrinis konstruktorius: Jonas\n\ud83d\udcda Parametrinis konstruktorius: Petras\nPolimorfinis vector su smart pointers:\nStudent: Jonas, Age: 20, Grade: 8.5\nStudent: Petras, Age: 21, Grade: 9\nSmart pointers automati\u0161kai i\u0161valys atmint\u012f\n\ud83d\uddd1\ufe0f Destruktorius: Petras\n\ud83d\uddd1\ufe0f Destruktorius: Jonas\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#stdvector-privalumai","title":"\ud83d\udd0d std::vector privalumai","text":"Funkcija Dinaminis masyvas (new[]) std::vector Atminties valdymas Rankinis new[]/delete[] Automatinis RAII Dyd\u017eio keitimas Reikia perkurti <code>resize()</code>, <code>push_back()</code> Saugi prieiga \u274c N\u0117ra \u2705 <code>at()</code> metodas STL algoritmai \u274c Reikia rodykli\u0173 \u2705 Pilnas palaikymas Exception safety \u274c Memory leaks \u2705 RAII apsauga Performance Grei\u010diausias Beveik toks pat"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_6","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti std::vector vietoj dinamini\u0173 masyv\u0173</li> <li>Suprasti capacity vs size skirtumus</li> <li>Taikyti smart pointers polimorfizmui</li> </ul>"},{"location":"arrays/array-evoliucija/#8-etapas-smart-pointers-su-objektu-masyvais","title":"8 etapas: Smart pointers su objekt\u0173 masyvais","text":""},{"location":"arrays/array-evoliucija/#koncepcija_7","title":"Koncepcija","text":"<p>Modern C++ (C++11+) rekomenduoja naudoti smart pointers vietoj raw pointers, ypa\u010d objekt\u0173 masyvams su polimorfizmu.</p>"},{"location":"arrays/array-evoliucija/#kodas-ir-analize_7","title":"Kodas ir analiz\u0117","text":"<pre><code>// student_8.cpp - Smart pointers\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;array&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, double g, const std::string&amp; topic) \n        : Student(n, a, g), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nclass StudentManager {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n\npublic:\n    StudentManager() {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius\\n\";\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        // unique_ptr automati\u0161kai i\u0161valo objektus\n    }\n\n    // Move-only semantics (unique_ptr negalima kopijuoti)\n    StudentManager(const StudentManager&amp;) = delete;\n    StudentManager&amp; operator=(const StudentManager&amp;) = delete;\n\n    // Move konstruktorius ir assignment\n    StudentManager(StudentManager&amp;&amp;) = default;\n    StudentManager&amp; operator=(StudentManager&amp;&amp;) = default;\n\n    void add_student(std::unique_ptr&lt;Student&gt; student) {\n        students.push_back(std::move(student));\n    }\n\n    template&lt;typename StudentType, typename... Args&gt;\n    void emplace_student(Args&amp;&amp;... args) {\n        students.push_back(std::make_unique&lt;StudentType&gt;(std::forward&lt;Args&gt;(args)...));\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; students.size() &lt;&lt; \" student\u0173) ---\\n\";\n        for (const auto&amp; student : students) {\n            std::cout &lt;&lt; \"Tipas: \" &lt;&lt; student-&gt;get_type() &lt;&lt; \" - \";\n            student-&gt;print();\n        }\n    }\n\n    void remove_student(size_t index) {\n        if (index &lt; students.size()) {\n            std::cout &lt;&lt; \"\u0160alinamas studentas: \" &lt;&lt; students[index]-&gt;get_name() &lt;&lt; std::endl;\n            students.erase(students.begin() + index);\n        }\n    }\n\n    size_t size() const { return students.size(); }\n};\n\nvoid demonstrate_unique_ptr() {\n    std::cout &lt;&lt; \"\\n=== unique_ptr demonstracija ===\\n\";\n\n    // Sukuriame unique_ptr objektus\n    auto student1 = std::make_unique&lt;Student&gt;(\"Jonas\", 20, 8.5);\n    auto grad_student = std::make_unique&lt;GraduateStudent&gt;(\"Petras\", 25, 9.0, \"AI Research\");\n\n    std::cout &lt;&lt; \"\\n--- Objektai sukurti ---\\n\";\n    student1-&gt;print();\n    grad_student-&gt;print();\n\n    // Perduodame ownership \u012f vector\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n    students.push_back(std::move(student1));  // student1 dabar nullptr\n    students.push_back(std::move(grad_student));\n\n    std::cout &lt;&lt; \"\\n--- Po move \u012f vector ---\\n\";\n    std::cout &lt;&lt; \"student1 yra nullptr: \" &lt;&lt; (student1 == nullptr ? \"Taip\" : \"Ne\") &lt;&lt; std::endl;\n\n    for (const auto&amp; student : students) {\n        student-&gt;print();\n    }\n\n    // Automatinis cleanup\n    std::cout &lt;&lt; \"\\n--- Vector sunaikinamas ---\\n\";\n}\n\nvoid demonstrate_shared_ptr() {\n    std::cout &lt;&lt; \"\\n=== shared_ptr demonstracija ===\\n\";\n\n    // Sukuriame shared_ptr objektus\n    auto student1 = std::make_shared&lt;Student&gt;(\"Marija\", 19, 8.8);\n    auto student2 = std::make_shared&lt;GraduateStudent&gt;(\"Tomas\", 24, 9.2, \"Machine Learning\");\n\n    std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;\n\n    // Dalijam\u0117s ownership\n    {\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group1;\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group2;\n\n        group1.push_back(student1);\n        group1.push_back(student2);\n\n        group2.push_back(student1);  // Tas pats objektas dviejuose vector'iuose\n\n        std::cout &lt;&lt; \"\\nPo prid\u0117jimo \u012f vector'ius:\\n\";\n        std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;  // 2\n        std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;  // 1\n\n        std::cout &lt;&lt; \"\\n--- group1 ---\\n\";\n        for (const auto&amp; student : group1) {\n            student-&gt;print();\n        }\n\n        std::cout &lt;&lt; \"\\n--- group2 ---\\n\";\n        for (const auto&amp; student : group2) {\n            student-&gt;print();\n        }\n\n        std::cout &lt;&lt; \"\\n--- Vector'iai sunaikinami ---\\n\";\n    }\n\n    std::cout &lt;&lt; \"\\nPo vector'i\u0173 sunaikinimo:\\n\";\n    std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; std::endl;  // 1\n    std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; std::endl;  // 1\n}\n\nvoid demonstrate_student_manager() {\n    std::cout &lt;&lt; \"\\n=== StudentManager su smart pointers ===\\n\";\n\n    StudentManager manager;\n\n    // Prid\u0117jimas su make_unique\n    manager.add_student(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\n    manager.add_student(std::make_unique&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"Data Science\"));\n\n    // Prid\u0117jimas su emplace\n    manager.emplace_student&lt;Student&gt;(\"C\", 21, 7.5);\n    manager.emplace_student&lt;GraduateStudent&gt;(\"D\", 26, 8.8, \"Robotics\");\n\n    manager.print_all();\n\n    // \u0160alinimas\n    std::cout &lt;&lt; \"\\n--- \u0160alinamas studentas ---\\n\";\n    manager.remove_student(1);  // \u0160aliname \"B\"\n\n    manager.print_all();\n\n    // Move semantics testas\n    std::cout &lt;&lt; \"\\n--- Move semantics ---\\n\";\n    StudentManager manager2 = std::move(manager);  // Move constructor\n\n    std::cout &lt;&lt; \"Originalus manager dydis: \" &lt;&lt; manager.size() &lt;&lt; std::endl;  // 0\n    std::cout &lt;&lt; \"Naujas manager2 dydis: \" &lt;&lt; manager2.size() &lt;&lt; std::endl;    // 3\n\n    manager2.print_all();\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Smart pointers su objekt\u0173 masyvais ===\\n\";\n\n    demonstrate_unique_ptr();\n    demonstrate_shared_ptr();\n    demonstrate_student_manager();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre> <p>Rezultatas (sutrumpinta): <pre><code>=== Smart pointers su objekt\u0173 masyvais ===\n\n=== unique_ptr demonstracija ===\n\ud83d\udcda Student konstruktorius: Jonas\n\ud83d\udcda Student konstruktorius: Petras\n\ud83c\udf93 GraduateStudent konstruktorius: Petras\n\n--- Objektai sukurti ---\nStudent: Jonas, Age: 20, Grade: 8.5\nGraduate Student: Petras, Age: 25, Grade: 9, Thesis: AI Research\n\n--- Po move \u012f vector ---\nstudent1 yra nullptr: Taip\nStudent: Jonas, Age: 20, Grade: 8.5\nGraduate Student: Petras, Age: 25, Grade: 9, Thesis: AI Research\n\n--- Vector sunaikinamas ---\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Petras\n\ud83d\uddd1\ufe0f Student destruktorius: Jonas\n\n=== shared_ptr demonstracija ===\n\ud83d\udcda Student konstruktorius: Marija\n\ud83d\udcda Student konstruktorius: Tomas\n\ud83c\udf93 GraduateStudent konstruktorius: Tomas\nstudent1 use_count: 1\nstudent2 use_count: 1\n\nPo prid\u0117jimo \u012f vector'ius:\nstudent1 use_count: 2\nstudent2 use_count: 1\n\nPo vector'i\u0173 sunaikinimo:\nstudent1 use_count: 1\nstudent2 use_count: 1\n\n=== StudentManager su smart pointers ===\n\ud83c\udfd7\ufe0f StudentManager konstruktorius\n\ud83d\udcda Student konstruktorius: A\n\ud83d\udcda Student konstruktorius: B\n\ud83c\udf93 GraduateStudent konstruktorius: B\n\ud83d\udcda Student konstruktorius: C\n\ud83d\udcda Student konstruktorius: D\n\ud83c\udf93 GraduateStudent konstruktorius: D\n\n--- StudentManager (4 student\u0173) ---\nTipas: Student - Student: A, Age: 20, Grade: 8\nTipas: GraduateStudent - Graduate Student: B, Age: 25, Grade: 9, Thesis: Data Science\nTipas: Student - Student: C, Age: 21, Grade: 7.5\nTipas: GraduateStudent - Graduate Student: D, Age: 26, Grade: 8.8, Thesis: Robotics\n\n--- \u0160alinamas studentas ---\n\u0160alinamas studentas: B\n\ud83d\uddd1\ufe0f GraduateStudent destruktorius: B\n\ud83d\uddd1\ufe0f Student destruktorius: B\n\n--- Move semantics ---\nOriginalus manager dydis: 0\nNaujas manager2 dydis: 3\n</code></pre></p>"},{"location":"arrays/array-evoliucija/#smart-pointers-palyginimas","title":"\ud83d\udd0d Smart pointers palyginimas","text":"Tipas Ownership Kopijavimas Naudojimas unique_ptr Vienasmen\u0117 \u274c Tik move Objekt\u0173 masyvai, RAII shared_ptr Bendras \u2705 Reference counting Dalijamasi objektais weak_ptr Nestiprus \u2705 Nepadidina count Cikl\u0173 vengimas"},{"location":"arrays/array-evoliucija/#mokymosi-tikslai_7","title":"\ud83d\udca1 Mokymosi tikslai","text":"<ul> <li>Naudoti smart pointers vietoj raw pointers</li> <li>Suprasti unique_ptr vs shared_ptr skirtumus</li> <li>Taikyti move semantics objekt\u0173 masyvams</li> </ul>"},{"location":"arrays/array-evoliucija/#isvados-ir-rekomendacijos","title":"I\u0161vados ir rekomendacijos","text":""},{"location":"arrays/array-evoliucija/#evoliucijos-santrauka","title":"Evoliucijos santrauka","text":"Etapas Metodas Privalumai Tr\u016bkumai Kada naudoti 1. C masyvai <code>Student arr[3]</code> Paprastas Fiksuotas dydis, tik default konstruktorius Mokymosi tikslais 2. Inicializacijos s\u0105ra\u0161as <code>Student arr[] = {...}</code> Parametriniai konstruktoriai Fiksuotas dydis \u017dinomas dydis compile time 3. Dinaminiai masyvai <code>new Student[n]</code> Dinaminis dydis Manual memory management Legacy kodas 4. Rule of Three Su copy/assignment Saugus kopijavimas Sud\u0117tinga implementacija Kai reikia kopijuoti 5. Rodykli\u0173 masyvai <code>Student* arr[]</code> Polimorfizmas Manual cleanup Polimorfizmas be STL 6. std::array <code>std::array&lt;Student, N&gt;</code> STL funkcionalumas, saugumas Fiksuotas dydis \u017dinomas dydis, STL algoritmai 7. std::vector <code>std::vector&lt;Student&gt;</code> Dinaminis, RAII, STL \u0160iek tiek overhead Da\u017eniausiai naudojamas 8. Smart pointers <code>vector&lt;unique_ptr&lt;Student&gt;&gt;</code> Polimorfizmas, RAII Sud\u0117tingesn\u0117 sintaks\u0117 Modern C++ polimorfizmas"},{"location":"arrays/array-evoliucija/#praktines-rekomendacijos","title":"Praktin\u0117s rekomendacijos","text":""},{"location":"arrays/array-evoliucija/#kada-naudoti-kuri-metoda","title":"Kada naudoti kur\u012f metod\u0105:","text":"<ol> <li>std::vector - da\u017eniausiai naudojamas pasirinkimas <li>Vienodo tipo objektai</li> <li>Dinaminis dydis</li> <li> <p>STL algoritmai</p> </li> <li> <p>std::vector&gt; - polimorfizmui <li>Skirting\u0173 tip\u0173 objektai</li> <li>Virtual\u016bs metodai</li> <li> <p>Modern C++ stilius</p> </li> <li> <p>std::array - fiksuotam dyd\u017eiui <li>\u017dinomas dydis compile time</li> <li>Maksimalus performance</li> <li> <p>STL funkcionalumas</p> </li> <li> <p>C masyvai - vengti, i\u0161skyrus:</p> </li> <li>Legacy kodas</li> <li>Embedded systems</li> <li>Mokymosi tikslais</li>"},{"location":"arrays/array-evoliucija/#dazniausios-klaidos-ir-ju-vengimas","title":"Da\u017eniausios klaidos ir j\u0173 vengimas","text":""},{"location":"arrays/array-evoliucija/#1-object-slicing","title":"1. Object Slicing","text":"<pre><code>// \u274c Blogai\nStudent arr[3] = {\n    Student(\"A\", 20, 8.0),\n    GraduateStudent(\"B\", 25, 9.0, \"AI\"),  // Object slicing!\n    Student(\"C\", 19, 7.5)\n};\n\n// \u2705 Gerai\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\nstudents.push_back(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\nstudents.push_back(std::make_unique&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"AI\"));\n</code></pre>"},{"location":"arrays/array-evoliucija/#2-memory-leaks","title":"2. Memory Leaks","text":"<pre><code>// \u274c Blogai\nStudent** students = new Student*[3];\nstudents[0] = new Student(\"A\", 20, 8.0);\n// Pamir\u0161tas delete[] ir delete\n\n// \u2705 Gerai\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\nstudents.push_back(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\n// Automatinis cleanup\n</code></pre>"},{"location":"arrays/array-evoliucija/#3-shallow-copy","title":"3. Shallow Copy","text":"<pre><code>// \u274c Blogai - be Rule of Three\nclass StudentManager {\n    Student* students;\n    int count;\n    // Tr\u016bksta copy constructor ir assignment operator\n};\n\n// \u2705 Gerai - su std::vector\nclass StudentManager {\n    std::vector&lt;Student&gt; students;  // Automatinis deep copy\n};\n</code></pre>"},{"location":"arrays/array-evoliucija/#mokymosi-kelias","title":"Mokymosi kelias","text":"<ol> <li>Prad\u0117kite nuo C masyv\u0173 - suprasite problemas</li> <li>Pereikite prie std::array - saugumas + STL</li> <li>I\u0161mokite std::vector - da\u017eniausiai naudojamas</li> <li>Prid\u0117kite smart pointers - polimorfizmui</li> <li>Praktikuokite su realiais projektais - \u012ftvirtinsite \u017einias</li> </ol> <p>Pagrindin\u0117 \u017einut\u0117: Modern C++ suteikia galingus \u012frankius objekt\u0173 masyv\u0173 valdymui. Naudokite STL konteinerius ir smart pointers - jie sprend\u017eia daugum\u0105 problem\u0173 automati\u0161kai ir saugiai.</p>"},{"location":"arrays/array-evolution/","title":"Objekt\u0173 masyv\u0173 evoliucija C++","text":"<p>Nuo C masyv\u0173 iki Modern C++ su STL ir smart pointers</p> <p>\ud83d\udd34 LIVE Documentation</p> <p>Kodo pavyzd\u017eiai automati\u0161kai sinchronizuojasi su <code>code/arrays/</code> katalogu.</p>"},{"location":"arrays/array-evolution/#evoliucijos-kelias","title":"\ud83d\udccb Evoliucijos kelias","text":"Etapas Metodas Problema \u2192 Sprendimas 1 C masyvai \u274c Tik default konstruktorius 2 Init list \u2705 Parametrai, \u274c fiksuotas dydis 3 Dynamic \u2705 Runtime dydis, \u274c memory leaks 4 Rule of Three \u2705 Deep copy saugumas 5 Pointers \u2705 Polimorfizmas, \u274c manual cleanup 6 std::array \u2705 STL + safety, \u274c fiksuotas 7 std::vector \u2705 Dynamic + RAII + STL 8 Smart pointers \u2705 Modern C++ - BEST!"},{"location":"arrays/array-evolution/#1-etapas-1-c-stiliaus-masyvai","title":"1\ufe0f\u20e3 Etapas 1: C stiliaus masyvai","text":""},{"location":"arrays/array-evolution/#problema","title":"Problema","text":"Bandome sukurti objekt\u0173 masyv\u0105 (atviras) <pre><code>    strcpy(name, \"Unknown\");\n    age = 0;\n    grade = 0.0;\n    std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n}\n\n// Parametrinis konstruktorius (nebus naudojamas masyve!)\nStudent(const char* n, int a, double g) {\n    strcpy(name, n);\n    age = a;\n    grade = g;\n    std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n}\n\n// Destruktorius\n~Student() {\n</code></pre> <p>\u274c Problema: <code>Student students[3]</code> kvie\u010dia tik default konstruktori\u0173!</p> Pilnas kodas (click to expand) <pre><code>// student_01.cpp - C stiliaus masyvai su objektais\n// Demonstracija: Tik default konstruktorius, rankinis duomen\u0173 keitimas\n\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass Student {\npublic:\n    char name[50];\n    int age;\n    double grade;\n\n    // Default konstruktorius\n    Student() {\n        strcpy(name, \"Unknown\");\n        age = 0;\n        grade = 0.0;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius (nebus naudojamas masyve!)\n    Student(const char* n, int a, double g) {\n        strcpy(name, n);\n        age = a;\n        grade = g;\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== C stiliaus masyvas su objektais ===\\n\\n\";\n\n    // \ud83d\udca5 PROBLEMA #1: Tik default konstruktorius!\n    Student students[3];  // Visi objektai sukurti su default konstruktoriumi\n\n    std::cout &lt;&lt; \"\\n--- Pradinis masyvas ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // Reikia rankiniu b\u016bdu keisti duomenis\n    std::cout &lt;&lt; \"\\n--- Kei\u010diame duomenis rankiniu b\u016bdu ---\\n\";\n    strcpy(students[0].name, \"Jonas\");\n    students[0].age = 20;\n    students[0].grade = 8.5;\n\n    strcpy(students[1].name, \"Petras\");\n    students[1].age = 21;\n    students[1].grade = 9.0;\n\n    strcpy(students[2].name, \"Marija\");\n    students[2].age = 19;\n    students[2].grade = 8.8;\n\n    std::cout &lt;&lt; \"\\n--- Po duomen\u0173 keitimo ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        students[i].print();\n    }\n\n    // \ud83d\udca5 PROBLEMA #2: Masyvo tipo painiava\n    std::cout &lt;&lt; \"\\n--- Masyvo tipo problema ---\\n\";\n    std::cout &lt;&lt; \"sizeof(students) = \" &lt;&lt; sizeof(students) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"sizeof(Student) = \" &lt;&lt; sizeof(Student) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"Element\u0173 skai\u010dius = \" &lt;&lt; sizeof(students) / sizeof(Student) &lt;&lt; \"\\n\";\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai (atvirk\u0161\u010dia tvarka) ---\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#kas-blogai","title":"Kas blogai?","text":"SukuriameReikia rankiniu b\u016bdu keisti <pre><code>Student students[3];  // Visi \"Unknown\", age=0, grade=0.0\n</code></pre> <pre><code>strcpy(students[0].name, \"Jonas\");\nstudents[0].age = 20;\nstudents[0].grade = 8.5;\n// ... ir taip kiekvienam!\n</code></pre>"},{"location":"arrays/array-evolution/#key-takeaway","title":"\ud83d\udca1 Key Takeaway","text":"<p>C masyvas visada kvie\u010dia tik default konstruktori\u0173. Dvigubas darbas: sukurti \u2192 keisti duomenis.</p>"},{"location":"arrays/array-evolution/#2-etapas-2-inicializacijos-sarasas-c11","title":"2\ufe0f\u20e3 Etapas 2: Inicializacijos s\u0105ra\u0161as (C++11)","text":""},{"location":"arrays/array-evolution/#sprendimas","title":"Sprendimas","text":"C++11 inicializacijos s\u0105ra\u0161as (atviras) <pre><code>    const std::string&amp; get_name() const { return name; }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== Inicializacijos s\u0105ra\u0161as (C++11) ===\\n\\n\";\n</code></pre> <p>\u2705 Galime naudoti parametrinius konstruktorius!</p> Pilnas kodas <pre><code>// student_02.cpp - Inicializacijos s\u0105ra\u0161as (C++11)\n// Demonstracija: Parametriniai konstruktoriai, std::string\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    // Default konstruktorius\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Parametrinis konstruktorius\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Copy konstruktorius\n    Student(const Student&amp; other) \n        : name(other.name), age(other.age), grade(other.grade) {\n        std::cout &lt;&lt; \"\ud83d\udccb Copy konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Destruktorius\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    const std::string&amp; get_name() const { return name; }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== Inicializacijos s\u0105ra\u0161as (C++11) ===\\n\\n\";\n\n    // \u2705 C++11 inicializacijos s\u0105ra\u0161as - parametriniai konstruktoriai!\n    Student students[] = {\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8)\n    };\n\n    const int count = sizeof(students) / sizeof(students[0]);\n    std::cout &lt;&lt; \"\\nMasyvo dydis: \" &lt;&lt; count &lt;&lt; \" elementai\\n\";\n\n    std::cout &lt;&lt; \"\\n--- Visi studentai ---\\n\";\n    for (int i = 0; i &lt; count; i++) {\n        std::cout &lt;&lt; (i + 1) &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // Masyvo tipo demonstracija\n    std::cout &lt;&lt; \"\\n--- Dyd\u017eio informacija ---\\n\";\n    std::cout &lt;&lt; \"sizeof(students) = \" &lt;&lt; sizeof(students) &lt;&lt; \" bytes\\n\";\n    std::cout &lt;&lt; \"sizeof(Student) = \" &lt;&lt; sizeof(Student) &lt;&lt; \" bytes\\n\";\n\n    // \ud83d\udca5 LIKO PROBLEMA: Negalima keisti masyvo dyd\u017eio\n    std::cout &lt;&lt; \"\\n--- Liko problem\u0173 ---\\n\";\n    std::cout &lt;&lt; \"\u274c Dydis fiksuotas compile time\\n\";\n    std::cout &lt;&lt; \"\u274c Negalima prid\u0117ti/pa\u0161alinti element\u0173\\n\";\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#kas-pagerejo","title":"Kas pager\u0117jo?","text":"Anks\u010diau Dabar Default konstruktorius \u2705 Parametrinis konstruktorius <code>char name[50]</code> \u2705 <code>std::string</code> Rankinis keitimas \u2705 Tiesiogiai inicializuojame"},{"location":"arrays/array-evolution/#liko-problemu","title":"Liko problem\u0173","text":"<p>\u274c Dydis fiksuotas compile time \u274c Masyvas \"virsta\" rodykle funkcijose \u274c Negalima keisti dyd\u017eio runtime</p>"},{"location":"arrays/array-evolution/#key-takeaway_1","title":"\ud83d\udca1 Key Takeaway","text":"<p>Inicializacijos s\u0105ra\u0161as leid\u017eia naudoti parametrinius konstruktorius, bet dydis vis dar fiksuotas.</p>"},{"location":"arrays/array-evolution/#3-etapas-3-dinaminiai-masyvai","title":"3\ufe0f\u20e3 Etapas 3: Dinaminiai masyvai","text":""},{"location":"arrays/array-evolution/#runtime-dydis","title":"Runtime dydis","text":"Dinaminis masyvas su new[] (atviras) <pre><code>              &lt;&lt; capacity &lt;&lt; \")\\n\";\n    students = new Student[capacity];  // \ud83d\udca5 Tik default konstruktoriai!\n}\n\n~StudentManager() {\n    std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n    delete[] students;  // \u2705 Automati\u0161kai i\u0161kvie\u010dia destruktorius\n}\n\n// \ud83d\udca5 PROBLEMA: N\u0117ra copy konstruktoriaus - shallow copy!\n// StudentManager(const StudentManager&amp;) = delete;  // Geriau u\u017edrausti\n\nvoid add_student(const std::string&amp; name, int age, double grade) {\n    if (count &gt;= capacity) {\n        std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n        return;\n</code></pre> <p>\u2705 Galime keisti dyd\u012f runtime \u274c Bet reikia <code>delete[]</code> - memory leak rizika!</p> Pilnas kodas <pre><code>// student_03.cpp - Dinaminiai masyvai (new/delete)\n// Demonstracija: Runtime dydis, memory management problemos\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {\n        std::cout &lt;&lt; \"\ud83d\udcda Default konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Parametrinis konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    // Setter metodai dinaminiam u\u017epildymui\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n;\n        age = a;\n        grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;  // Rodykl\u0117 \u012f dinamin\u012f masyv\u0105\n    int capacity;\n    int count;\n\npublic:\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: \" \n                  &lt;&lt; capacity &lt;&lt; \")\\n\";\n        students = new Student[capacity];  // \ud83d\udca5 Tik default konstruktoriai!\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;  // \u2705 Automati\u0161kai i\u0161kvie\u010dia destruktorius\n    }\n\n    // \ud83d\udca5 PROBLEMA: N\u0117ra copy konstruktoriaus - shallow copy!\n    // StudentManager(const StudentManager&amp;) = delete;  // Geriau u\u017edrausti\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; count &lt;&lt; \"/\" \n                  &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n};\n\nvoid test_dynamic_array() {\n    std::cout &lt;&lt; \"\\n=== Funkcijos scope testas ===\\n\";\n\n    StudentManager manager(2);\n    manager.add_student(\"Tomas\", 22, 7.8);\n    manager.add_student(\"Ona\", 20, 9.2);\n    manager.print_all();\n\n    std::cout &lt;&lt; \"\\n--- Funkcija baigiasi - manager sunaikinamas ---\\n\";\n}\n\nint main() {\n    std::cout &lt;&lt; \"=== Dinaminiai masyvai ===\\n\\n\";\n\n    // Paprastas dinaminis masyvas\n    std::cout &lt;&lt; \"--- Runtime dyd\u017eio \u012fvedimas ---\\n\";\n    int size = 3;  // Hardcoded vietoj std::cin\n    std::cout &lt;&lt; \"Student\u0173 skai\u010dius: \" &lt;&lt; size &lt;&lt; \"\\n\\n\";\n\n    Student* students = new Student[size];  // Default konstruktoriai\n\n    // U\u017epildymas duomenimis\n    std::cout &lt;&lt; \"--- U\u017epildymas duomenimis ---\\n\";\n    students[0].set_data(\"Jonas\", 20, 8.5);\n    students[1].set_data(\"Petras\", 21, 9.0);\n    students[2].set_data(\"Marija\", 19, 8.8);\n\n    std::cout &lt;&lt; \"\\n--- Dinaminis masyvas ---\\n\";\n    for (int i = 0; i &lt; size; i++) {\n        students[i].print();\n    }\n\n    std::cout &lt;&lt; \"\\n--- delete[] i\u0161kvietimas ---\\n\";\n    delete[] students;  // \u2705 Destruktoriai i\u0161kvie\u010diami\n\n    // Objekto su dinaminiu masyvu testas\n    test_dynamic_array();\n\n    // \ud83d\udca5 SHALLOW COPY DEMONSTRACIJA\n    std::cout &lt;&lt; \"\\n=== Shallow copy problema ===\\n\";\n    std::cout &lt;&lt; \"\u274c Jei sukurtume kopij\u0105 - double delete crash!\\n\";\n    std::cout &lt;&lt; \"\u274c Reikia Rule of Three!\\n\";\n\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#problemos","title":"Problemos","text":"Memory leakShallow copy <pre><code>Student* students = new Student[size];\n// ... naudojame ...\n// Pamir\u0161ome delete[] students; \ud83d\udca5\n</code></pre> <pre><code>StudentManager m1(10);\nStudentManager m2 = m1;  // \ud83d\udca5 Abu rodo \u012f t\u0105 pat\u012f masyv\u0105\n// Sunaikinus - double delete!\n</code></pre>"},{"location":"arrays/array-evolution/#key-takeaway_2","title":"\ud83d\udca1 Key Takeaway","text":"<p><code>new[]</code> duoda runtime dyd\u012f, bet reikia rankiniu b\u016bdu valdyti atmint\u012f. Pavojinga: memory leaks, double delete, shallow copy.</p>"},{"location":"arrays/array-evolution/#4-etapas-4-rule-of-three","title":"4\ufe0f\u20e3 Etapas 4: Rule of Three","text":""},{"location":"arrays/array-evolution/#deep-copy-saugumas","title":"Deep copy saugumas","text":"Rule of Three implementacija (atviras) <pre><code>// 1. Konstruktorius\nStudentManager(int initial_capacity) \n    : capacity(initial_capacity), count(0) {\n    std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: \" \n              &lt;&lt; capacity &lt;&lt; \")\\n\";\n    students = new Student[capacity];\n}\n\n// 2. Destruktorius\n~StudentManager() {\n    std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n    delete[] students;\n}\n\n// 3. Copy konstruktorius (deep copy)\nStudentManager(const StudentManager&amp; other) \n    : capacity(other.capacity), count(other.count) {\n    std::cout &lt;&lt; \"\ud83d\udccb StudentManager copy konstruktorius\\n\";\n\n    students = new Student[capacity];  // Naujas masyvas\n\n    // Kopijuojame duomenis\n    for (int i = 0; i &lt; count; i++) {\n        students[i] = other.students[i];\n    }\n}\n\n// 4. Assignment operatorius\nStudentManager&amp; operator=(const StudentManager&amp; other) {\n    std::cout &lt;&lt; \"\ud83d\udcdd StudentManager assignment operatorius\\n\";\n\n    if (this == &amp;other) {  // Self-assignment apsauga\n        return *this;\n    }\n\n    // I\u0161valome sen\u0105 atmint\u012f\n</code></pre> <p>\u2705 Destruktorius, Copy konstruktorius, Assignment operatorius</p> Pilnas kodas <pre><code>// student_04.cpp - Rule of Three\n// Demonstracija: Deep copy, destruktorius, assignment operatorius\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {}\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {}\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    void set_data(const std::string&amp; n, int a, double g) {\n        name = n; age = a; grade = g;\n    }\n};\n\nclass StudentManager {\nprivate:\n    Student* students;\n    int capacity;\n    int count;\n\npublic:\n    // 1. Konstruktorius\n    StudentManager(int initial_capacity) \n        : capacity(initial_capacity), count(0) {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius (capacity: \" \n                  &lt;&lt; capacity &lt;&lt; \")\\n\";\n        students = new Student[capacity];\n    }\n\n    // 2. Destruktorius\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n        delete[] students;\n    }\n\n    // 3. Copy konstruktorius (deep copy)\n    StudentManager(const StudentManager&amp; other) \n        : capacity(other.capacity), count(other.count) {\n        std::cout &lt;&lt; \"\ud83d\udccb StudentManager copy konstruktorius\\n\";\n\n        students = new Student[capacity];  // Naujas masyvas\n\n        // Kopijuojame duomenis\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];\n        }\n    }\n\n    // 4. Assignment operatorius\n    StudentManager&amp; operator=(const StudentManager&amp; other) {\n        std::cout &lt;&lt; \"\ud83d\udcdd StudentManager assignment operatorius\\n\";\n\n        if (this == &amp;other) {  // Self-assignment apsauga\n            return *this;\n        }\n\n        // I\u0161valome sen\u0105 atmint\u012f\n        delete[] students;\n\n        // Kopijuojame nauj\u0105\n        capacity = other.capacity;\n        count = other.count;\n        students = new Student[capacity];\n\n        for (int i = 0; i &lt; count; i++) {\n            students[i] = other.students[i];\n        }\n\n        return *this;\n    }\n\n    void add_student(const std::string&amp; name, int age, double grade) {\n        if (count &gt;= capacity) {\n            std::cout &lt;&lt; \"\u274c Masyvas pilnas!\\n\";\n            return;\n        }\n\n        students[count].set_data(name, age, grade);\n        count++;\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; count &lt;&lt; \"/\" \n                  &lt;&lt; capacity &lt;&lt; \") ---\\n\";\n        for (int i = 0; i &lt; count; i++) {\n            students[i].print();\n        }\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== Rule of Three ===\\n\\n\";\n\n    // Originalus objektas\n    std::cout &lt;&lt; \"--- Originalus objektas ---\\n\";\n    StudentManager manager1(2);\n    manager1.add_student(\"Jonas\", 20, 8.5);\n    manager1.add_student(\"Petras\", 21, 9.0);\n    manager1.print_all();\n\n    // Copy konstruktorius testas\n    std::cout &lt;&lt; \"\\n=== Copy konstruktorius ===\\n\";\n    StudentManager manager2 = manager1;  // Copy konstruktorius\n    manager2.print_all();\n\n    // Assignment operatorius testas\n    std::cout &lt;&lt; \"\\n=== Assignment operatorius ===\\n\";\n    StudentManager manager3(1);\n    manager3.add_student(\"Marija\", 19, 8.8);\n    manager3.print_all();\n\n    std::cout &lt;&lt; \"\\n--- Assignment: manager3 = manager1 ---\\n\";\n    manager3 = manager1;  // Assignment operatorius\n    manager3.print_all();\n\n    // Self-assignment testas\n    std::cout &lt;&lt; \"\\n=== Self-assignment testas ===\\n\";\n    manager1 = manager1;  // Turi b\u016bti saugus\n    std::cout &lt;&lt; \"\u2705 Self-assignment necrash'ino!\\n\";\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#rule-of-three","title":"Rule of Three","text":"Komponentas Paskirtis Destruktorius <code>delete[] students;</code> Copy konstruktorius Deep copy suk\u016brimas Assignment operatorius Deep copy priskyrimas"},{"location":"arrays/array-evolution/#self-assignment-apsauga","title":"Self-assignment apsauga","text":"<pre><code>StudentManager&amp; operator=(const StudentManager&amp; other) {\n    if (this == &amp;other) return *this;  // \u2190 SVARBU!\n    // ... copy logic ...\n}\n</code></pre>"},{"location":"arrays/array-evolution/#key-takeaway_3","title":"\ud83d\udca1 Key Takeaway","text":"<p>Kai klas\u0117 valdo dinamin\u0119 atmint\u012f, privaloma Rule of Three. Kitaip - shallow copy \u2192 crash.</p>"},{"location":"arrays/array-evolution/#5-etapas-5-rodykliu-masyvai","title":"5\ufe0f\u20e3 Etapas 5: Rodykli\u0173 masyvai","text":""},{"location":"arrays/array-evolution/#polimorfizmas","title":"Polimorfizmas","text":"Object slicing problema (atviras) <pre><code>    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nint main() {\n</code></pre> <p>\u274c <code>GraduateStudent</code> \"nupjaunamas\" \u2192 lieka tik <code>Student</code>!</p> Teisingas b\u016bdas - rodykli\u0173 masyvas <pre><code>Student* polymorphic_array[3];\npolymorphic_array[0] = new Student(\"Jonas\", 20);\npolymorphic_array[1] = new GraduateStudent(\"Petras\", 25, \"AI Research\");\npolymorphic_array[2] = new Student(\"Marija\", 19);\n\nstd::cout &lt;&lt; \"\\n--- Tikrinimas (teisingas polimorfizmas) ---\\n\";\nfor (int i = 0; i &lt; 3; i++) {\n    std::cout &lt;&lt; \"Tipas: \" &lt;&lt; polymorphic_array[i]-&gt;get_type() &lt;&lt; \" - \";\n    polymorphic_array[i]-&gt;print();\n}\nstd::cout &lt;&lt; \"\\n\u2705 Petras teisingai rodomas kaip GraduateStudent!\\n\";\n</code></pre> <p>\u2705 Polimorfizmas veikia su rodykl\u0117mis!</p> Pilnas kodas <pre><code>// demo_05.cpp - Rodykli\u0173 semantika ir polimorfizmas\n// Demonstracija: Object slicing, rodykli\u0173 masyvas\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n\npublic:\n    Student(const std::string&amp; n, int a) : name(n), age(a) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, const std::string&amp; topic) \n        : Student(n, a), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== Rodykli\u0173 semantika ir polimorfizmas ===\\n\\n\";\n\n    // \ud83d\udca5 PROBLEMA: Objekt\u0173 masyvas su polimorfizmu\n    std::cout &lt;&lt; \"--- 1. Objekt\u0173 masyvas (object slicing!) ---\\n\";\n    Student mixed_array[3] = {\n        Student(\"Jonas\", 20),\n        GraduateStudent(\"Petras\", 25, \"AI Research\"),  // \ud83d\udca5 Object slicing!\n        Student(\"Marija\", 19)\n    };\n\n    std::cout &lt;&lt; \"\\n--- Tikrinimas (neteisingas polimorfizmas) ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; mixed_array[i].get_type() &lt;&lt; \" - \";\n        mixed_array[i].print();\n    }\n    std::cout &lt;&lt; \"\\n\u274c Petras tur\u0117jo b\u016bti GraduateStudent, bet slicing!\\n\";\n\n    // \u2705 SPRENDIMAS: Rodykli\u0173 masyvas\n    std::cout &lt;&lt; \"\\n--- 2. Rodykli\u0173 masyvas (teisingas polimorfizmas) ---\\n\";\n    Student* polymorphic_array[3];\n    polymorphic_array[0] = new Student(\"Jonas\", 20);\n    polymorphic_array[1] = new GraduateStudent(\"Petras\", 25, \"AI Research\");\n    polymorphic_array[2] = new Student(\"Marija\", 19);\n\n    std::cout &lt;&lt; \"\\n--- Tikrinimas (teisingas polimorfizmas) ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        std::cout &lt;&lt; \"Tipas: \" &lt;&lt; polymorphic_array[i]-&gt;get_type() &lt;&lt; \" - \";\n        polymorphic_array[i]-&gt;print();\n    }\n    std::cout &lt;&lt; \"\\n\u2705 Petras teisingai rodomas kaip GraduateStudent!\\n\";\n\n    // I\u0161valymas\n    std::cout &lt;&lt; \"\\n--- Manual cleanup ---\\n\";\n    for (int i = 0; i &lt; 3; i++) {\n        delete polymorphic_array[i];\n    }\n\n    std::cout &lt;&lt; \"\\n--- Objekt\u0173 masyvo destruktoriai ---\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#palyginimas","title":"Palyginimas","text":"Tipas Sintaks\u0117 Polimorfizmas Cleanup Objekt\u0173 masyvas <code>Student arr[3]</code> \u274c Slicing Automatinis Rodykli\u0173 masyvas <code>Student* arr[3]</code> \u2705 Veikia Rankinis Dinaminis <code>Student** arr</code> \u2705 Veikia Rankinis"},{"location":"arrays/array-evolution/#key-takeaway_4","title":"\ud83d\udca1 Key Takeaway","text":"<p>Polimorfizmui b\u016btinos rodykl\u0117s. Objekt\u0173 masyvas = object slicing!</p>"},{"location":"arrays/array-evolution/#6-etapas-6-stl-stdarray","title":"6\ufe0f\u20e3 Etapas 6: STL std::array","text":""},{"location":"arrays/array-evolution/#saugus-c-masyvas","title":"Saugus C masyvas","text":"std::array su inicializacija (atviras) <pre><code>~Student() {\n    std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n}\n\nvoid print() const {\n    std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n              &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n}\n\ndouble get_grade() const { return grade; }\nconst std::string&amp; get_name() const { return name; }\n\nbool operator&lt;(const Student&amp; other) const {\n    return grade &lt; other.grade;\n}\n</code></pre> <p>\u2705 STL funkcionalumas + compile-time dydis</p> Pilnas kodas <pre><code>// demo_06.cpp - STL std::array\n// Demonstracija: Saugus masyvas, STL algoritmai\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student() : name(\"Unknown\"), age(0), grade(0.0) {}\n\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {}\n\n    ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    double get_grade() const { return grade; }\n    const std::string&amp; get_name() const { return name; }\n\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::array ===\\n\\n\";\n\n    // \u2705 std::array su inicializacijos s\u0105ra\u0161u\n    std::array&lt;Student, 4&gt; students = {{\n        Student(\"Jonas\", 20, 8.5),\n        Student(\"Petras\", 21, 9.0),\n        Student(\"Marija\", 19, 8.8),\n        Student(\"Tomas\", 22, 7.5)\n    }};\n\n    std::cout &lt;&lt; \"--- Pradinis masyvas ---\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; (i + 1) &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // STL algoritmai\n    std::cout &lt;&lt; \"\\n--- R\u016b\u0161iavimas pagal pa\u017eym\u012f ---\\n\";\n    std::sort(students.begin(), students.end());\n\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; (i + 1) &lt;&lt; \". \";\n        students[i].print();\n    }\n\n    // Paie\u0161ka\n    std::cout &lt;&lt; \"\\n--- Paie\u0161ka (pa\u017eymys &gt; 8.7) ---\\n\";\n    auto it = std::find_if(students.begin(), students.end(), \n        [](const Student&amp; s) { return s.get_grade() &gt; 8.7; });\n\n    if (it != students.end()) {\n        std::cout &lt;&lt; \"Rastas: \";\n        it-&gt;print();\n    }\n\n    // Saugus prieigos metodas\n    std::cout &lt;&lt; \"\\n--- Saugi prieiga su at() ---\\n\";\n    try {\n        std::cout &lt;&lt; \"students.at(2): \";\n        students.at(2).print();\n\n        std::cout &lt;&lt; \"students.at(10): \";\n        students.at(10).print();  // \u274c Mest\u0173 exception\n    } catch (const std::out_of_range&amp; e) {\n        std::cout &lt;&lt; \"\u274c Klaida: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    }\n\n    // Array informacija\n    std::cout &lt;&lt; \"\\n--- Array informacija ---\\n\";\n    std::cout &lt;&lt; \"Size: \" &lt;&lt; students.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Empty: \" &lt;&lt; (students.empty() ? \"Taip\" : \"Ne\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Front: \"; students.front().print();\n    std::cout &lt;&lt; \"Back: \"; students.back().print();\n\n    std::cout &lt;&lt; \"\\n--- Destruktoriai ---\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#privalumai","title":"Privalumai","text":"Saugi prieigaSTL algoritmaiRange-based for <pre><code>students.at(2).print();  // \u2705 Su bounds checking\n// students.at(10);      // \u274c Metus exception\n</code></pre> <pre><code>std::sort(students.begin(), students.end());\n\nauto it = std::find_if(students.begin(), students.end(),\n    [](const Student&amp; s) { return s.get_grade() &gt; 8.7; });\n</code></pre> <pre><code>for (const auto&amp; student : students) {\n    student.print();\n}\n</code></pre>"},{"location":"arrays/array-evolution/#c-masyvas-vs-stdarray","title":"C masyvas vs std::array","text":"Funkcija C masyvas std::array Dydis <code>sizeof(arr)/sizeof(arr[0])</code> <code>arr.size()</code> Saugi prieiga \u274c \u2705 <code>at()</code> STL \u274c \u2705 <code>begin()/end()</code> Range-for \u274c \u2705"},{"location":"arrays/array-evolution/#key-takeaway_5","title":"\ud83d\udca1 Key Takeaway","text":"<p><code>std::array</code> = C masyvas + STL funkcionalumas + saugumas. Bet dydis vis dar fiksuotas compile time.</p>"},{"location":"arrays/array-evolution/#7-etapas-7-stl-stdvector","title":"7\ufe0f\u20e3 Etapas 7: STL std::vector","text":""},{"location":"arrays/array-evolution/#dinaminis-raii-stl-paprastumas","title":"Dinaminis + RAII + STL = Paprastumas! \ud83c\udf89","text":"std::vector - papras\u010diausias ir galingiausias! (atviras) <pre><code>}\n\n// Spausdinimas\nvoid print() const {\n    std::cout &lt;&lt; \"Student: \" &lt;&lt; name \n              &lt;&lt; \", Am\u017eius: \" &lt;&lt; age \n              &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; grade &lt;&lt; std::endl;\n}\n\n// Getteris\ndouble get_grade() const { \n    return grade; \n}\n\nstd::string get_name() const {\n    return name;\n}\n\n// Palyginimas (reikalingas std::sort)\nbool operator&lt;(const Student&amp; other) const {\n    return grade &lt; other.grade;\n</code></pre> <p>\u2705 Tiesiog veikia! Nereikia <code>new[]</code>/<code>delete[]</code> - viskas automati\u0161kai!</p> Pilnas kodas <pre><code>// demo_07.cpp - STL std::vector (paprastas variantas)\n// Demonstracija: Dinaminis masyvas, automatinis atminties valdymas, STL algoritmai\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass Student {\nprivate:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    // Konstruktorius\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Sukurtas: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    // Spausdinimas\n    void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name \n                  &lt;&lt; \", Am\u017eius: \" &lt;&lt; age \n                  &lt;&lt; \", Pa\u017eymys: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    // Getteris\n    double get_grade() const { \n        return grade; \n    }\n\n    std::string get_name() const {\n        return name;\n    }\n\n    // Palyginimas (reikalingas std::sort)\n    bool operator&lt;(const Student&amp; other) const {\n        return grade &lt; other.grade;\n    }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== STL std::vector demonstracija ===\\n\\n\";\n\n    // ========================================================================\n    // 1. K\u016aRIMAS - tu\u0161\u010dias vector\n    // ========================================================================\n\n    std::vector&lt;Student&gt; students;\n    std::cout &lt;&lt; \"Pradinis dydis: \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Pradinis capacity: \" &lt;&lt; students.capacity() &lt;&lt; \"\\n\\n\";\n\n    // ========================================================================\n    // 2. PRID\u0116JIMAS - push_back ir emplace_back\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Pridedame studentus (push_back) ---\\n\";\n\n    // push_back - reikia sukurti objekt\u0105 prie\u0161 tai\n    Student s1(\"Jonas\", 20, 8.5);\n    students.push_back(s1);\n\n    // Arba sukuriame ir i\u0161 karto \u012fdedame\n    students.push_back(Student(\"Petras\", 21, 9.0));\n    students.push_back(Student(\"Marija\", 19, 8.8));\n\n    std::cout &lt;&lt; \"\\nPo push_back:\\n\";\n    std::cout &lt;&lt; \"  size = \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  capacity = \" &lt;&lt; students.capacity() &lt;&lt; \"\\n\\n\";\n\n    // emplace_back - efektyvesnis, konstruoja objekt\u0105 vietoje\n    std::cout &lt;&lt; \"--- Pridedame studentus (emplace_back) ---\\n\";\n    students.emplace_back(\"Tomas\", 22, 7.5);\n    students.emplace_back(\"Ona\", 20, 9.2);\n\n    std::cout &lt;&lt; \"\\nPo emplace_back:\\n\";\n    std::cout &lt;&lt; \"  size = \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  capacity = \" &lt;&lt; students.capacity() &lt;&lt; \"\\n\\n\";\n\n    // ========================================================================\n    // 3. PRIEIGA - operatorius [] ir at()\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Prieiga prie element\u0173 ---\\n\";\n    std::cout &lt;&lt; \"Pirmas studentas (students[0]): \";\n    students[0].print();\n\n    std::cout &lt;&lt; \"\\nPaskutinis studentas (students.back()): \";\n    students.back().print();\n\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 4. ITERAVIMAS - range-based for loop\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Visi studentai (range-based for) ---\\n\";\n    for (const auto&amp; student : students) {\n        student.print();\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 5. ITERAVIMAS - tradicinis b\u016bdas su indeksais\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Visi studentai (su indeksais) ---\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; i + 1 &lt;&lt; \". \";\n        students[i].print();\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 6. R\u016a\u0160IAVIMAS - std::sort()\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- R\u016b\u0161iavimas pagal pa\u017eym\u012f (ma\u017e\u0117jimo tvarka) ---\\n\";\n    std::sort(students.begin(), students.end());\n\n    for (const auto&amp; student : students) {\n        std::cout &lt;&lt; \"  Pa\u017eymys: \" &lt;&lt; student.get_grade() \n                  &lt;&lt; \" - \" &lt;&lt; student.get_name() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 7. R\u016a\u0160IAVIMAS - custom comparator (did\u0117jimo tvarka)\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- R\u016b\u0161iavimas pagal pa\u017eym\u012f (did\u0117jimo tvarka) ---\\n\";\n    std::sort(students.begin(), students.end(), \n              [](const Student&amp; a, const Student&amp; b) {\n                  return a.get_grade() &gt; b.get_grade();\n              });\n\n    for (const auto&amp; student : students) {\n        std::cout &lt;&lt; \"  Pa\u017eymys: \" &lt;&lt; student.get_grade() \n                  &lt;&lt; \" - \" &lt;&lt; student.get_name() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 8. \u012eTERPIMAS - insert()\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- \u012eterpiame student\u0105 \u012f antr\u0105 pozicij\u0105 ---\\n\";\n    auto it = students.begin() + 1;  // Pozicija [1]\n    students.insert(it, Student(\"Lukas\", 23, 8.7));\n\n    std::cout &lt;&lt; \"Po insert:\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; \"  [\" &lt;&lt; i &lt;&lt; \"] \" &lt;&lt; students[i].get_name() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 9. \u0160ALINIMAS - erase()\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- \u0160aliname tre\u010di\u0105 student\u0105 ---\\n\";\n    students.erase(students.begin() + 2);\n\n    std::cout &lt;&lt; \"Po erase (size = \" &lt;&lt; students.size() &lt;&lt; \"):\\n\";\n    for (size_t i = 0; i &lt; students.size(); i++) {\n        std::cout &lt;&lt; \"  [\" &lt;&lt; i &lt;&lt; \"] \" &lt;&lt; students[i].get_name() &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 10. PAIE\u0160KA - std::find_if()\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Ie\u0161kome studento su pa\u017eymiu &gt; 9.0 ---\\n\";\n    auto found = std::find_if(students.begin(), students.end(),\n                              [](const Student&amp; s) {\n                                  return s.get_grade() &gt; 9.0;\n                              });\n\n    if (found != students.end()) {\n        std::cout &lt;&lt; \"Rastas: \";\n        found-&gt;print();\n    } else {\n        std::cout &lt;&lt; \"Nerastas!\\n\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n\n    // ========================================================================\n    // 11. CAPACITY VALDYMAS\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Capacity valdymas ---\\n\";\n    std::cout &lt;&lt; \"Dabartinis size: \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Dabartinis capacity: \" &lt;&lt; students.capacity() &lt;&lt; \"\\n\\n\";\n\n    // reserve() - i\u0161skiria atmint\u012f i\u0161 anksto (i\u0161vengiame perk\u0117lim\u0173)\n    students.reserve(20);\n    std::cout &lt;&lt; \"Po reserve(20):\\n\";\n    std::cout &lt;&lt; \"  size: \" &lt;&lt; students.size() &lt;&lt; \" (nepasikeit\u0117)\\n\";\n    std::cout &lt;&lt; \"  capacity: \" &lt;&lt; students.capacity() &lt;&lt; \" (padid\u0117jo)\\n\\n\";\n\n    // shrink_to_fit() - suma\u017eina capacity iki size\n    students.shrink_to_fit();\n    std::cout &lt;&lt; \"Po shrink_to_fit():\\n\";\n    std::cout &lt;&lt; \"  size: \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  capacity: \" &lt;&lt; students.capacity() &lt;&lt; \"\\n\\n\";\n\n    // ========================================================================\n    // 12. I\u0160VALYMAS\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- I\u0161valome vector ---\\n\";\n    students.clear();\n    std::cout &lt;&lt; \"Po clear():\\n\";\n    std::cout &lt;&lt; \"  size: \" &lt;&lt; students.size() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"  capacity: \" &lt;&lt; students.capacity() \n              &lt;&lt; \" (capacity lieka!)\\n\\n\";\n\n    // ========================================================================\n    // 13. PRADINIS DYDIS\n    // ========================================================================\n\n    std::cout &lt;&lt; \"--- Kuriame vector su pradiniu dyd\u017eiu ---\\n\";\n    std::vector&lt;int&gt; numbers(5, 100);  // 5 elementai, visi = 100\n\n    std::cout &lt;&lt; \"numbers = { \";\n    for (int num : numbers) {\n        std::cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"}\\n\";\n\n    return 0;\n}\n\n// ============================================================================\n// PASTABOS STUDENTAMS:\n// ============================================================================\n//\n// 1. AUTOMATINIS ATMINTIES VALDYMAS:\n//    - vector PATS valdo atmint\u012f (new/delete nevartojamas!)\n//    - I\u0161einant i\u0161 scope, atmintis automati\u0161kai atlaisvinama\n//    - Nereikia RAII pattern\u0173 - jau \u012fdiegta!\n//\n// 2. PUSH_BACK vs EMPLACE_BACK:\n//    - push_back(obj) - reikia sukurto objekto\n//    - emplace_back(args...) - konstruoja objekt\u0105 vietoje (efektyviau)\n//\n// 3. SIZE vs CAPACITY:\n//    - size = kiek element\u0173 realiai yra\n//    - capacity = kiek element\u0173 galima \u012fd\u0117ti be naujo alokavimo\n//    - Kai size == capacity, pridedant nauj\u0105 element\u0105 capacity dvigub\u0117ja!\n//\n// 4. ITERATORIAI:\n//    - begin() - pirmas elementas\n//    - end() - VIENA POZICIJA PO paskutinio (ne pats paskutinis!)\n//    - Iteratoriai gali sugesti po insert/erase/push_back (jei reallocate)\n//\n// 5. STL ALGORITMAI:\n//    - std::sort() - r\u016b\u0161iavimas (reikia operator&lt; arba custom comparator)\n//    - std::find_if() - paie\u0161ka su lambda funkcija\n//    - Visi algoritmai veikia su iteratoriais, ne indeksais!\n//\n// 6. LAMBDA FUNKCIJOS (C++11):\n//    - [](args) { body } - anoniminis funkcijos objektas\n//    - Naudojamas kaip callback std::sort, std::find_if ir kt.\n//\n// 7. EFEKTYVUMAS:\n//    - reserve() prie\u0161 daug prid\u0117jim\u0173 - i\u0161vengia perk\u0117lim\u0173\n//    - emplace_back &gt; push_back - konstruoja vietoje\n//    - Pass by const reference - i\u0161vengia kopij\u0173\n//\n// 8. DA\u017dNIAUSIOS KLAIDOS:\n//    - students[i] nespaud\u017eia bounds (gali crash)\n//    - students.at(i) tikrina bounds (meta exception jei out of range)\n//    - Naudoti invalidated iterator po erase/insert\n//\n// ============================================================================\n</code></pre>"},{"location":"arrays/array-evolution/#pagrindas-tiesiog-pridek-ir-naudok","title":"Pagrindas: Tiesiog Prid\u0117k ir Naudok","text":"K\u016brimas ir Prid\u0117jimasPrieigaIteravimas <pre><code>std::vector&lt;Student&gt; students;  // Tu\u0161\u010dias vector\n\n// B\u016bdas 1: push_back\nstudents.push_back(Student(\"Jonas\", 20, 8.5));\n\n// B\u016bdas 2: emplace_back (efektyvesnis!)\nstudents.emplace_back(\"Petras\", 21, 9.0);\n</code></pre> <pre><code>students[0].print();      // Greita prieiga\nstudents.at(0).print();   // Su bounds checking\nstudents.front().print(); // Pirmas\nstudents.back().print();  // Paskutinis\n</code></pre> <pre><code>// Range-based for (REKOMENDUOJAMA!)\nfor (const auto&amp; student : students) {\n    student.print();\n}\n\n// Tradicinis b\u016bdas\nfor (size_t i = 0; i &lt; students.size(); i++) {\n    students[i].print();\n}\n</code></pre>"},{"location":"arrays/array-evolution/#stl-galimybes-veikia-is-karto","title":"STL Galimyb\u0117s - Veikia I\u0161 Karto!","text":"R\u016b\u0161iavimasPaie\u0161kaModifikavimas <pre><code>// Su operator&lt;\nstd::sort(students.begin(), students.end());\n\n// Custom lambda comparator\nstd::sort(students.begin(), students.end(),\n    [](const Student&amp; a, const Student&amp; b) {\n        return a.get_grade() &gt; b.get_grade();\n    });\n</code></pre> <pre><code>auto found = std::find_if(students.begin(), students.end(),\n                          [](const Student&amp; s) {\n                              return s.get_grade() &gt; 9.0;\n                          });\n\nif (found != students.end()) {\n    found-&gt;print();  // Rastas!\n}\n</code></pre> <pre><code>students.insert(students.begin() + 1, newStudent);\nstudents.erase(students.begin() + 2);\nstudents.clear();  // I\u0161valo visus\n</code></pre>"},{"location":"arrays/array-evolution/#size-vs-capacity-svarbu-suprasti","title":"Size vs Capacity - Svarbu Suprasti!","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 [0] [1] [2] [3] [4] [ ] [ ] [ ]       \u2502\n\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500       \u2502\n\u2502       size=5         capacity=8       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>std::vector&lt;Student&gt; students;\nstudents.reserve(10);           // capacity = 10, size = 0\nstudents.emplace_back(...);     // capacity = 10, size = 1\nstudents.emplace_back(...);     // capacity = 10, size = 2\n// ... prid\u0117jus 11-t\u0105 ...       // capacity = 20, size = 11 (dvigub\u0117ja!)\n</code></pre> <p>Optimizavimas: Jei \u017einote, kiek bus element\u0173 - <code>reserve()</code> i\u0161 anksto!</p>"},{"location":"arrays/array-evolution/#kodel-vector-yra-geriausias","title":"Kod\u0117l vector Yra Geriausias?","text":"<p>\u2705 Automatinis atminties valdymas - nereikia <code>delete[]</code> \u2705 Dinaminis dydis - auga automati\u0161kai \u2705 STL algoritmai - <code>sort</code>, <code>find</code> veikia i\u0161 karto \u2705 Saugumas - <code>at()</code> tikrina ribas \u2705 Efektyvumas - cache-friendly contiguous memory \u2705 Exception-safe - garantuoja cleanup  </p>"},{"location":"arrays/array-evolution/#lyginant-su-ankstesniais-etapais","title":"Lyginant su Ankstesniais Etapais","text":"Funkcija C masyvas std::array std::vector Dinaminis dydis \u274c \u274c \u2705 Auto cleanup \u274c \u2705 \u2705 Bounds checking \u274c \u2705 <code>at()</code> \u2705 <code>at()</code> STL algoritmai \u26a0\ufe0f Nepatogiai \u2705 \u2705 Dydis runtime \u274c \u274c \u2705"},{"location":"arrays/array-evolution/#kada-naudoti","title":"Kada Naudoti?","text":"<p>\u2705 std::vector \u2192 90% atvej\u0173! Default pasirinkimas \u26a0\ufe0f std::array \u2192 Kai dydis \u017einomas compile-time \u274c C masyvai \u2192 Tik legacy code  </p>"},{"location":"arrays/array-evolution/#key-takeaway_6","title":"\ud83d\udca1 Key Takeaway","text":"<p><code>std::vector</code> yra papras\u010diausias b\u016bdas dirbti su dinaminiais masyvais! Nereikia r\u016bpintis atminties valdymu - C++ daro visk\u0105 automati\u0161kai. Tiesiog <code>push_back</code> / <code>emplace_back</code> ir d\u017eiaukis! \ud83c\udf89</p>"},{"location":"arrays/array-evolution/#8-etapas-8-smart-pointers","title":"8\ufe0f\u20e3 Etapas 8: Smart Pointers","text":""},{"location":"arrays/array-evolution/#modern-c-polimorfizmas","title":"Modern C++ polimorfizmas","text":"unique_ptr su polimorfizmu (atviras) <pre><code>    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, double g, const std::string&amp; topic) \n        : Student(n, a, g), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n</code></pre> <p>\u2705 Polimorfizmas + automatinis cleanup + RAII!</p> Pilnas kodas <pre><code>// demo_08.cpp - Smart pointers su polimorfizmu\n// Demonstracija: unique_ptr, shared_ptr, automatinis cleanup\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nclass Student {\nprotected:\n    std::string name;\n    int age;\n    double grade;\n\npublic:\n    Student(const std::string&amp; n, int a, double g) \n        : name(n), age(a), grade(g) {\n        std::cout &lt;&lt; \"\ud83d\udcda Student konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual ~Student() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f Student destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    virtual void print() const {\n        std::cout &lt;&lt; \"Student: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; std::endl;\n    }\n\n    virtual std::string get_type() const { return \"Student\"; }\n};\n\nclass GraduateStudent : public Student {\nprivate:\n    std::string thesis_topic;\n\npublic:\n    GraduateStudent(const std::string&amp; n, int a, double g, const std::string&amp; topic) \n        : Student(n, a, g), thesis_topic(topic) {\n        std::cout &lt;&lt; \"\ud83c\udf93 GraduateStudent konstruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    ~GraduateStudent() override {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f GraduateStudent destruktorius: \" &lt;&lt; name &lt;&lt; std::endl;\n    }\n\n    void print() const override {\n        std::cout &lt;&lt; \"Graduate: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age \n                  &lt;&lt; \", Grade: \" &lt;&lt; grade &lt;&lt; \", Thesis: \" &lt;&lt; thesis_topic &lt;&lt; std::endl;\n    }\n\n    std::string get_type() const override { return \"GraduateStudent\"; }\n};\n\nvoid demonstrate_unique_ptr() {\n    std::cout &lt;&lt; \"\\n=== unique_ptr demonstracija ===\\n\";\n\n    // Vector su unique_ptr - polimorfizmas\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n\n    students.push_back(std::make_unique&lt;Student&gt;(\"Jonas\", 20, 8.5));\n    students.push_back(std::make_unique&lt;GraduateStudent&gt;(\"Petras\", 25, 9.0, \"AI\"));\n    students.push_back(std::make_unique&lt;Student&gt;(\"Marija\", 19, 8.8));\n    students.push_back(std::make_unique&lt;GraduateStudent&gt;(\"Tomas\", 26, 9.2, \"ML\"));\n\n    std::cout &lt;&lt; \"\\n--- Visi studentai (teisingas polimorfizmas) ---\\n\";\n    for (const auto&amp; student : students) {\n        std::cout &lt;&lt; \"Type: \" &lt;&lt; student-&gt;get_type() &lt;&lt; \" - \";\n        student-&gt;print();\n    }\n\n    std::cout &lt;&lt; \"\\n--- Automatinis cleanup ---\\n\";\n}\n\nvoid demonstrate_shared_ptr() {\n    std::cout &lt;&lt; \"\\n=== shared_ptr demonstracija ===\\n\";\n\n    auto student1 = std::make_shared&lt;Student&gt;(\"Shared1\", 20, 8.0);\n    auto student2 = std::make_shared&lt;GraduateStudent&gt;(\"Shared2\", 25, 9.0, \"Data Science\");\n\n    std::cout &lt;&lt; \"\\nstudent1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; \"\\n\";\n\n    {\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group1;\n        std::vector&lt;std::shared_ptr&lt;Student&gt;&gt; group2;\n\n        group1.push_back(student1);\n        group1.push_back(student2);\n\n        group2.push_back(student1);  // Tas pats objektas!\n\n        std::cout &lt;&lt; \"\\nPo prid\u0117jimo \u012f vector'ius:\\n\";\n        std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; \"\\n\";\n        std::cout &lt;&lt; \"student2 use_count: \" &lt;&lt; student2.use_count() &lt;&lt; \"\\n\";\n\n        std::cout &lt;&lt; \"\\n--- Vector'iai sunaikinami ---\\n\";\n    }\n\n    std::cout &lt;&lt; \"\\nPo vector'i\u0173 sunaikinimo:\\n\";\n    std::cout &lt;&lt; \"student1 use_count: \" &lt;&lt; student1.use_count() &lt;&lt; \"\\n\";\n}\n\nclass StudentManager {\nprivate:\n    std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\n\npublic:\n    StudentManager() {\n        std::cout &lt;&lt; \"\ud83c\udfd7\ufe0f StudentManager konstruktorius\\n\";\n    }\n\n    ~StudentManager() {\n        std::cout &lt;&lt; \"\ud83d\uddd1\ufe0f StudentManager destruktorius\\n\";\n    }\n\n    template&lt;typename StudentType, typename... Args&gt;\n    void emplace_student(Args&amp;&amp;... args) {\n        students.push_back(std::make_unique&lt;StudentType&gt;(std::forward&lt;Args&gt;(args)...));\n    }\n\n    void print_all() const {\n        std::cout &lt;&lt; \"\\n--- StudentManager (\" &lt;&lt; students.size() &lt;&lt; \" student\u0173) ---\\n\";\n        for (const auto&amp; student : students) {\n            std::cout &lt;&lt; \"Type: \" &lt;&lt; student-&gt;get_type() &lt;&lt; \" - \";\n            student-&gt;print();\n        }\n    }\n\n    size_t size() const { return students.size(); }\n};\n\nint main() {\n    std::cout &lt;&lt; \"=== Smart pointers su polimorfizmu ===\\n\";\n\n    demonstrate_unique_ptr();\n    demonstrate_shared_ptr();\n\n    // StudentManager testas\n    std::cout &lt;&lt; \"\\n=== StudentManager su smart pointers ===\\n\";\n    StudentManager manager;\n\n    manager.emplace_student&lt;Student&gt;(\"A\", 20, 8.0);\n    manager.emplace_student&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"Robotics\");\n    manager.emplace_student&lt;Student&gt;(\"C\", 21, 7.5);\n    manager.emplace_student&lt;GraduateStudent&gt;(\"D\", 26, 8.8, \"CV\");\n\n    manager.print_all();\n\n    std::cout &lt;&lt; \"\\n=== Destruktoriai ===\\n\";\n    return 0;\n}\n</code></pre>"},{"location":"arrays/array-evolution/#smart-pointer-tipai","title":"Smart pointer tipai","text":"unique_ptrshared_ptr <pre><code>std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; students;\nstudents.push_back(std::make_unique&lt;Student&gt;(\"A\", 20, 8.0));\nstudents.push_back(std::make_unique&lt;GraduateStudent&gt;(\"B\", 25, 9.0, \"AI\"));\n\n// Automatinis cleanup!\n</code></pre> <p>\u2705 Vienasmen\u0117 ownership \u2705 Zero overhead \u2705 Move-only</p> <pre><code>auto student = std::make_shared&lt;Student&gt;(\"Jonas\", 20, 8.5);\n\ngroup1.push_back(student);  // use_count = 2\ngroup2.push_back(student);  // use_count = 3\n\n// Sunaikinamas kai use_count = 0\n</code></pre> <p>\u2705 Bendras ownership \u2705 Reference counting \u26a0\ufe0f \u0160iek tiek overhead</p>"},{"location":"arrays/array-evolution/#palyginimas_1","title":"Palyginimas","text":"Tipas Ownership Kopijavimas Naudojimas <code>unique_ptr</code> Vienasmen\u0117 \u274c Tik move Da\u017eniausiai <code>shared_ptr</code> Bendras \u2705 Ref count Dalijamasi <code>weak_ptr</code> Nestiprus \u2705 Cikl\u0173 vengimas"},{"location":"arrays/array-evolution/#key-takeaway_7","title":"\ud83d\udca1 Key Takeaway","text":"<p><code>vector&lt;unique_ptr&lt;Base&gt;&gt;</code> - Modern C++ b\u016bdas polimorfizmui. Automatinis cleanup + zero overhead.</p>"},{"location":"arrays/array-evolution/#galutine-santrauka","title":"\ud83d\udcca Galutin\u0117 santrauka","text":""},{"location":"arrays/array-evolution/#kada-ka-naudoti","title":"Kada k\u0105 naudoti?","text":"<pre><code>graph TD\n    A[Reikia objekt\u0173 masyvo?] --&gt; B{\u017dinomas dydis?}\n    B --&gt;|Taip| C{Reikia STL?}\n    B --&gt;|Ne| D{Polimorfizmas?}\n\n    C --&gt;|Taip| E[std::array]\n    C --&gt;|Ne| F[C masyvas - vengti!]\n\n    D --&gt;|Taip| G[vector&amp;lt;unique_ptr&amp;lt;T&amp;gt;&amp;gt;]\n    D --&gt;|Ne| H[vector&amp;lt;T&amp;gt;]\n\n    style H fill:#6f6\n    style G fill:#66f\n    style E fill:#f96</code></pre>"},{"location":"arrays/array-evolution/#praktines-rekomendacijos","title":"Praktin\u0117s rekomendacijos","text":"Scenarijus Sprendimas Kod\u0117l Vienodo tipo, \u017einomas dydis <code>std::array&lt;T, N&gt;</code> Compile-time, STL Vienodo tipo, dinaminis <code>std::vector&lt;T&gt;</code> DEFAULT! Polimorfizmas <code>vector&lt;unique_ptr&lt;T&gt;&gt;</code> Modern C++ Legacy kodas C masyvai Vengti!"},{"location":"arrays/array-evolution/#dazniausios-klaidos","title":"Da\u017eniausios klaidos","text":"1. Object Slicing <pre><code>// \u274c BLOGAI\nStudent arr[3] = {\n    Student(\"A\", 20, 8.0),\n    GraduateStudent(\"B\", 25, 9.0, \"AI\"),  // \ud83d\udca5 Slicing!\n};\n\n// \u2705 GERAI\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; arr;\narr.push_back(std::make_unique&lt;GraduateStudent&gt;(...));\n</code></pre> 2. Memory Leaks <pre><code>// \u274c BLOGAI\nStudent** arr = new Student*[3];\narr[0] = new Student(...);\n// Pamir\u0161tas delete!\n\n// \u2705 GERAI\nstd::vector&lt;std::unique_ptr&lt;Student&gt;&gt; arr;\n// Automatinis cleanup\n</code></pre> 3. Shallow Copy <pre><code>// \u274c BLOGAI - be Rule of Three\nclass Manager {\n    Student* arr;\n    // Tr\u016bksta copy/assignment!\n};\n\n// \u2705 GERAI\nclass Manager {\n    std::vector&lt;Student&gt; arr;  // Auto deep copy\n};\n</code></pre>"},{"location":"arrays/array-evolution/#mokymosi-kelias","title":"\ud83c\udfaf Mokymosi kelias","text":"<ol> <li>Prad\u0117k nuo C masyv\u0173 \u2192 Suprasi problemas</li> <li>Pereik prie <code>std::array</code> \u2192 STL + saugumas</li> <li>I\u0161mok <code>std::vector</code> \u2192 Da\u017eniausiai naudojamas</li> <li>Prid\u0117k smart pointers \u2192 Polimorfizmas</li> <li>Praktikuok su projektais \u2192 \u012etvirtinimas</li> </ol>"},{"location":"arrays/array-evolution/#papildoma-medziaga","title":"\ud83d\udcda Papildoma med\u017eiaga","text":"Nuorodos \u012f detalius README <ul> <li>Etapas 1 - README</li> <li>Etapas 4 - README</li> <li>Etapas 8 - README</li> </ul> Build'inimo instrukcijos <pre><code># Vienas failas\ng++ -std=c++17 code/arrays/07_std_vector/demo.cpp -o demo\n\n# Su Makefile\ncd code/arrays/\nmake all\n</code></pre> <p>Pagrindin\u0117 \u017einut\u0117: Modern C++ suteikia galingus \u012frankius objekt\u0173 masyv\u0173 valdymui. Naudok STL konteinerius ir smart pointers - jie sprend\u017eia problemas automati\u0161kai ir saugiai! \ud83d\ude80</p>"},{"location":"arrays/array-evolution/#refleksija-ir-isivertinimas","title":"\ud83c\udf93 Refleksija ir \u012fsivertinimas","text":""},{"location":"arrays/array-evolution/#pagrindiniai-terminai","title":"Pagrindiniai terminai","text":"Termin\u0173 \u017eodynas (click to expand) <p>Default konstruktorius Konstruktorius be parametr\u0173, automati\u0161kai i\u0161kvie\u010diamas masyvuose.</p> <p>Parametrinis konstruktorius Konstruktorius su parametrais, leid\u017eia inicializuoti objekt\u0105 konkre\u010diomis reik\u0161m\u0117mis.</p> <p>Object slicing I\u0161vestin\u0117s klas\u0117s objekto \"nupjovimas\" \u012f bazin\u0119 klas\u0119 kai kopijuojamas \u012f bazin\u0117s klas\u0117s objekt\u0105 arba masyv\u0105.</p> <p>RAII (Resource Acquisition Is Initialization) Resurs\u0173 valdymo principas - resursai \u012fgyjami konstruktoriuje, atlaisvinami destruktoriuje.</p> <p>Shallow copy vs Deep copy - Shallow copy - kopijuojama tik rodykl\u0117s reik\u0161m\u0117 (abi rodykl\u0117s rodo \u012f t\u0105 pat\u012f objekt\u0105) - Deep copy - sukuriamas naujas objektas su nukopijuotais duomenimis</p> <p>Rule of Three Jei klas\u0117 valdo dinaminius resursus, turi tur\u0117ti: 1. Destruktori\u0173 2. Copy konstruktori\u0173 3. Assignment operatori\u0173</p> <p>Smart pointer Klas\u0117, kuri automati\u0161kai valdo dinamin\u0119 atmint\u012f (RAII principu).</p> <p>Ownership Kas \"valdo\" objekt\u0105 ir atsakingas u\u017e jo sunaikinim\u0105.</p>"},{"location":"arrays/array-evolution/#savipatikra","title":"Savipatikra","text":"Patikrink ar supratai (click to expand) <p>Q1: Kod\u0117l <code>Student arr[3]</code> neveikia su parametriniu konstruktoriumi?</p> Atsakymas <p>C++ standartas reikalauja vienodo inicializavimo b\u016bdo compile-time. Masyvas negali \u017einoti skirting\u0173 parametr\u0173 kiekvienam elementui. Tod\u0117l automati\u0161kai kvie\u010diamas tik default konstruktorius.</p> <p>Q2: Kada naudoti <code>std::array</code> vs <code>std::vector</code>?</p> Atsakymas <ul> <li><code>std::array&lt;T, N&gt;</code> - kai dydis \u017einomas compile time, reikia maksimalaus performance</li> <li><code>std::vector&lt;T&gt;</code> - kai dydis dinaminis runtime, reikia lankstesnio valdymo</li> </ul> <p>Q3: Kas nutinka be Rule of Three su dinaminiais masyvais?</p> Atsakymas <p>Shallow copy \u2192 abi kopijos rodo \u012f t\u0105 pat\u012f masyv\u0105 \u2192  sunaikinus vien\u0105 objekt\u0105 kitas bando naikinti jau sunaikint\u0105 masyv\u0105 \u2192  double delete \u2192 crash \ud83d\udca5</p> <p>Q4: Kod\u0117l polimorfizmui reikia rodykli\u0173 masyvo, ne objekt\u0173?</p> Atsakymas <p>Objekt\u0173 masyvas sukelia object slicing - i\u0161vestin\u0117s klas\u0117s dalis \"nukerpama\". Rodykli\u0173 masyvas i\u0161laiko piln\u0105 objekto tip\u0105 per virtualius metodus.</p> <p>Q5: Kuo <code>unique_ptr</code> skiriasi nuo <code>shared_ptr</code>?</p> Atsakymas <ul> <li><code>unique_ptr</code> - vienasmen\u0117 ownership, negalima kopijuoti, tik move</li> <li><code>shared_ptr</code> - bendras ownership, reference counting, galima kopijuoti</li> </ul>"},{"location":"arrays/array-evolution/#pries-einant-toliau","title":"Prie\u0161 einant toliau","text":"Checklist - \u012fsitikink, kad supranti <p>Atminties valdymas</p> <ul> <li>[ ] Skirtumas tarp stack ir heap atminties</li> <li>[ ] Kod\u0117l reikia <code>delete[]</code> su <code>new[]</code></li> <li>[ ] Kas yra memory leak ir kaip jo i\u0161vengti</li> <li>[ ] RAII principas</li> </ul> <p>Masyvai</p> <ul> <li>[ ] C masyvo vs <code>std::array</code> vs <code>std::vector</code> skirtumai</li> <li>[ ] Kada kuris tinka</li> <li>[ ] Inicializacijos s\u0105ra\u0161o sintaks\u0117</li> </ul> <p>OOP konceptai</p> <ul> <li>[ ] Object slicing problema</li> <li>[ ] Kada polimorfizmui reikia rodykli\u0173</li> <li>[ ] Rule of Three paskirtis</li> <li>[ ] Deep copy vs shallow copy</li> </ul> <p>Modern C++</p> <ul> <li>[ ] <code>unique_ptr</code> naudojimas</li> <li>[ ] <code>shared_ptr</code> naudojimas</li> <li>[ ] Kada naudoti smart pointers</li> </ul> <p>\u26a0\ufe0f Jei ko nors nesupranti - gr\u012f\u017ek \u012f atitinkamus etapus!</p>"},{"location":"arrays/array-evolution/#dazniausios-klaidos_1","title":"Da\u017eniausios klaidos","text":"Common pitfalls - ko vengti <p>1. Memory leak</p> <pre><code>// \u274c BLOGAI\nStudent* arr = new Student[10];\n// ... naudojame ...\n// Pamir\u0161ome delete[]! \ud83d\udca5\n</code></pre> <p>Sprendimas: Naudok <code>std::vector</code> arba <code>unique_ptr</code></p> <p>2. Object slicing</p> <pre><code>// \u274c BLOGAI\nStudent arr[3] = {\n    Student(\"A\", 20, 8.0),\n    GraduateStudent(\"B\", 25, 9.0, \"AI\"),  // \ud83d\udca5 Slicing!\n};\n</code></pre> <p>Sprendimas: Naudok rodykli\u0173 masyv\u0105 arba <code>vector&lt;unique_ptr&lt;Student&gt;&gt;</code></p> <p>3. Shallow copy crash</p> <pre><code>// \u274c BLOGAI - be Rule of Three\nclass Manager {\n    Student* arr;\npublic:\n    Manager(int n) { arr = new Student[n]; }\n    ~Manager() { delete[] arr; }\n    // Tr\u016bksta copy constructor ir assignment!\n};\n\nManager m1(10);\nManager m2 = m1;  // \ud83d\udca5 Shallow copy \u2192 double delete!\n</code></pre> <p>Sprendimas: Implementuok Rule of Three arba naudok <code>std::vector</code></p> <p>4. Off-by-one errors</p> <pre><code>// \u274c BLOGAI\nfor (int i = 0; i &lt;= arr.size(); i++) {  // &lt;= vietoj &lt;\n    arr[i].print();  // \ud83d\udca5 Vir\u0161ija ribas!\n}\n</code></pre> <p>Sprendimas: Visada <code>i &lt; size</code>, ne <code>i &lt;= size</code></p> <p>5. Dangling pointer</p> <pre><code>// \u274c BLOGAI\nStudent* get_student() {\n    Student s(\"Jonas\", 20, 8.5);\n    return &amp;s;  // \ud83d\udca5 Gr\u0105\u017eina rodykl\u0119 \u012f lokal\u0173 objekt\u0105!\n}\n</code></pre> <p>Sprendimas: Gr\u0105\u017eink <code>std::unique_ptr</code> arba objekt\u0105 pagal reik\u0161m\u0119</p>"},{"location":"arrays/array-evolution/#praktiniai-patarimai","title":"Praktiniai patarimai","text":"Best practices <p>\u2705 Rekomenduojami b\u016bdai</p> <ol> <li>Default pasirinkimas: <code>std::vector&lt;T&gt;</code></li> <li>Dinaminis dydis</li> <li>Automatinis atminties valdymas</li> <li> <p>STL algoritmai</p> </li> <li> <p>\u017dinomas dydis: <code>std::array&lt;T, N&gt;</code></p> </li> <li>Compile-time dydis</li> <li>Stack atmintis</li> <li> <p>Zero overhead</p> </li> <li> <p>Polimorfizmas: <code>std::vector&lt;std::unique_ptr&lt;Base&gt;&gt;</code></p> </li> <li>Modern C++ stilius</li> <li>Automatinis cleanup</li> <li> <p>Efektyvus</p> </li> <li> <p>Dalinamasi objektais: <code>std::shared_ptr</code></p> </li> <li>Kai keletas \"savinink\u0173\"</li> <li>Reference counting</li> <li>Thread-safe (su atomic operations)</li> </ol> <p>\u274c Ko vengti</p> <ol> <li>~~<code>new[]</code> / <code>delete[]</code>~~ \u2192 Naudok <code>std::vector</code></li> <li>~~C masyvai~~ \u2192 Naudok <code>std::array</code> arba <code>std::vector</code></li> <li>~~Raw pointers ownership~~ \u2192 Naudok smart pointers</li> <li>~~Manual memory management~~ \u2192 Naudok RAII</li> </ol>"},{"location":"arrays/array-evolution/#tolesniam-skaitymui","title":"Tolesniam skaitymui","text":"Papildoma med\u017eiaga <p>Oficiali dokumentacija</p> <ul> <li>C++ Reference - std::vector</li> <li>C++ Reference - std::array</li> <li>C++ Reference - Smart Pointers</li> </ul> <p>Knygos</p> <ul> <li>Effective Modern C++ - Scott Meyers (Items 18-22)</li> <li>C++ Primer - Stanley Lippman (Chapter 12)</li> </ul> <p>Video</p> <ul> <li>CppCon talks about RAII and smart pointers</li> <li>Back to Basics: RAII and the Rule of Zero</li> </ul> <p>S\u0117km\u0117s mokantis C++! \ud83d\ude80 Jei kyla klausim\u0173 - visada galima gr\u012f\u017eti \u012f bet kur\u012f etap\u0105 ir per\u017ei\u016br\u0117ti dar kart\u0105.</p>"},{"location":"betterc/ParamPass/","title":"Parametr\u0173 perdavimo mechanizmai","text":""},{"location":"betterc/ParamPass/#value-vs-pointer-vs-reference","title":"Value vs. Pointer vs. Reference","text":""},{"location":"betterc/ParamPass/#1-perdavimas-pagal-reiksme-callpass-by-value","title":"1. Perdavimas pagal reik\u0161m\u0119 (call/pass by value)","text":"<p>Tai vienintelis \"tikras\" C kalbos mechanizmas.</p> <ul> <li>\u012e funkcij\u0105 perduodamos kopijos.</li> <li>Funkcija turi savo lokalius kintamuosius (<code>temp</code>, <code>x</code>, <code>y</code>).</li> <li>Original\u016bs kintamieji <code>main</code> funkcijoje N\u0116RA kei\u010diami.</li> </ul>  Tai saugu, bet neefektyvu dideliems objektams ir netinka, kai norime pakeisti original\u0105.  <pre><code>void swap_val(int x, int y) { // Gauna KOPIJAS (x=1, y=2)\n    int temp = x;\n    x = y;\n    y = temp;\n} // \u010cia kopijos sunaikinamos. Originalai a ir b nepakito.\n</code></pre> <p>\ud83d\udc49 Python Tutor</p>"},{"location":"betterc/ParamPass/#2-c-rodyklemis-imituojamas-perdavimas-pagal-nuoroda-callpass-by-reference","title":"2. C rodykl\u0117mis imituojamas perdavimas pagal nuorod\u0105 (\"call/pass by reference\")","text":"<p>C kalboje nor\u0117dami pakeisti original\u0105, turime \"gudrauti\" naudodami adresus.</p> <ol> <li>Parametrai tampa rodykl\u0117mis (<code>int*</code>).</li> <li>Naudojame i\u0161adresavimo (dereference) operatori\u0173 <code>*</code>, kad pasiektume reik\u0161m\u0119.</li> <li>Kvie\u010diant funkcij\u0105, siun\u010diame adresus (<code>&amp;a</code>).</li> </ol> <pre><code>void swap_ptr(int* x, int* y) { // Gauna ADRESUS\n    int temp = *x; // Paimk reik\u0161m\u0119 i\u0161 adreso x\n    *x = *y;       // \u012era\u0161yk y reik\u0161m\u0119 \u012f x adres\u0105\n    *y = temp;     // \u012era\u0161yk temp \u012f y adres\u0105\n}\n\n// Kvietimas: swap_ptr(&amp;a, &amp;b);\n</code></pre> <p>\ud83d\udc49 Vizualizuoti atmint\u012f (Python Tutor)</p>"},{"location":"betterc/ParamPass/#3-c-perdavimas-pagal-nuorodas-callpass-by-reference","title":"3. C++ perdavimas pagal nuorodas (call/pass by reference)","text":"<p>C++ \u012fveda tikr\u0105j\u012f perdavim\u0105 pagal nuorod\u0105. Nuoroda (<code>int&amp;</code>) \u2013 tai pseudonimas (alias). Tai lyg antras vardas tam pa\u010diam kintamajam.</p> <ul> <li>Sintaks\u0117 \u0161varesn\u0117 (nereikia <code>*</code> ir <code>&amp;</code> funkcijos viduje).</li> <li>Kompiliatorius u\u017etikrina, kad nuoroda visada \u012f ka\u017ek\u0105 rodyt\u0173.</li> </ul> <pre><code>void swap_cpp(int&amp; x, int&amp; y) { // x yra 'a' pseudonimas\n    int temp = x;\n    x = y;         // Kei\u010dia pat\u012f original\u0105\n    y = temp;\n}\n\n// Kvietimas: swap_cpp(a, b);  &lt;- Atrodo paprastai!\n</code></pre> <p>\ud83d\udc49 I\u0161bandyti kode (Godbolt)</p>"},{"location":"betterc/ParamPass/#apibendrinimas-3-budai","title":"Apibendrinimas: 3 b\u016bdai","text":"Savyb\u0117 By Value (C/C++) Pointer (C stilius) Reference (C++ stilius) Deklaracija <code>void f(int x)</code> <code>void f(int* x)</code> <code>void f(int&amp; x)</code> Kvietimas <code>f(a)</code> <code>f(&amp;a)</code> <code>f(a)</code> Veiksmas Dirba su kopija Dirba su adresu Dirba su originalu Sintaks\u0117 Paprasta Sud\u0117tinga (<code>*</code>, <code>&amp;</code>) Paprasta Verdiktas Saugus, bet \"lokalus\" Galingas, bet pavojingas Modernus standartas <pre><code>// Tik C++ leid\u017eia ra\u0161yti taip \u0161variai:\nint main() {\n    int a=1, b=2;\n    swap_cpp(a, b); // a=2, b=1\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/","title":"Stack Evolution Guide: From Monolithic Code to ADT","text":""},{"location":"evolution/Claude_stack_evolution_guide/#ivadas-kodel-adt-abstract-data-type","title":"\ud83d\udcda \u012evadas: Kod\u0117l ADT (Abstract Data Type)?","text":"<p>\u0160is vadovas parodo evoliucin\u012f keli\u0105 nuo papras\u010diausio monolitinio kodo iki pilnaver\u010dio Abstract Data Type su enkapsulacija C kalboje. Kiekvienas \u017eingsnis atskleid\u017eia realias problemas ir j\u0173 sprendimus.</p> <p>Pagrindin\u0117 id\u0117ja: Mokymasis per klaidas - kiekviena versija rodo, KOD\u0116L reikia sekan\u010dio \u017eingsnio.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#mokymosi-tikslai","title":"\ud83c\udfaf Mokymosi tikslai","text":"<p>Po \u0161io vadovo suprasite:</p> <ul> <li>\u2705 Skirtum\u0105 tarp modulio ir ADT</li> <li>\u2705 Declaration vs Definition (apra\u0161as vs apibr\u0117\u017eimas)</li> <li>\u2705 Information hiding princip\u0105</li> <li>\u2705 Opaque type technik\u0105</li> <li>\u2705 Factory pattern C kalboje</li> <li>\u2705 C \u2192 C++ s\u0105sajas (OOP pagrindus)</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-1-naivus-sprendimas-viskas-vienoje-programoje","title":"Etapas 1: Naivus sprendimas - viskas vienoje programoje","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas","title":"\ud83c\udfaf Tikslas","text":"<p>Parodyti papras\u010diausi\u0105 stek\u0105, visa logika vienoje funkcijoje.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#sprendimas","title":"\ud83d\udcbb Sprendimas","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    char c;\n    init();\n\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 01_n_usestack.c -o 01_n_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia","title":"\u2705 Veikia","text":"<pre><code>&gt; 01_n_usestack.exe\n123456\n654321\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#problemos","title":"\u274c Problemos","text":"<ol> <li>Nelankstus - negalima pakartotinio naudojimo</li> <li>Global\u016bs kintamieji - <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas - negalima tur\u0117ti keli\u0173</li> <li>Nemodulin\u0117 strukt\u016bra - visa logika vienoje vietoje</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Monolitinis kodas veikia ma\u017eoms programoms, bet n\u0117ra skalabilus ir pakartotinai naudojamas.\"</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-2-dekompozicija-i-failus","title":"Etapas 2: Dekompozicija \u012f failus","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_1","title":"\ud83c\udfaf Tikslas","text":"<p>Atskirti steko logik\u0105 nuo vartotojo kodo.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#sprendimas_1","title":"\ud83d\udcbb Sprendimas","text":"<p>02_n_stack.c (steko implementacija): <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>02_n_user.c (vartotojo kodas): <pre><code>#include &lt;stdio.h&gt;\n#include \"02_n_stack.c\"  // \u26a0\ufe0f Include .c fail\u0105!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_1","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 02_n_user.c -o 02_n_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_1","title":"\u2705 Veikia","text":"<p>Kompiliuojasi ir veikia, nes <code>#include \"02_n_stack.c\"</code> \u012ftraukia vis\u0105 kod\u0105.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#blogai-bandymas-kompiliuoti-atskirai","title":"\u274c Blogai: Bandymas kompiliuoti atskirai","text":"<p>02_nx_user.c: <pre><code>#include &lt;stdio.h&gt;\n// N\u0117ra jokio include!\n\nint main(void) {\n    char c;\n    init();  // \u274c Kas yra init()?\n    while ('\\n' != (c = getchar())) \n        push(c);  // \u274c Kas yra push()?\n    while (!isEmpty()) \n        putchar(pop());  // \u274c Kas yra isEmpty(), pop()?\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_2","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 02_n_stack.c 02_nx_user.c -o 02_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#klaidos","title":"\u274c Klaidos","text":"<p>GCC: <pre><code>02_nx_user.c: In function 'main':\n02_nx_user.c:6:5: warning: implicit declaration of function 'init'\n02_nx_user.c:7:37: warning: implicit declaration of function 'push'\n02_nx_user.c:8:13: warning: implicit declaration of function 'isEmpty'\n02_nx_user.c:8:32: warning: implicit declaration of function 'pop'\n</code></pre></p> <p>Clang: <pre><code>02_nx_user.c:6:5: error: call to undeclared function 'init'\n02_nx_user.c:7:37: error: call to undeclared function 'push'\n02_nx_user.c:8:13: error: call to undeclared function 'isEmpty'\n02_nx_user.c:8:32: error: call to undeclared function 'pop'\n4 errors generated.\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_1","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Kompiliatoriui reikia deklaracij\u0173 prie\u0161 naudojim\u0105. GCC leid\u017eia 'implicit declarations' (su warning), Clang - ne.\"</p> <p>Sprendimas: Reikalingi header failai su funkcij\u0173 deklaracijomis!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-3-modulis-header-failu-klaidos","title":"Etapas 3: Modulis - Header fail\u0173 klaidos","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_2","title":"\ud83c\udfaf Tikslas","text":"<p>Sukurti teising\u0105 modul\u012f su header failu. Bet pirmiausia - suprasti da\u017eniausias klaidas!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#klaida-1-multiple-definition","title":"\u274c Klaida #1: Multiple definition","text":"<p>03_nx_stack.h (BLOGAI!): <pre><code>#define SIZE 100\n\nchar stack[SIZE];  // \u274c Apibr\u0117\u017eimas header'yje!\nint top;           // \u274c Apibr\u0117\u017eimas header'yje!\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>03_nx_stack.c: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\n\nchar stack[SIZE];  // Apibr\u0117\u017eimas .c faile\nint top;\n\nvoid init(void) { top = 0; }\nint isEmpty(void) { return 0 == top; }\nint isFull(void) { return SIZE == top; }\nvoid push(char c) {\n    if (!isFull()) stack[top++] = c;\n}\nchar pop(void) {\n    if (!isEmpty()) return stack[--top];\n    return '\\0';\n}\n</code></pre></p> <p>03_nx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_nx_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_3","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_nx_stack.c 03_nx_user.c -o 03_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#linker-klaida","title":"\u274c Linker klaida","text":"<p>GCC: <pre><code>ld.exe: multiple definition of `stack'\nld.exe: multiple definition of `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre></p> <p>Clang: <pre><code>ld: multiple definition of `stack'\nld: multiple definition of `top'\nclang: error: linker command failed with exit code 1\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kodel-klaida","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ol> <li>Header'yje: <code>char stack[SIZE];</code> - tai apibr\u0117\u017eimas (definition)</li> <li>.c faile: <code>char stack[SIZE];</code> - dar vienas apibr\u0117\u017eimas</li> <li>Kiekvienas <code>.c</code> failas, kuris \u012ftraukia header'\u012f, sukuria savo kopij\u0105</li> <li>Linker'is: \"Turiu 2 <code>stack</code> apibr\u0117\u017eimus - kurio naudoti?\"</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_2","title":"\ud83d\udcd6 Pamoka","text":"<p>Declaration vs Definition: - Declaration: \"\u017dinok, kad ka\u017ekas egzistuoja\" (<code>extern char stack[];</code>) - Definition: \"Sukurk atmint\u012f daiktui\" (<code>char stack[SIZE];</code>)</p> <p>Header'iuose - tik deklaracijos! Apibr\u0117\u017eimai - tik <code>.c</code> failuose.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#klaida-2-undefined-reference","title":"\u274c Klaida #2: Undefined reference","text":"<p>03_ny_stack.h (bandymas taisyti su <code>extern</code>): <pre><code>#define SIZE 100\n\nextern char stack[SIZE];  // \u2705 Deklaracija\nextern int top;           // \u2705 Deklaracija\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre></p> <p>03_ny_stack.c (bet PAMIR\u0160OME apibr\u0117\u017eti!): <pre><code>#include &lt;stdio.h&gt;\n#include \"03_ny_stack.h\"\n\nvoid init(void) {\n    top = 0;  // Naudojame 'top', bet JO N\u0116RA!\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;  // Naudojame 'stack', bet JO N\u0116RA!\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_4","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_ny_stack.c 03_ny_user.c -o 03_ny_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#linker-klaida_1","title":"\u274c Linker klaida","text":"<pre><code>ld.exe: undefined reference to `stack'\nld.exe: undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kodel-klaida_1","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ol> <li>Header'yje: <code>extern char stack[SIZE];</code> - tik deklaracija</li> <li>.c faile: N\u0116RA apibr\u0117\u017eimo <code>char stack[SIZE];</code></li> <li>Linker'is: \"\u017dinau, kad <code>stack</code> turi egzistuoti, bet KUR jis?\"</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_3","title":"\ud83d\udcd6 Pamoka","text":"<p><code>extern</code> sako \"tai egzistuoja ka\u017ekur kitur\". Bet tas \"ka\u017ekur kitur\" turi b\u016bti tikrai apibr\u0117\u017etas!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#teisingas-sprendimas","title":"\u2705 Teisingas sprendimas","text":"<p>03_stack.h: <pre><code>// Tik deklaracijos\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>03_stack.c: <pre><code>#include \"03_stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];  // \u2705 Apibr\u0117\u017eimas .c faile\nint top;           // \u2705 Apibr\u0117\u017eimas .c faile\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>03_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_5","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_user.c -o 03_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_2","title":"\u2705 Veikia!","text":"<p>Bet... ar tikrai saugus?</p>"},{"location":"evolution/Claude_stack_evolution_guide/#ataka-ant-modulio","title":"\ud83d\udd13 \"Ataka\" ant modulio","text":"<p>03_z_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"\n\nextern char stack[];  // Galiu pasiekti globalius kintamuosius!\nextern int top;\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd13 ATAKA! Tiesiogin\u0117 manipuliacija!\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_6","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_z_user.c -o 03_z_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliuojasi","title":"\u2705 Kompiliuojasi!","text":"<pre><code>&gt; 03_z_use_stack.exe\n123\n!321   // \u2190 '!' buvo \u012fterpta!\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_4","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Jei duomenys global\u016bs, jie NEAPSAUGOTI nuo klaid\u0173 ar piktnaud\u017eiavimo!\"</p> <p>Modulis \u2260 Enkapsulacija</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-4-information-hiding-su-static","title":"Etapas 4: Information Hiding su <code>static</code>","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_3","title":"\ud83c\udfaf Tikslas","text":"<p>Pasl\u0117pti steko realizacijos detales nuo i\u0161or\u0117s pasaulio.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#sprendimas_2","title":"\ud83d\udcbb Sprendimas","text":"<p>04_stack.h: <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>04_stack.c: <pre><code>#include \"04_stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];  // \u2705 PRIVATE!\nstatic int top;           // \u2705 PRIVATE!\n\nstatic void reset(void) { // \u2705 Helper funkcija - PRIVATE!\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>04_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"04_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_7","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 04_stack.c 04_user.c -o 04_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_3","title":"\u2705 Veikia!","text":""},{"location":"evolution/Claude_stack_evolution_guide/#ataka-nepavyksta","title":"\ud83d\udd12 \"Ataka\" NEPAVYKSTA!","text":"<p>04_zx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"04_stack.h\"\n\nextern char stack[];  // Bandau pasiekti\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd12 Bandau atakuoti\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n\n    reset();  // \ud83d\udd12 Bandau i\u0161kviesti privat\u0173 metod\u0105\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_8","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 04_stack.c 04_zx_user.c -o 04_zx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#linker-klaida_2","title":"\u274c Linker klaida!","text":"<pre><code>ld.exe: undefined reference to `reset'\nld.exe: undefined reference to `stack'\nld.exe: undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kas-nutiko","title":"\ud83d\udd0d Kas nutiko?","text":"<p><code>static</code> C kalboje sukuria internal linkage: - Kintamasis/funkcija matoma TIK tame <code>.c</code> faile - Kiti failai negali jos pasiekti, net su <code>extern</code> - Tai C kalbos b\u016bdas padaryti \"private\" duomenis</p>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_5","title":"\ud83d\udcd6 Pamoka","text":"<p>Information Hiding principas: - Pasl\u0117pti realizacijos detales - Eksportuoti tik s\u0105saj\u0105 (interface) - <code>static</code> \u2248 <code>private</code> C++ kalboje</p>"},{"location":"evolution/Claude_stack_evolution_guide/#problema","title":"\u26a0\ufe0f Problema","text":"<p>Vis tiek tik vienas stekas! Negalime tur\u0117ti <code>st1</code>, <code>st2</code> egzempliori\u0173.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-5-user-defined-type-3-klaidos-anatomija","title":"Etapas 5: User Defined Type - 3 klaidos anatomija","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_4","title":"\ud83c\udfaf Tikslas","text":"<p>Sukurti tip\u0105, kad gal\u0117tume tur\u0117ti kelis stekas.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#bandymas-1-static-strukturoje","title":"\u274c Bandymas #1: <code>static</code> strukt\u016broje","text":"<p>05_nx_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    static char stack[SIZE];  // \u274c Galvojame: \"static narys\"\n    static int top;           // \u274c Kaip C++\n};\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n// ... kitos funkcijos\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_9","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_nx_usestack.c -o 05_nx_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimo-klaida","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n</code></pre></p> <p>Clang: <pre><code>05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kodel-klaida_2","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<p>C kalba draud\u017eia storage-class specifikatorius strukt\u016bros nariams!</p> <ul> <li><code>struct</code> apra\u0161o tipo \u0161ablon\u0105</li> <li><code>static</code> taikomas kintamiesiems/funkcijoms, ne tipo nariams</li> <li>C++ turi <code>static</code> narius, bet C - NE</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_6","title":"\ud83d\udcd6 Pamoka","text":"<p>C ir C++ skiriasi! C strukt\u016bros - tik duomen\u0173 konteineriai, ne klas\u0117s.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#bandymas-2-pass-by-value","title":"\u274c Bandymas #2: Pass-by-value","text":"<p>05_ny_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nvoid init(struct Stack st) {  // \u274c Kopija!\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {  // \u274c Kopija!\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {  // \u274c Kopija!\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {  // \u274c Kopija!\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {  // \u274c Kopija!\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    struct Stack st1;\n    char c;\n\n    init(st1);\n    while ((!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(st1, c);\n    while (!isEmpty(st1)) \n        putchar(pop(st1));\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_10","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_ny_usestack.c -o 05_ny_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliuojasi_1","title":"\u2705 Kompiliuojasi!","text":""},{"location":"evolution/Claude_stack_evolution_guide/#bet-nevykdo-teisingai","title":"\u274c Bet nevykdo teisingai","text":"<pre><code>&gt; 05_ny_usestack.exe\n123\n        // \u2190 NIEKO! Tu\u0161\u010dia!\nPabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kas-nutiko_1","title":"\ud83d\udd0d Kas nutiko?","text":"<p>Pass-by-value problema:</p> <pre><code>main():\n  st1.stack = [?, ?, ?, ?, ?]  \u2190 NIEKADA nepakeistas\n  st1.top = ?                  \u2190 Neinicializuotas\n\ninit(kopija):\n  kopija.top = 0  \u2190 Modifikuoja KOPIJ\u0104\n  // Kopija nunyksta funkcijos pabaigoje\n\npush(kopija, 'c'):\n  kopija.stack[0] = '1'\n  kopija.stack[1] = '2'\n  kopija.stack[2] = '3'\n  kopija.top = 3\n  // Kopija nunyksta\n\npop(kopija):\n  return kopija.stack[--kopija.top]  \u2190 Bet originalas tu\u0161\u010dias!\n</code></pre> <p>Rezultatas: Originalus <code>st1</code> lieka nemodifikuotas!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_7","title":"\ud83d\udcd6 Pamoka","text":"<p>Pass-by-value vs Pass-by-reference: - C perdavin\u0117ja kopijas - Norint modifikuoti - reikia rodykli\u0173 (pointers) - C++ turi references (<code>&amp;</code>), C - tik pointers</p>"},{"location":"evolution/Claude_stack_evolution_guide/#teisingas-sprendimas-rodykles","title":"\u2705 Teisingas sprendimas: Rodykl\u0117s!","text":"<p>05_n_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {  // \u2705 Rodykl\u0117\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    struct Stack st1, st2;\n    char c;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);  // \u2705 Adresas\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);  // \u2705 Dar vienas stekas!\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_11","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_n_usestack.c -o 05_n_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_4","title":"\u2705 Veikia!","text":"<pre><code>&gt; 05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#pasiekta","title":"\ud83c\udf89 Pasiekta","text":"<ul> <li>\u2705 Turime tip\u0105 <code>struct Stack</code></li> <li>\u2705 Galime tur\u0117ti kelis stekas (<code>st1</code>, <code>st2</code>)</li> <li>\u2705 Tikras ADT - tipas su operacijomis</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide/#bet-dar-ne-modulis","title":"\u26a0\ufe0f Bet dar ne modulis!","text":""},{"location":"evolution/Claude_stack_evolution_guide/#etapas-6-adt-modulyje","title":"Etapas 6: ADT modulyje","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_5","title":"\ud83c\udfaf Tikslas","text":"<p>Perkelti ADT \u012f modul\u012f (header + implementation).</p>"},{"location":"evolution/Claude_stack_evolution_guide/#sprendimas_3","title":"\ud83d\udcbb Sprendimas","text":"<p>06_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];  // \u26a0\ufe0f Matomas header'yje\n    int top;           // \u26a0\ufe0f Matomas header'yje\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>06_stack.c: <pre><code>#include \"06_stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>06_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;\n    char c;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_12","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 06_stack.c 06_user.c -o 06_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_5","title":"\u2705 Veikia!","text":"<pre><code>&gt; 06_use_stack.exe\nIvesk st1\n123\n321\nst1 pabaiga\nIvesk st2\n123456\n54321\nst2 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#pasiekta_1","title":"\ud83c\udf89 Pasiekta","text":"<ul> <li>\u2705 ADT modulyje</li> <li>\u2705 Du stekai veikia</li> <li>\u2705 Gra\u017eus kodas</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide/#bet-ataka-pavyksta","title":"\ud83d\udd13 Bet \"ataka\" pavyksta!","text":"<p>06_z_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st2;\n    char c;\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n\n    st2.stack[st2.top++] = '!';  // \ud83d\udd13 Tiesiogin\u0117 manipuliacija!\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_13","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 06_stack.c 06_z_user.c -o 06_z_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliuojasi_2","title":"\u2705 Kompiliuojasi!","text":"<pre><code>&gt; 06_z_use_stack.exe\nIvesk st2\n123456\n!54321   // \u2190 Ataka pavyko!\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_8","title":"\ud83d\udcd6 Pamoka","text":"<p>Jei strukt\u016bros apibr\u0117\u017eimas matomas header'yje, tai NE enkapsulacija!</p> <p>Bet kas gali pasiekti <code>st.top</code>, <code>st.stack[i]</code>.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-7-opaque-type-tikra-enkapsulacija","title":"Etapas 7: Opaque Type - tikra enkapsulacija","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_6","title":"\ud83c\udfaf Tikslas","text":"<p>Pasl\u0117pti strukt\u016bros apibr\u0117\u017eim\u0105, palikti tik forward declaration.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#bandymas-1-stack-objektai-su-forward-declaration","title":"\u274c Bandymas #1: Stack objektai su forward declaration","text":"<p>07_n_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;  // \u2705 Forward declaration\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>07_n_stack.c: <pre><code>#include \"07_n_stack.h\"\n\nstruct Stack {  // \u2705 Pilnas apibr\u0117\u017eimas TIK .c faile\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>07_nx_user.c (bandymas su stack objektais): <pre><code>#include &lt;stdio.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;  // \u274c Bandau deklaruoti\n    // ...\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_14","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_n_stack.c 07_nx_user.c -o 07_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimo-klaida_1","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>07_nx_user.c: In function 'main':\n07_nx_user.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\n07_nx_user.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n</code></pre></p> <p>Clang: <pre><code>07_nx_user.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./07_n_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kodel-klaida_3","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ul> <li>Kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio</li> <li>Negali allokuoti <code>st1</code> ir <code>st2</code> stack'e</li> <li>Forward declaration leid\u017eia tik rodykles!</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_9","title":"\ud83d\udcd6 Pamoka","text":"<p>Incomplete type (nepilnas tipas): - Galima deklaruoti rodykles: <code>struct Stack *pst</code> - NEGALIMA deklaruoti objekt\u0173: <code>struct Stack st</code> - NEGALIMA naudoti <code>sizeof(struct Stack)</code></p>"},{"location":"evolution/Claude_stack_evolution_guide/#bandymas-2-heap-allokacija-su-calloc","title":"\u274c Bandymas #2: Heap allokacija su <code>calloc</code>","text":"<p>07_ny_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = calloc(sizeof(struct Stack), 1);  // \u274c sizeof incomplete type!\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    // ...\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_15","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_n_stack.c 07_ny_user.c -o 07_ny_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimo-klaida_2","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>07_ny_user.c: In function 'main':\n07_ny_user.c:10:26: error: invalid application of 'sizeof' \n                          to incomplete type 'struct Stack'\n   10 |     pst1 = calloc(sizeof(struct Stack), 1);\n      |                          ^~~~~~\n</code></pre></p> <p>Clang: <pre><code>07_ny_user.c:10:19: error: invalid application of 'sizeof' \n                           to an incomplete type 'struct Stack'\n   10 |     pst1 = calloc(sizeof(struct Stack), 1);\n      |                   ^     ~~~~~~~~~~~~~~\n./07_n_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#problema_1","title":"\ud83d\udd0d Problema","text":"<p>Vartotojas negali naudoti <code>sizeof(struct Stack)</code> - tipas nei\u0161baigtas!</p> <p>Sprendimas: Reikia factory funkcijos!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#teisingas-sprendimas-factory-pattern","title":"\u2705 Teisingas sprendimas: Factory Pattern","text":"<p>07_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;  // Opaque type\n\nstruct Stack* create(void);  // \u2705 Factory funkcija!\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>07_stack.c: <pre><code>#include &lt;stdlib.h&gt;\n#include \"07_stack.h\"\n\nstruct Stack {  // \u2705 Pilnas apibr\u0117\u017eimas TIK .c faile\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {  // \u2705 Factory\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>07_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();  // \u2705 Factory funkcija\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_16","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_stack.c 07_user.c -o 07_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_6","title":"\u2705 Veikia!","text":"<pre><code>&gt; 07_use_stack.exe\nIvesk st1\n123456\n54321\nst1 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#ataka-nepavyksta_1","title":"\ud83d\udd12 \"Ataka\" NEPAVYKSTA!","text":"<p>07_zx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n\n    pst1-&gt;stack[pst1-&gt;top++] = '!';  // \ud83d\udd12 Bandau atakuoti!\n\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_17","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_stack.c 07_zx_user.c -o 07_zx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimo-klaida_3","title":"\u274c Kompiliavimo klaida!","text":"<p>GCC: <pre><code>07_zx_user.c: In function 'main':\n07_zx_user.c:15:9: error: invalid use of undefined type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |         ^~\n07_zx_user.c:15:21: error: invalid use of undefined type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |                     ^~\n</code></pre></p> <p>Clang: <pre><code>07_zx_user.c:15:9: error: incomplete definition of type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |     ~~~~^\n./07_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#pergale","title":"\ud83c\udf89 Pergal\u0117!","text":"<p>Kompiliatorius neleid\u017eia pasiekti strukt\u016bros nari\u0173!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#pamoka_10","title":"\ud83d\udcd6 Pamoka","text":"<p>Opaque type / PIMPL (Pointer to Implementation) idiom: - Header'yje - tik forward declaration - Strukt\u016bros apibr\u0117\u017eimas - TIK .c faile - Vartotojas negali pasiekti <code>pst-&gt;member</code> - Tai kompiliatoriaus lygmens enkapsulacija!</p>"},{"location":"evolution/Claude_stack_evolution_guide/#etapas-8-full-lifecycle-raii-intro","title":"Etapas 8: Full Lifecycle + RAII intro","text":""},{"location":"evolution/Claude_stack_evolution_guide/#tikslas_7","title":"\ud83c\udfaf Tikslas","text":"<p>Prid\u0117ti piln\u0105 objekto lifecycle valdym\u0105 ir paruo\u0161ti C++ RAII koncepcijos \u012fvad\u0105.</p>"},{"location":"evolution/Claude_stack_evolution_guide/#sprendimas_4","title":"\ud83d\udcbb Sprendimas","text":"<p>077_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);   // Constructor\nvoid destroy(struct Stack *); // \u2705 Destructor!\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>077_stack.c: <pre><code>#include &lt;stdlib.h&gt;\n#include \"077_stack.h\"\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) {  // \u2705 Atlaisvinimas!\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>077_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"077_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();  // \u2705 Suk\u016brimas\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    destroy(pst1);  // \u2705 Sunaikinimas\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide/#kompiliavimas_18","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 077_stack.c 077_user.c -o 077_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#veikia_7","title":"\u2705 Veikia!","text":"<pre><code>&gt; 077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#pasiekta-pilnas-adt-c-kalboje","title":"\ud83c\udf89 Pasiekta: Pilnas ADT C kalboje!","text":"<p>Turime: - \u2705 Opaque type - strukt\u016bra pasl\u0117pta - \u2705 Factory pattern - <code>create()</code> - \u2705 Enkapsulacija - duomenys nepasiekiami - \u2705 Full lifecycle - <code>create()</code> / <code>destroy()</code> - \u2705 Modulin\u0117 strukt\u016bra - header + implementation - \u2705 Information hiding - <code>static</code> nariai</p>"},{"location":"evolution/Claude_stack_evolution_guide/#c-c-tiltas-raii-ivadas","title":"\ud83d\udd17 C \u2192 C++ tiltas: RAII \u012fvadas","text":"<p>C kalboje: <pre><code>struct Stack *pst = create();  // Manual suk\u016brimas\n// ... naudojimas\ndestroy(pst);                  // Manual sunaikinimas\n</code></pre></p> <p>Problemos: 1. \u274c Galima pamir\u0161ti <code>destroy()</code> \u2192 memory leak 2. \u274c Jei klaida tarp <code>create()</code> ir <code>destroy()</code> \u2192 leak 3. \u274c Reikia sekti kiekvieno objekto lifecycle rankomis</p> <p>C++ sprendimas: RAII (Resource Acquisition Is Initialization)</p> <pre><code>class Stack {\nprivate:\n    char stack[SIZE];\n    int top;\n\npublic:\n    Stack() : top(0) {}  // \u2705 Constructor - automatinis!\n    ~Stack() {}          // \u2705 Destructor - automatinis!\n\n    void push(char c) {\n        if (top &lt; SIZE) stack[top++] = c;\n    }\n\n    char pop() {\n        if (top &gt; 0) return stack[--top];\n        return '\\0';\n    }\n};\n\nint main() {\n    Stack st1;  // \u2705 Constructor automati\u0161kai i\u0161kvie\u010diamas\n    st1.push('A');\n    // ...\n}  // \u2705 Destructor automati\u0161kai i\u0161kvie\u010diamas i\u0161einant i\u0161 scope!\n</code></pre> <p>RAII garantijos: - \u2705 Constructor visuomet i\u0161kvie\u010diamas objekto suk\u016brimo metu - \u2705 Destructor visuomet i\u0161kvie\u010diamas objekto sunaikinimo metu - \u2705 Automatinis resource valdymas - \u2705 Exception-safe - destructor i\u0161kviestas net klaidos atveju</p>"},{"location":"evolution/Claude_stack_evolution_guide/#evoliucijos-apzvalga","title":"\ud83d\udcd6 Evoliucijos ap\u017evalga","text":"Etapas Sprendimas Pasiekta Tr\u016bkumai 1 Monolitinis kodas Veikia Nelankstus, global\u016bs 2 Fail\u0173 atskyrimas Dekompozicija N\u0117ra header fail\u0173 3 Modulis Header + .c Global\u016bs duomenys 4 Information hiding <code>static</code> Tik 1 stekas 5 User Defined Type Keletas stekas N\u0117ra enkapsuliacijos 6 ADT modulyje Tipas + modulis Duomenys matomi 7 Opaque type Enkapsulacija Reikia manual destroy 8 Full lifecycle RAII \u012fvadas Manual lifecycle (C)"},{"location":"evolution/Claude_stack_evolution_guide/#pagrindines-pamokos","title":"\ud83c\udf93 Pagrindin\u0117s pamokos","text":""},{"location":"evolution/Claude_stack_evolution_guide/#1-declaration-vs-definition","title":"1. Declaration vs Definition","text":"<pre><code>// DECLARATION (apra\u0161as)\nextern int x;\nvoid foo(void);\nstruct Stack;  // Forward declaration\n\n// DEFINITION (apibr\u0117\u017eimas)\nint x = 42;\nvoid foo(void) { /* ... */ }\nstruct Stack { /* ... */ };\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#2-storage-classes","title":"2. Storage classes","text":"<pre><code>// Global scope\nint global;           // External linkage\nstatic int internal;  // Internal linkage\nextern int external;  // Declaration\n\n// Function scope\nvoid foo(void) {\n    static int persistent;  // I\u0161lieka tarp kvietim\u0173\n    auto int local;         // Default (stack)\n    register int fast;      // Suggestion compiler'iui\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#3-incomplete-types","title":"3. Incomplete types","text":"<pre><code>struct Stack;  // Incomplete type\n\nstruct Stack *p;        // \u2705 OK - rodykl\u0117\nsizeof(struct Stack);   // \u274c KLAIDA - nepilnas tipas\nstruct Stack s;         // \u274c KLAIDA - reikia dyd\u017eio\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#4-opaque-type-pattern","title":"4. Opaque type pattern","text":"<pre><code>// Header (.h)\nstruct Type;\nstruct Type* create(void);\nvoid destroy(struct Type*);\n\n// Implementation (.c)\nstruct Type {\n    // Priva\u010dius nariai\n};\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#5-c-vs-c-enkapsulacija","title":"5. C vs C++ enkapsulacija","text":"Aspektas C C++ Private duomenys <code>static</code> .c faile <code>private:</code> klas\u0117je Constructor <code>create()</code> funkcija Automatinis <code>Type()</code> Destructor <code>destroy()</code> funkcija Automatinis <code>~Type()</code> Lifecycle Manual RAII (automatinis) Multiple instances Strukt\u016br\u0173 masyvas Objekt\u0173 masyvas"},{"location":"evolution/Claude_stack_evolution_guide/#uzduotys-studentams","title":"\ud83d\udcdd U\u017eduotys studentams","text":""},{"location":"evolution/Claude_stack_evolution_guide/#uzduotis-1-pataisyk-klaida","title":"U\u017eduotis 1: Pataisyk klaid\u0105","text":"<p>Kod\u0117l \u0161is kodas nesikompiliuoja? Kaip pataisyti?</p> <pre><code>// my_stack.h\nstruct Stack {\n    int data[100];\n    int top;\n};\n\n// my_stack.c\n#include \"my_stack.h\"\n\nstruct Stack {\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n</code></pre> Atsakymas  **Klaida:** Multiple definition of `struct Stack`  **Sprendimas:** Strukt\u016bros apibr\u0117\u017eimas turi b\u016bti TIK vienoje vietoje: - Header'yje: jei reikia matomo tipo (Etapas 6) - .c faile: jei naudojame opaque type (Etapas 7)  <pre><code>// Variantas 1: Header'yje (matomas)\n// my_stack.h\nstruct Stack {\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val);\n\n// my_stack.c\n#include \"my_stack.h\"\n// NEAPIBR\u0116\u017dIAME dar kart\u0105!\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n\n// Variantas 2: Opaque type (pasl\u0117ptas)\n// my_stack.h\nstruct Stack;  // Tik forward declaration\nvoid push(struct Stack *s, int val);\n\n// my_stack.c\n#include \"my_stack.h\"\n\nstruct Stack {  // Apibr\u0117\u017eimas TIK \u010dia\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#uzduotis-2-pass-by-value-vs-pass-by-pointer","title":"U\u017eduotis 2: Pass-by-value vs Pass-by-pointer","text":"<p>Kod\u0117l \u0161i funkcija nemodifikuoja originalaus steko?</p> <pre><code>void init(struct Stack st) {\n    st.top = 0;\n}\n\nint main(void) {\n    struct Stack s;\n    init(s);\n    printf(\"%d\\n\", s.top);  // Kas bus i\u0161spausdinta?\n}\n</code></pre> Atsakymas  **Atsakymas:** Spausdins neinicializuot\u0105 reik\u0161m\u0119 (\u0161iuk\u0161les).  **Prie\u017eastis:** `init(s)` gauna **kopij\u0105** strukt\u016bros. Modifikuoja kopij\u0105, ne original\u0105.  **Sprendimas:** <pre><code>void init(struct Stack *pst) {  // Rodykl\u0117!\n    pst-&gt;top = 0;\n}\n\nint main(void) {\n    struct Stack s;\n    init(&amp;s);  // Perduodame adres\u0105\n    printf(\"%d\\n\", s.top);  // 0\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#uzduotis-3-implementuok-queue","title":"U\u017eduotis 3: Implementuok Queue","text":"<p>Naudodami Opaque Type pattern (Etapas 7-8), implementuokite Queue ADT su: - <code>create()</code> / <code>destroy()</code> - <code>enqueue(Queue*, int)</code> - \u012fdeda \u012f gal\u0105 - <code>dequeue(Queue*)</code> - i\u0161ima i\u0161 priekio - <code>isEmpty(Queue*)</code></p> Sprendimo pavyzdys <pre><code>// queue.h\n#ifndef QUEUE_H\n#define QUEUE_H\n\n#define QUEUE_SIZE 100\n\nstruct Queue;\n\nstruct Queue* create(void);\nvoid destroy(struct Queue*);\nvoid enqueue(struct Queue*, int);\nint dequeue(struct Queue*);\nint isEmpty(struct Queue*);\n\n#endif\n\n// queue.c\n#include &lt;stdlib.h&gt;\n#include \"queue.h\"\n\nstruct Queue {\n    int data[QUEUE_SIZE];\n    int front;\n    int rear;\n    int count;\n};\n\nstruct Queue* create(void) {\n    struct Queue *q = (struct Queue*) calloc(sizeof(struct Queue), 1);\n    q-&gt;front = 0;\n    q-&gt;rear = -1;\n    q-&gt;count = 0;\n    return q;\n}\n\nvoid destroy(struct Queue *q) {\n    free(q);\n}\n\nvoid enqueue(struct Queue *q, int val) {\n    if (q-&gt;count &lt; QUEUE_SIZE) {\n        q-&gt;rear = (q-&gt;rear + 1) % QUEUE_SIZE;\n        q-&gt;data[q-&gt;rear] = val;\n        q-&gt;count++;\n    }\n}\n\nint dequeue(struct Queue *q) {\n    if (q-&gt;count &gt; 0) {\n        int val = q-&gt;data[q-&gt;front];\n        q-&gt;front = (q-&gt;front + 1) % QUEUE_SIZE;\n        q-&gt;count--;\n        return val;\n    }\n    return -1;  // Tu\u0161\u010dia\n}\n\nint isEmpty(struct Queue *q) {\n    return q-&gt;count == 0;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide/#kitas-zingsnis-c","title":"\ud83d\ude80 Kitas \u017eingsnis: C++","text":"<p>\u0160is vadovas paruo\u0161\u0117 jus C++ OOP:</p> <pre><code>class Stack {\nprivate:  // \u2248 static C kalboje\n    static const int SIZE = 100;\n    char data[SIZE];\n    int top;\n\npublic:  // \u2248 header funkcijos C kalboje\n    Stack() : top(0) {}  // \u2248 create()\n    ~Stack() {}          // \u2248 destroy()\n\n    void push(char c) {\n        if (top &lt; SIZE) data[top++] = c;\n    }\n\n    char pop() {\n        if (top &gt; 0) return data[--top];\n        return '\\0';\n    }\n\n    bool isEmpty() const {\n        return top == 0;\n    }\n};\n\n// Naudojimas\nint main() {\n    Stack s1, s2;  // \u2705 Automatinis constructor\n    s1.push('A');\n    s2.push('B');\n}  // \u2705 Automatinis destructor\n</code></pre> <p>C++ privalumai: - \u2705 Automatinis lifecycle (RAII) - \u2705 Sintaksinis <code>private</code> / <code>public</code> - \u2705 Member funkcijos - \u2705 Operator overloading - \u2705 Templates (generic programming)</p>"},{"location":"evolution/Claude_stack_evolution_guide/#papildoma-literatura","title":"\ud83d\udcda Papildoma literat\u016bra","text":"<ol> <li>K&amp;R \"The C Programming Language\" - Chapter 6 (Structures)</li> <li>\"Expert C Programming\" by Peter van der Linden</li> <li>\"C Interfaces and Implementations\" by David Hanson</li> <li>Stroustrup \"The C++ Programming Language\" - RAII (Chapter 13)</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide/#apibendrinimas","title":"\ud83c\udfac Apibendrinimas","text":"<p>Evoliucijos kelias: 1. Monolitinis kodas \u2192 Modulis 2. Global\u016bs duomenys \u2192 Information hiding (<code>static</code>) 3. Vienas stekas \u2192 User Defined Type (strukt\u016bra) 4. Matoma strukt\u016bra \u2192 Opaque type (forward declaration) 5. Manual lifecycle \u2192 Factory pattern (<code>create</code>/<code>destroy</code>) 6. C \u2192 C++ (RAII, automatinis lifecycle)</p> <p>Svarbiausios pamokos: - \u2705 Enkapsulacija - ne tik patogumas, bet saugumas - \u2705 Abstrakcija - sl\u0117pti detales, rodyti s\u0105saj\u0105 - \u2705 Modulin\u0117 strukt\u016bra - pakartotinis naudojimas - \u2705 Lifecycle valdymas - suk\u016brimas ir sunaikinimas - \u2705 C \u2192 C++ tiltas - manual \u2192 automatic</p> <p>S\u0117km\u0117s mokantis! \ud83d\ude80</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/","title":"Stack Evolution Guide: From Monolithic Code to ADT","text":"0102 <pre><code>#include &lt;stdio.h&gt;\n\n// === Sugalvojome toki\u0105 realizacij\u0105 (implementacij\u0105) ===\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\n/* Inicializavimas/nustatymas - reset() */\nvoid init(void) {\n    top = 0;\n}\n\n/* Ar stekas tu\u0161\u010dias */\nint isEmpty(void) {\n    return 0 == top;\n}\n\n/* Ar stekas pilnas */\nint isFull(void) {\n    return SIZE == top;\n}\n\n/* \u012ed\u0117ti element\u0105 \u012f stek\u0105 */\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\n/* I\u0161imti element\u0105 i\u0161 steko */\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\n// === \u010cia naudojame t\u0105 stek\u0105 ===\n\nint main(void) {\n    char c;\n\n    init();\n\n    /* Skaitome simbolius iki '\\n' */\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    /* Kol stekas netu\u0161\u010dias, spausdiname i\u0161imdami po simbol\u012f (element\u0105) */\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n\n/*\n&gt;gcc usestack.c -o app\n*/\n</code></pre> <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#ivadas-kodel-adt-abstract-data-type","title":"\ud83d\udcda \u012evadas: Kod\u0117l ADT (Abstract Data Type)?","text":"<p>\u0160is vadovas parodo evoliucin\u012f keli\u0105 nuo papras\u010diausio monolitinio kodo iki pilnaver\u010dio Abstract Data Type su enkapsulacija C kalboje. Kiekvienas \u017eingsnis atskleid\u017eia realias problemas ir j\u0173 sprendimus.</p> <p>Pagrindin\u0117 id\u0117ja: Mokymasis per klaidas - kiekviena versija rodo, KOD\u0116L reikia sekan\u010dio \u017eingsnio.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#mokymosi-tikslai","title":"\ud83c\udfaf Mokymosi tikslai","text":"<p>Po \u0161io vadovo suprasite:</p> <ul> <li>\u2705 Skirtum\u0105 tarp modulio ir ADT</li> <li>\u2705 Declaration vs Definition (apra\u0161as vs apibr\u0117\u017eimas)</li> <li>\u2705 Information hiding princip\u0105</li> <li>\u2705 Opaque type technik\u0105</li> <li>\u2705 Factory pattern C kalboje</li> <li>\u2705 C \u2192 C++ s\u0105sajas (OOP pagrindus)</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-1-naivus-sprendimas-viskas-vienoje-programoje","title":"Etapas 1: Naivus sprendimas - viskas vienoje programoje","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas","title":"\ud83c\udfaf Tikslas","text":"<p>Parodyti papras\u010diausi\u0105 stek\u0105, visa logika vienoje funkcijoje.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#sprendimas","title":"\ud83d\udcbb Sprendimas","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    char c;\n    init();\n\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 01_n_usestack.c -o 01_n_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia","title":"\u2705 Veikia","text":"<pre><code>&gt; 01_n_usestack.exe\n123456\n654321\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#problemos","title":"\u274c Problemos","text":"<ol> <li>Nelankstus - negalima pakartotinio naudojimo</li> <li>Global\u016bs kintamieji - <code>stack[]</code> ir <code>top</code> matomi visur</li> <li>Tik vienas stekas - negalima tur\u0117ti keli\u0173</li> <li>Nemodulin\u0117 strukt\u016bra - visa logika vienoje vietoje</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Monolitinis kodas veikia ma\u017eoms programoms, bet n\u0117ra skalabilus ir pakartotinai naudojamas.\"</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-2-dekompozicija-i-failus","title":"Etapas 2: Dekompozicija \u012f failus","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_1","title":"\ud83c\udfaf Tikslas","text":"<p>Atskirti steko logik\u0105 nuo vartotojo kodo.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#sprendimas_1","title":"\ud83d\udcbb Sprendimas","text":"<p>02_n_stack.c (steko implementacija): <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>02_n_user.c (vartotojo kodas): <pre><code>#include &lt;stdio.h&gt;\n#include \"02_n_stack.c\"  // \u26a0\ufe0f Include .c fail\u0105!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_1","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 02_n_user.c -o 02_n_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_1","title":"\u2705 Veikia","text":"<p>Kompiliuojasi ir veikia, nes <code>#include \"02_n_stack.c\"</code> \u012ftraukia vis\u0105 kod\u0105.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#blogai-bandymas-kompiliuoti-atskirai","title":"\u274c Blogai: Bandymas kompiliuoti atskirai","text":"<p>02_nx_user.c: <pre><code>#include &lt;stdio.h&gt;\n// N\u0117ra jokio include!\n\nint main(void) {\n    char c;\n    init();  // \u274c Kas yra init()?\n    while ('\\n' != (c = getchar())) \n        push(c);  // \u274c Kas yra push()?\n    while (!isEmpty()) \n        putchar(pop());  // \u274c Kas yra isEmpty(), pop()?\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_2","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 02_n_stack.c 02_nx_user.c -o 02_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#klaidos","title":"\u274c Klaidos","text":"<p>GCC: <pre><code>02_nx_user.c: In function 'main':\n02_nx_user.c:6:5: warning: implicit declaration of function 'init'\n02_nx_user.c:7:37: warning: implicit declaration of function 'push'\n02_nx_user.c:8:13: warning: implicit declaration of function 'isEmpty'\n02_nx_user.c:8:32: warning: implicit declaration of function 'pop'\n</code></pre></p> <p>Clang: <pre><code>02_nx_user.c:6:5: error: call to undeclared function 'init'\n02_nx_user.c:7:37: error: call to undeclared function 'push'\n02_nx_user.c:8:13: error: call to undeclared function 'isEmpty'\n02_nx_user.c:8:32: error: call to undeclared function 'pop'\n4 errors generated.\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_1","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Kompiliatoriui reikia deklaracij\u0173 prie\u0161 naudojim\u0105. GCC leid\u017eia 'implicit declarations' (su warning), Clang - ne.\"</p> <p>Sprendimas: Reikalingi header failai su funkcij\u0173 deklaracijomis!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-3-modulis-header-failu-klaidos","title":"Etapas 3: Modulis - Header fail\u0173 klaidos","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_2","title":"\ud83c\udfaf Tikslas","text":"<p>Sukurti teising\u0105 modul\u012f su header failu. Bet pirmiausia - suprasti da\u017eniausias klaidas!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#klaida-1-multiple-definition","title":"\u274c Klaida #1: Multiple definition","text":"<p>03_nx_stack.h (BLOGAI!): <pre><code>#define SIZE 100\n\nchar stack[SIZE];  // \u274c Apibr\u0117\u017eimas header'yje!\nint top;           // \u274c Apibr\u0117\u017eimas header'yje!\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>03_nx_stack.c: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\n\nchar stack[SIZE];  // Apibr\u0117\u017eimas .c faile\nint top;\n\nvoid init(void) { top = 0; }\nint isEmpty(void) { return 0 == top; }\nint isFull(void) { return SIZE == top; }\nvoid push(char c) {\n    if (!isFull()) stack[top++] = c;\n}\nchar pop(void) {\n    if (!isEmpty()) return stack[--top];\n    return '\\0';\n}\n</code></pre></p> <p>03_nx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_nx_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_3","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_nx_stack.c 03_nx_user.c -o 03_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#linker-klaida","title":"\u274c Linker klaida","text":"<p>GCC: <pre><code>ld.exe: multiple definition of `stack'\nld.exe: multiple definition of `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre></p> <p>Clang: <pre><code>ld: multiple definition of `stack'\nld: multiple definition of `top'\nclang: error: linker command failed with exit code 1\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kodel-klaida","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ol> <li>Header'yje: <code>char stack[SIZE];</code> - tai apibr\u0117\u017eimas (definition)</li> <li>.c faile: <code>char stack[SIZE];</code> - dar vienas apibr\u0117\u017eimas</li> <li>Kiekvienas <code>.c</code> failas, kuris \u012ftraukia header'\u012f, sukuria savo kopij\u0105</li> <li>Linker'is: \"Turiu 2 <code>stack</code> apibr\u0117\u017eimus - kurio naudoti?\"</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_2","title":"\ud83d\udcd6 Pamoka","text":"<p>Declaration vs Definition: - Declaration: \"\u017dinok, kad ka\u017ekas egzistuoja\" (<code>extern char stack[];</code>) - Definition: \"Sukurk atmint\u012f daiktui\" (<code>char stack[SIZE];</code>)</p> <p>Header'iuose - tik deklaracijos! Apibr\u0117\u017eimai - tik <code>.c</code> failuose.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#klaida-2-undefined-reference","title":"\u274c Klaida #2: Undefined reference","text":"<p>03_ny_stack.h (bandymas taisyti su <code>extern</code>): <pre><code>#define SIZE 100\n\nextern char stack[SIZE];  // \u2705 Deklaracija\nextern int top;           // \u2705 Deklaracija\n\nextern void init(void);\nextern int isEmpty(void);\nextern int isFull(void);\nextern void push(char c);\nextern char pop(void);\n</code></pre></p> <p>03_ny_stack.c (bet PAMIR\u0160OME apibr\u0117\u017eti!): <pre><code>#include &lt;stdio.h&gt;\n#include \"03_ny_stack.h\"\n\nvoid init(void) {\n    top = 0;  // Naudojame 'top', bet JO N\u0116RA!\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;  // Naudojame 'stack', bet JO N\u0116RA!\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_4","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_ny_stack.c 03_ny_user.c -o 03_ny_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#linker-klaida_1","title":"\u274c Linker klaida","text":"<pre><code>ld.exe: undefined reference to `stack'\nld.exe: undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kodel-klaida_1","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ol> <li>Header'yje: <code>extern char stack[SIZE];</code> - tik deklaracija</li> <li>.c faile: N\u0116RA apibr\u0117\u017eimo <code>char stack[SIZE];</code></li> <li>Linker'is: \"\u017dinau, kad <code>stack</code> turi egzistuoti, bet KUR jis?\"</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_3","title":"\ud83d\udcd6 Pamoka","text":"<p><code>extern</code> sako \"tai egzistuoja ka\u017ekur kitur\". Bet tas \"ka\u017ekur kitur\" turi b\u016bti tikrai apibr\u0117\u017etas!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#teisingas-sprendimas","title":"\u2705 Teisingas sprendimas","text":"<p>03_stack.h: <pre><code>// Tik deklaracijos\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>03_stack.c: <pre><code>#include \"03_stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];  // \u2705 Apibr\u0117\u017eimas .c faile\nint top;           // \u2705 Apibr\u0117\u017eimas .c faile\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>03_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_5","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_user.c -o 03_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_2","title":"\u2705 Veikia!","text":"<p>Bet... ar tikrai saugus?</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#ataka-ant-modulio","title":"\ud83d\udd13 \"Ataka\" ant modulio","text":"<p>03_z_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"\n\nextern char stack[];  // Galiu pasiekti globalius kintamuosius!\nextern int top;\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd13 ATAKA! Tiesiogin\u0117 manipuliacija!\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_6","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_z_user.c -o 03_z_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliuojasi","title":"\u2705 Kompiliuojasi!","text":"<pre><code>&gt; 03_z_use_stack.exe\n123\n!321   // \u2190 '!' buvo \u012fterpta!\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_4","title":"\ud83d\udcd6 Pamoka","text":"<p>\"Jei duomenys global\u016bs, jie NEAPSAUGOTI nuo klaid\u0173 ar piktnaud\u017eiavimo!\"</p> <p>Modulis \u2260 Enkapsulacija</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-4-information-hiding-su-static","title":"Etapas 4: Information Hiding su <code>static</code>","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_3","title":"\ud83c\udfaf Tikslas","text":"<p>Pasl\u0117pti steko realizacijos detales nuo i\u0161or\u0117s pasaulio.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#sprendimas_2","title":"\ud83d\udcbb Sprendimas","text":"<p>04_stack.h: <pre><code>void init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>04_stack.c: <pre><code>#include \"04_stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];  // \u2705 PRIVATE!\nstatic int top;           // \u2705 PRIVATE!\n\nstatic void reset(void) { // \u2705 Helper funkcija - PRIVATE!\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>04_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"04_stack.h\"\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_7","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 04_stack.c 04_user.c -o 04_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_3","title":"\u2705 Veikia!","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#ataka-nepavyksta","title":"\ud83d\udd12 \"Ataka\" NEPAVYKSTA!","text":"<p>04_zx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"04_stack.h\"\n\nextern char stack[];  // Bandau pasiekti\nextern int top;\nextern void reset(void);\n\nint main(void) {\n    char c;\n    init();\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd12 Bandau atakuoti\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n\n    reset();  // \ud83d\udd12 Bandau i\u0161kviesti privat\u0173 metod\u0105\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_8","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 04_stack.c 04_zx_user.c -o 04_zx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#linker-klaida_2","title":"\u274c Linker klaida!","text":"<pre><code>ld.exe: undefined reference to `reset'\nld.exe: undefined reference to `stack'\nld.exe: undefined reference to `top'\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kas-nutiko","title":"\ud83d\udd0d Kas nutiko?","text":"<p><code>static</code> C kalboje sukuria internal linkage: - Kintamasis/funkcija matoma TIK tame <code>.c</code> faile - Kiti failai negali jos pasiekti, net su <code>extern</code> - Tai C kalbos b\u016bdas padaryti \"private\" duomenis</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_5","title":"\ud83d\udcd6 Pamoka","text":"<p>Information Hiding principas: - Pasl\u0117pti realizacijos detales - Eksportuoti tik s\u0105saj\u0105 (interface) - <code>static</code> \u2248 <code>private</code> C++ kalboje</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#problema","title":"\u26a0\ufe0f Problema","text":"<p>Vis tiek tik vienas stekas! Negalime tur\u0117ti <code>st1</code>, <code>st2</code> egzempliori\u0173.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-5-user-defined-type-3-klaidos-anatomija","title":"Etapas 5: User Defined Type - 3 klaidos anatomija","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_4","title":"\ud83c\udfaf Tikslas","text":"<p>Sukurti tip\u0105, kad gal\u0117tume tur\u0117ti kelis stekas.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bandymas-1-static-strukturoje","title":"\u274c Bandymas #1: <code>static</code> strukt\u016broje","text":"<p>05_nx_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    static char stack[SIZE];  // \u274c Galvojame: \"static narys\"\n    static int top;           // \u274c Kaip C++\n};\n\nvoid init(struct Stack st) {\n    st.top = 0;\n}\n// ... kitos funkcijos\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_9","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_nx_usestack.c -o 05_nx_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimo-klaida","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>05_nx_usestack.c:7:3: error: expected specifier-qualifier-list before 'static'\n    7 |   static char stack[SIZE];\n      |   ^~~~~~\n</code></pre></p> <p>Clang: <pre><code>05_nx_usestack.c:7:3: error: type name does not allow storage class to be specified\n    7 |   static char stack[SIZE];\n      |   ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kodel-klaida_2","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<p>C kalba draud\u017eia storage-class specifikatorius strukt\u016bros nariams!</p> <ul> <li><code>struct</code> apra\u0161o tipo \u0161ablon\u0105</li> <li><code>static</code> taikomas kintamiesiems/funkcijoms, ne tipo nariams</li> <li>C++ turi <code>static</code> narius, bet C - NE</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_6","title":"\ud83d\udcd6 Pamoka","text":"<p>C ir C++ skiriasi! C strukt\u016bros - tik duomen\u0173 konteineriai, ne klas\u0117s.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bandymas-2-pass-by-value","title":"\u274c Bandymas #2: Pass-by-value","text":"<p>05_ny_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nvoid init(struct Stack st) {  // \u274c Kopija!\n    st.top = 0;\n}\n\nint isEmpty(struct Stack st) {  // \u274c Kopija!\n    return 0 == st.top;\n}\n\nint isFull(struct Stack st) {  // \u274c Kopija!\n    return SIZE == st.top;\n}\n\nvoid push(struct Stack st, char c) {  // \u274c Kopija!\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;\n    }\n}\n\nchar pop(struct Stack st) {  // \u274c Kopija!\n    if (!isEmpty(st)) {\n        return st.stack[--st.top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    struct Stack st1;\n    char c;\n\n    init(st1);\n    while ((!isFull(st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(st1, c);\n    while (!isEmpty(st1)) \n        putchar(pop(st1));\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_10","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_ny_usestack.c -o 05_ny_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliuojasi_1","title":"\u2705 Kompiliuojasi!","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#bet-nevykdo-teisingai","title":"\u274c Bet nevykdo teisingai","text":"<pre><code>&gt; 05_ny_usestack.exe\n123\n        // \u2190 NIEKO! Tu\u0161\u010dia!\nPabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kas-nutiko_1","title":"\ud83d\udd0d Kas nutiko?","text":"<p>Pass-by-value problema:</p> <pre><code>main():\n  st1.stack = [?, ?, ?, ?, ?]  \u2190 NIEKADA nepakeistas\n  st1.top = ?                  \u2190 Neinicializuotas\n\ninit(kopija):\n  kopija.top = 0  \u2190 Modifikuoja KOPIJ\u0104\n  // Kopija nunyksta funkcijos pabaigoje\n\npush(kopija, 'c'):\n  kopija.stack[0] = '1'\n  kopija.stack[1] = '2'\n  kopija.stack[2] = '3'\n  kopija.top = 3\n  // Kopija nunyksta\n\npop(kopija):\n  return kopija.stack[--kopija.top]  \u2190 Bet originalas tu\u0161\u010dias!\n</code></pre> <p>Rezultatas: Originalus <code>st1</code> lieka nemodifikuotas!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_7","title":"\ud83d\udcd6 Pamoka","text":"<p>Pass-by-value vs Pass-by-reference: - C perdavin\u0117ja kopijas - Norint modifikuoti - reikia rodykli\u0173 (pointers) - C++ turi references (<code>&amp;</code>), C - tik pointers</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#teisingas-sprendimas-rodykles","title":"\u2705 Teisingas sprendimas: Rodykl\u0117s!","text":"<p>05_n_usestack.c: <pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {  // \u2705 Rodykl\u0117\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {  // \u2705 Rodykl\u0117\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    struct Stack st1, st2;\n    char c;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);  // \u2705 Adresas\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);  // \u2705 Dar vienas stekas!\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_11","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 05_n_usestack.c -o 05_n_usestack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_4","title":"\u2705 Veikia!","text":"<pre><code>&gt; 05_n_usestack.exe\nIvesk st1\n456\n654\nst1 pabaiga\nIvesk st2\n456789\n87654\nst2 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pasiekta","title":"\ud83c\udf89 Pasiekta","text":"<ul> <li>\u2705 Turime tip\u0105 <code>struct Stack</code></li> <li>\u2705 Galime tur\u0117ti kelis stekas (<code>st1</code>, <code>st2</code>)</li> <li>\u2705 Tikras ADT - tipas su operacijomis</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bet-dar-ne-modulis","title":"\u26a0\ufe0f Bet dar ne modulis!","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-6-adt-modulyje","title":"Etapas 6: ADT modulyje","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_5","title":"\ud83c\udfaf Tikslas","text":"<p>Perkelti ADT \u012f modul\u012f (header + implementation).</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#sprendimas_3","title":"\ud83d\udcbb Sprendimas","text":"<p>06_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack {\n    char stack[SIZE];  // \u26a0\ufe0f Matomas header'yje\n    int top;           // \u26a0\ufe0f Matomas header'yje\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>06_stack.c: <pre><code>#include \"06_stack.h\"\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>06_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;\n    char c;\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_12","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 06_stack.c 06_user.c -o 06_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_5","title":"\u2705 Veikia!","text":"<pre><code>&gt; 06_use_stack.exe\nIvesk st1\n123\n321\nst1 pabaiga\nIvesk st2\n123456\n54321\nst2 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pasiekta_1","title":"\ud83c\udf89 Pasiekta","text":"<ul> <li>\u2705 ADT modulyje</li> <li>\u2705 Du stekai veikia</li> <li>\u2705 Gra\u017eus kodas</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bet-ataka-pavyksta","title":"\ud83d\udd13 Bet \"ataka\" pavyksta!","text":"<p>06_z_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st2;\n    char c;\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n\n    st2.stack[st2.top++] = '!';  // \ud83d\udd13 Tiesiogin\u0117 manipuliacija!\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"st2 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_13","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 06_stack.c 06_z_user.c -o 06_z_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliuojasi_2","title":"\u2705 Kompiliuojasi!","text":"<pre><code>&gt; 06_z_use_stack.exe\nIvesk st2\n123456\n!54321   // \u2190 Ataka pavyko!\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_8","title":"\ud83d\udcd6 Pamoka","text":"<p>Jei strukt\u016bros apibr\u0117\u017eimas matomas header'yje, tai NE enkapsulacija!</p> <p>Bet kas gali pasiekti <code>st.top</code>, <code>st.stack[i]</code>.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-7-opaque-type-tikra-enkapsulacija","title":"Etapas 7: Opaque Type - tikra enkapsulacija","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_6","title":"\ud83c\udfaf Tikslas","text":"<p>Pasl\u0117pti strukt\u016bros apibr\u0117\u017eim\u0105, palikti tik forward declaration.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bandymas-1-stack-objektai-su-forward-declaration","title":"\u274c Bandymas #1: Stack objektai su forward declaration","text":"<p>07_n_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;  // \u2705 Forward declaration\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>07_n_stack.c: <pre><code>#include \"07_n_stack.h\"\n\nstruct Stack {  // \u2705 Pilnas apibr\u0117\u017eimas TIK .c faile\n    char stack[SIZE];\n    int top;\n};\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>07_nx_user.c (bandymas su stack objektais): <pre><code>#include &lt;stdio.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;  // \u274c Bandau deklaruoti\n    // ...\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_14","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_n_stack.c 07_nx_user.c -o 07_nx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimo-klaida_1","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>07_nx_user.c: In function 'main':\n07_nx_user.c:7:18: error: storage size of 'st1' isn't known\n    7 |     struct Stack st1, st2;\n      |                  ^~~\n07_nx_user.c:7:23: error: storage size of 'st2' isn't known\n    7 |     struct Stack st1, st2;\n      |                       ^~~\n</code></pre></p> <p>Clang: <pre><code>07_nx_user.c:7:18: error: variable has incomplete type 'struct Stack'\n    7 |     struct Stack st1, st2;\n      |                  ^\n./07_n_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kodel-klaida_3","title":"\ud83d\udd0d Kod\u0117l klaida?","text":"<ul> <li>Kompiliatorius ne\u017eino strukt\u016bros dyd\u017eio</li> <li>Negali allokuoti <code>st1</code> ir <code>st2</code> stack'e</li> <li>Forward declaration leid\u017eia tik rodykles!</li> </ul>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_9","title":"\ud83d\udcd6 Pamoka","text":"<p>Incomplete type (nepilnas tipas): - Galima deklaruoti rodykles: <code>struct Stack *pst</code> - NEGALIMA deklaruoti objekt\u0173: <code>struct Stack st</code> - NEGALIMA naudoti <code>sizeof(struct Stack)</code></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#bandymas-2-heap-allokacija-su-calloc","title":"\u274c Bandymas #2: Heap allokacija su <code>calloc</code>","text":"<p>07_ny_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = calloc(sizeof(struct Stack), 1);  // \u274c sizeof incomplete type!\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    // ...\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_15","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_n_stack.c 07_ny_user.c -o 07_ny_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimo-klaida_2","title":"\u274c Kompiliavimo klaida","text":"<p>GCC: <pre><code>07_ny_user.c: In function 'main':\n07_ny_user.c:10:26: error: invalid application of 'sizeof' \n                          to incomplete type 'struct Stack'\n   10 |     pst1 = calloc(sizeof(struct Stack), 1);\n      |                          ^~~~~~\n</code></pre></p> <p>Clang: <pre><code>07_ny_user.c:10:19: error: invalid application of 'sizeof' \n                           to an incomplete type 'struct Stack'\n   10 |     pst1 = calloc(sizeof(struct Stack), 1);\n      |                   ^     ~~~~~~~~~~~~~~\n./07_n_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#problema_1","title":"\ud83d\udd0d Problema","text":"<p>Vartotojas negali naudoti <code>sizeof(struct Stack)</code> - tipas nei\u0161baigtas!</p> <p>Sprendimas: Reikia factory funkcijos!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#teisingas-sprendimas-factory-pattern","title":"\u2705 Teisingas sprendimas: Factory Pattern","text":"<p>07_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;  // Opaque type\n\nstruct Stack* create(void);  // \u2705 Factory funkcija!\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>07_stack.c: <pre><code>#include &lt;stdlib.h&gt;\n#include \"07_stack.h\"\n\nstruct Stack {  // \u2705 Pilnas apibr\u0117\u017eimas TIK .c faile\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {  // \u2705 Factory\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>07_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();  // \u2705 Factory funkcija\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_16","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_stack.c 07_user.c -o 07_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_6","title":"\u2705 Veikia!","text":"<pre><code>&gt; 07_use_stack.exe\nIvesk st1\n123456\n54321\nst1 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#ataka-nepavyksta_1","title":"\ud83d\udd12 \"Ataka\" NEPAVYKSTA!","text":"<p>07_zx_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n\n    pst1-&gt;stack[pst1-&gt;top++] = '!';  // \ud83d\udd12 Bandau atakuoti!\n\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_17","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 07_stack.c 07_zx_user.c -o 07_zx_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimo-klaida_3","title":"\u274c Kompiliavimo klaida!","text":"<p>GCC: <pre><code>07_zx_user.c: In function 'main':\n07_zx_user.c:15:9: error: invalid use of undefined type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |         ^~\n07_zx_user.c:15:21: error: invalid use of undefined type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |                     ^~\n</code></pre></p> <p>Clang: <pre><code>07_zx_user.c:15:9: error: incomplete definition of type 'struct Stack'\n   15 |     pst1-&gt;stack[pst1-&gt;top++] = '!';\n      |     ~~~~^\n./07_stack.h:3:8: note: forward declaration of 'struct Stack'\n    3 | struct Stack;\n      |        ^\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pergale","title":"\ud83c\udf89 Pergal\u0117!","text":"<p>Kompiliatorius neleid\u017eia pasiekti strukt\u016bros nari\u0173!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pamoka_10","title":"\ud83d\udcd6 Pamoka","text":"<p>Opaque type / PIMPL (Pointer to Implementation) idiom: - Header'yje - tik forward declaration - Strukt\u016bros apibr\u0117\u017eimas - TIK .c faile - Vartotojas negali pasiekti <code>pst-&gt;member</code> - Tai kompiliatoriaus lygmens enkapsulacija!</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#etapas-8-full-lifecycle-raii-intro","title":"Etapas 8: Full Lifecycle + RAII intro","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#tikslas_7","title":"\ud83c\udfaf Tikslas","text":"<p>Prid\u0117ti piln\u0105 objekto lifecycle valdym\u0105 ir paruo\u0161ti C++ RAII koncepcijos \u012fvad\u0105.</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#sprendimas_4","title":"\ud83d\udcbb Sprendimas","text":"<p>077_stack.h: <pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);   // Constructor\nvoid destroy(struct Stack *); // \u2705 Destructor!\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre></p> <p>077_stack.c: <pre><code>#include &lt;stdlib.h&gt;\n#include \"077_stack.h\"\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nvoid destroy(struct Stack *pst) {  // \u2705 Atlaisvinimas!\n    free(pst);\n}\n\nstatic void reset(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *pst) {\n    return 0 == pst-&gt;top;\n}\n\nint isFull(struct Stack *pst) {\n    return SIZE == pst-&gt;top;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *pst) {\n    if (!isEmpty(pst)) {\n        return pst-&gt;stack[--pst-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>077_user.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"077_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n    char c;\n\n    pst1 = create();  // \u2705 Suk\u016brimas\n\n    printf(\"Ivesk st1\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"st1 pabaiga\\n\");\n\n    destroy(pst1);  // \u2705 Sunaikinimas\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kompiliavimas_18","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc 077_stack.c 077_user.c -o 077_use_stack\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#veikia_7","title":"\u2705 Veikia!","text":"<pre><code>&gt; 077_use_stack.exe\nIvesk st1\n1234567\n54321\nst1 pabaiga\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pasiekta-pilnas-adt-c-kalboje","title":"\ud83c\udf89 Pasiekta: Pilnas ADT C kalboje!","text":"<p>Turime: - \u2705 Opaque type - strukt\u016bra pasl\u0117pta - \u2705 Factory pattern - <code>create()</code> - \u2705 Enkapsulacija - duomenys nepasiekiami - \u2705 Full lifecycle - <code>create()</code> / <code>destroy()</code> - \u2705 Modulin\u0117 strukt\u016bra - header + implementation - \u2705 Information hiding - <code>static</code> nariai</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#c-c-tiltas-raii-ivadas","title":"\ud83d\udd17 C \u2192 C++ tiltas: RAII \u012fvadas","text":"<p>C kalboje: <pre><code>struct Stack *pst = create();  // Manual suk\u016brimas\n// ... naudojimas\ndestroy(pst);                  // Manual sunaikinimas\n</code></pre></p> <p>Problemos: 1. \u274c Galima pamir\u0161ti <code>destroy()</code> \u2192 memory leak 2. \u274c Jei klaida tarp <code>create()</code> ir <code>destroy()</code> \u2192 leak 3. \u274c Reikia sekti kiekvieno objekto lifecycle rankomis</p> <p>C++ sprendimas: RAII (Resource Acquisition Is Initialization)</p> <pre><code>class Stack {\nprivate:\n    char stack[SIZE];\n    int top;\n\npublic:\n    Stack() : top(0) {}  // \u2705 Constructor - automatinis!\n    ~Stack() {}          // \u2705 Destructor - automatinis!\n\n    void push(char c) {\n        if (top &lt; SIZE) stack[top++] = c;\n    }\n\n    char pop() {\n        if (top &gt; 0) return stack[--top];\n        return '\\0';\n    }\n};\n\nint main() {\n    Stack st1;  // \u2705 Constructor automati\u0161kai i\u0161kvie\u010diamas\n    st1.push('A');\n    // ...\n}  // \u2705 Destructor automati\u0161kai i\u0161kvie\u010diamas i\u0161einant i\u0161 scope!\n</code></pre> <p>RAII garantijos: - \u2705 Constructor visuomet i\u0161kvie\u010diamas objekto suk\u016brimo metu - \u2705 Destructor visuomet i\u0161kvie\u010diamas objekto sunaikinimo metu - \u2705 Automatinis resource valdymas - \u2705 Exception-safe - destructor i\u0161kviestas net klaidos atveju</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#evoliucijos-apzvalga","title":"\ud83d\udcd6 Evoliucijos ap\u017evalga","text":"Etapas Sprendimas Pasiekta Tr\u016bkumai 1 Monolitinis kodas Veikia Nelankstus, global\u016bs 2 Fail\u0173 atskyrimas Dekompozicija N\u0117ra header fail\u0173 3 Modulis Header + .c Global\u016bs duomenys 4 Information hiding <code>static</code> Tik 1 stekas 5 User Defined Type Keletas stekas N\u0117ra enkapsuliacijos 6 ADT modulyje Tipas + modulis Duomenys matomi 7 Opaque type Enkapsulacija Reikia manual destroy 8 Full lifecycle RAII \u012fvadas Manual lifecycle (C)"},{"location":"evolution/Claude_stack_evolution_guide_VG/#pagrindines-pamokos","title":"\ud83c\udf93 Pagrindin\u0117s pamokos","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#1-declaration-vs-definition","title":"1. Declaration vs Definition","text":"<pre><code>// DECLARATION (apra\u0161as)\nextern int x;\nvoid foo(void);\nstruct Stack;  // Forward declaration\n\n// DEFINITION (apibr\u0117\u017eimas)\nint x = 42;\nvoid foo(void) { /* ... */ }\nstruct Stack { /* ... */ };\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#2-storage-classes","title":"2. Storage classes","text":"<pre><code>// Global scope\nint global;           // External linkage\nstatic int internal;  // Internal linkage\nextern int external;  // Declaration\n\n// Function scope\nvoid foo(void) {\n    static int persistent;  // I\u0161lieka tarp kvietim\u0173\n    auto int local;         // Default (stack)\n    register int fast;      // Suggestion compiler'iui\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#3-incomplete-types","title":"3. Incomplete types","text":"<pre><code>struct Stack;  // Incomplete type\n\nstruct Stack *p;        // \u2705 OK - rodykl\u0117\nsizeof(struct Stack);   // \u274c KLAIDA - nepilnas tipas\nstruct Stack s;         // \u274c KLAIDA - reikia dyd\u017eio\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#4-opaque-type-pattern","title":"4. Opaque type pattern","text":"<pre><code>// Header (.h)\nstruct Type;\nstruct Type* create(void);\nvoid destroy(struct Type*);\n\n// Implementation (.c)\nstruct Type {\n    // Priva\u010dius nariai\n};\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#5-c-vs-c-enkapsulacija","title":"5. C vs C++ enkapsulacija","text":"Aspektas C C++ Private duomenys <code>static</code> .c faile <code>private:</code> klas\u0117je Constructor <code>create()</code> funkcija Automatinis <code>Type()</code> Destructor <code>destroy()</code> funkcija Automatinis <code>~Type()</code> Lifecycle Manual RAII (automatinis) Multiple instances Strukt\u016br\u0173 masyvas Objekt\u0173 masyvas"},{"location":"evolution/Claude_stack_evolution_guide_VG/#uzduotys-studentams","title":"\ud83d\udcdd U\u017eduotys studentams","text":""},{"location":"evolution/Claude_stack_evolution_guide_VG/#uzduotis-1-pataisyk-klaida","title":"U\u017eduotis 1: Pataisyk klaid\u0105","text":"<p>Kod\u0117l \u0161is kodas nesikompiliuoja? Kaip pataisyti?</p> <pre><code>// my_stack.h\nstruct Stack {\n    int data[100];\n    int top;\n};\n\n// my_stack.c\n#include \"my_stack.h\"\n\nstruct Stack {\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n</code></pre> Atsakymas  **Klaida:** Multiple definition of `struct Stack`  **Sprendimas:** Strukt\u016bros apibr\u0117\u017eimas turi b\u016bti TIK vienoje vietoje: - Header'yje: jei reikia matomo tipo (Etapas 6) - .c faile: jei naudojame opaque type (Etapas 7)  <pre><code>// Variantas 1: Header'yje (matomas)\n// my_stack.h\nstruct Stack {\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val);\n\n// my_stack.c\n#include \"my_stack.h\"\n// NEAPIBR\u0116\u017dIAME dar kart\u0105!\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n\n// Variantas 2: Opaque type (pasl\u0117ptas)\n// my_stack.h\nstruct Stack;  // Tik forward declaration\nvoid push(struct Stack *s, int val);\n\n// my_stack.c\n#include \"my_stack.h\"\n\nstruct Stack {  // Apibr\u0117\u017eimas TIK \u010dia\n    int data[100];\n    int top;\n};\n\nvoid push(struct Stack *s, int val) {\n    s-&gt;data[s-&gt;top++] = val;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#uzduotis-2-pass-by-value-vs-pass-by-pointer","title":"U\u017eduotis 2: Pass-by-value vs Pass-by-pointer","text":"<p>Kod\u0117l \u0161i funkcija nemodifikuoja originalaus steko?</p> <pre><code>void init(struct Stack st) {\n    st.top = 0;\n}\n\nint main(void) {\n    struct Stack s;\n    init(s);\n    printf(\"%d\\n\", s.top);  // Kas bus i\u0161spausdinta?\n}\n</code></pre> Atsakymas  **Atsakymas:** Spausdins neinicializuot\u0105 reik\u0161m\u0119 (\u0161iuk\u0161les).  **Prie\u017eastis:** `init(s)` gauna **kopij\u0105** strukt\u016bros. Modifikuoja kopij\u0105, ne original\u0105.  **Sprendimas:** <pre><code>void init(struct Stack *pst) {  // Rodykl\u0117!\n    pst-&gt;top = 0;\n}\n\nint main(void) {\n    struct Stack s;\n    init(&amp;s);  // Perduodame adres\u0105\n    printf(\"%d\\n\", s.top);  // 0\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#uzduotis-3-implementuok-queue","title":"U\u017eduotis 3: Implementuok Queue","text":"<p>Naudodami Opaque Type pattern (Etapas 7-8), implementuokite Queue ADT su: - <code>create()</code> / <code>destroy()</code> - <code>enqueue(Queue*, int)</code> - \u012fdeda \u012f gal\u0105 - <code>dequeue(Queue*)</code> - i\u0161ima i\u0161 priekio - <code>isEmpty(Queue*)</code></p> Sprendimo pavyzdys <pre><code>// queue.h\n#ifndef QUEUE_H\n#define QUEUE_H\n\n#define QUEUE_SIZE 100\n\nstruct Queue;\n\nstruct Queue* create(void);\nvoid destroy(struct Queue*);\nvoid enqueue(struct Queue*, int);\nint dequeue(struct Queue*);\nint isEmpty(struct Queue*);\n\n#endif\n\n// queue.c\n#include &lt;stdlib.h&gt;\n#include \"queue.h\"\n\nstruct Queue {\n    int data[QUEUE_SIZE];\n    int front;\n    int rear;\n    int count;\n};\n\nstruct Queue* create(void) {\n    struct Queue *q = (struct Queue*) calloc(sizeof(struct Queue), 1);\n    q-&gt;front = 0;\n    q-&gt;rear = -1;\n    q-&gt;count = 0;\n    return q;\n}\n\nvoid destroy(struct Queue *q) {\n    free(q);\n}\n\nvoid enqueue(struct Queue *q, int val) {\n    if (q-&gt;count &lt; QUEUE_SIZE) {\n        q-&gt;rear = (q-&gt;rear + 1) % QUEUE_SIZE;\n        q-&gt;data[q-&gt;rear] = val;\n        q-&gt;count++;\n    }\n}\n\nint dequeue(struct Queue *q) {\n    if (q-&gt;count &gt; 0) {\n        int val = q-&gt;data[q-&gt;front];\n        q-&gt;front = (q-&gt;front + 1) % QUEUE_SIZE;\n        q-&gt;count--;\n        return val;\n    }\n    return -1;  // Tu\u0161\u010dia\n}\n\nint isEmpty(struct Queue *q) {\n    return q-&gt;count == 0;\n}\n</code></pre>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#kitas-zingsnis-c","title":"\ud83d\ude80 Kitas \u017eingsnis: C++","text":"<p>\u0160is vadovas paruo\u0161\u0117 jus C++ OOP:</p> <pre><code>class Stack {\nprivate:  // \u2248 static C kalboje\n    static const int SIZE = 100;\n    char data[SIZE];\n    int top;\n\npublic:  // \u2248 header funkcijos C kalboje\n    Stack() : top(0) {}  // \u2248 create()\n    ~Stack() {}          // \u2248 destroy()\n\n    void push(char c) {\n        if (top &lt; SIZE) data[top++] = c;\n    }\n\n    char pop() {\n        if (top &gt; 0) return data[--top];\n        return '\\0';\n    }\n\n    bool isEmpty() const {\n        return top == 0;\n    }\n};\n\n// Naudojimas\nint main() {\n    Stack s1, s2;  // \u2705 Automatinis constructor\n    s1.push('A');\n    s2.push('B');\n}  // \u2705 Automatinis destructor\n</code></pre> <p>C++ privalumai: - \u2705 Automatinis lifecycle (RAII) - \u2705 Sintaksinis <code>private</code> / <code>public</code> - \u2705 Member funkcijos - \u2705 Operator overloading - \u2705 Templates (generic programming)</p>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#papildoma-literatura","title":"\ud83d\udcda Papildoma literat\u016bra","text":"<ol> <li>K&amp;R \"The C Programming Language\" - Chapter 6 (Structures)</li> <li>\"Expert C Programming\" by Peter van der Linden</li> <li>\"C Interfaces and Implementations\" by David Hanson</li> <li>Stroustrup \"The C++ Programming Language\" - RAII (Chapter 13)</li> </ol>"},{"location":"evolution/Claude_stack_evolution_guide_VG/#apibendrinimas","title":"\ud83c\udfac Apibendrinimas","text":"<p>Evoliucijos kelias: 1. Monolitinis kodas \u2192 Modulis 2. Global\u016bs duomenys \u2192 Information hiding (<code>static</code>) 3. Vienas stekas \u2192 User Defined Type (strukt\u016bra) 4. Matoma strukt\u016bra \u2192 Opaque type (forward declaration) 5. Manual lifecycle \u2192 Factory pattern (<code>create</code>/<code>destroy</code>) 6. C \u2192 C++ (RAII, automatinis lifecycle)</p> <p>Svarbiausios pamokos: - \u2705 Enkapsulacija - ne tik patogumas, bet saugumas - \u2705 Abstrakcija - sl\u0117pti detales, rodyti s\u0105saj\u0105 - \u2705 Modulin\u0117 strukt\u016bra - pakartotinis naudojimas - \u2705 Lifecycle valdymas - suk\u016brimas ir sunaikinimas - \u2705 C \u2192 C++ tiltas - manual \u2192 automatic</p> <p>S\u0117km\u0117s mokantis! \ud83d\ude80</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/","title":"\ud83d\udcda Stack ADT Evoliucija: Nuo C iki C++","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pedagoginis-vadovas-9-etapai","title":"Pedagoginis vadovas - 9 etapai","text":"<p>Versija: 2026.01 (GALUTIN\u0116) Kodas: <code>code/evolution/stack-2026/</code> Etapai: 01 \u2192 09 (pilna C evoliucija) Tikslas: Parodyti tikr\u0105 ADT evoliucij\u0105 su kompiliavimo/linkavimo klaidomis</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#subdirektoriju-zymejimai","title":"\ud83c\udfaf Subdirektorij\u0173 \u017eym\u0117jimai","text":"\u017dym\u0117jimas Reik\u0161m\u0117 Kas nutinka NC Not Compiling Kompiliavimo klaida (syntax/type error) NL Not Linking Linkavimo klaida (multiple definition/undefined reference) OK Kompiliuojasi ir veikia Bet gali b\u016bti dizaino problema OK_Attack Veikia, bet ataka pavyksta Parodo saugumo sprag\u0105 RT RunTime error Kompiliuojasi, bet crash/neteisingi rezultatai"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#9-etapu-apzvalga","title":"\ud83d\udcd6 9 ETAP\u0172 AP\u017dVALGA","text":"<pre><code>01_Running_PROGRAM                    \u2192 Monolitas\n02_Decomposing_to_UNITS              \u2192 Fizinis padalijimas (NL klaidos!)\n03_Discovering_C_MODULE              \u2192 Modulis (atakos pavyksta!)\n04_Protecting_IMPLEMENTATION         \u2192 static sl\u0117pimas (NL ataka nepavyksta!)\n05_Defining_USER_TYPE                \u2192 struct (NC, RT klaidos!)\n06_ENCAPSULATING_UDT_in_Module       \u2192 Modulinis UDT (atakos pavyksta!)\n07_HIDING_UDT_Information            \u2192 Opaque pointer (NC ataka nepavyksta!)\n08_Acquiring_RESOURCES               \u2192 Factory (create/destroy)\n09_Completing_LIFECYCLE              \u2192 Pilnas lifecycle\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-01-running_program","title":"\ud83d\ude80 ETAPAS 01: Running_PROGRAM","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>01_Running_PROGRAM/\n\u2514\u2500\u2500 stack.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija","title":"\ud83d\udccc Koncepcija","text":"<p>MONOLITH - visa logika vienoje vietoje. Global\u016bs kintamieji. Veikia, bet...</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>stack.c</code></p> <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 5\n\nchar stack[SIZE];  // \u2190 globalus\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc stack.c -o stack\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia","title":"\u2705 Veikia!","text":"<pre><code>Input:  12345\nOutput: 54321\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#problemos","title":"\u274c Problemos","text":"<ol> <li>Global\u016bs <code>stack[]</code> ir <code>top</code> - matomi visur</li> <li>Tik vienas stekas sistemoje</li> <li>Viskas viename faile - negalima pakartotinio naudojimo</li> <li>Jokio inkapsuliavimo</li> </ol>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka","title":"\ud83d\udca1 Pamoka","text":"<p>Veikiantis kodas \u2260 geras kodas</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-02-decomposing_to_units","title":"\ud83d\ude80 ETAPAS 02: Decomposing_to_UNITS","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_1","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>02_Decomposing_to_UNITS/\n\u251c\u2500\u2500 02_NL/              \u2190 Linkavimo klaida!\n\u2502   \u251c\u2500\u2500 stack.c\n\u2502   \u2514\u2500\u2500 user.c\n\u2514\u2500\u2500 03_OK_Wrong/        \u2190 Veikia, bet BLOGAI\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_1","title":"\ud83d\udccc Koncepcija","text":"<p>DECOMPOSING - bandome atskirti logik\u0105 \u012f failus</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#02_nl-linkavimo-klaida","title":"02_NL: Linkavimo klaida","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_1","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>02_NL/stack.c</code> <pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>02_NL/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"  // \u26a0\ufe0f KLAIDA: include .c fail\u0105!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas_1","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc stack.c user.c -o app\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#nl-linkavimo-klaida","title":"\u274c NL - Linkavimo klaida!","text":"<pre><code>multiple definition of `init'\nmultiple definition of `isEmpty'\nmultiple definition of `isFull'\nmultiple definition of `push'\nmultiple definition of `pop'\nmultiple definition of `stack'\nmultiple definition of `top'\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodel","title":"\ud83d\udd0d Kod\u0117l?","text":"<ul> <li><code>user.c</code> daro <code>#include \"stack.c\"</code> \u2192 visos funkcijos nukopijuojamos</li> <li>Tada kompiliuojame ir <code>stack.c</code> atskirai</li> <li>Linkeris mato dvigubas definicijas!</li> </ul>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#03_ok_wrong-veikia-bet-blogai","title":"03_OK_Wrong: Veikia, bet BLOGAI","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_2","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>03_OK_Wrong/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.c\"  // \u26a0\ufe0f ANTIPATTERN!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas_2","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc user.c -o app  # \u2190 Tik user.c!\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia_1","title":"\u2705 Veikia!","text":"<pre><code>Input:  123\nOutput: 321\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodel-blogai","title":"\u274c Kod\u0117l BLOGAI?","text":"<ul> <li><code>#include \"stack.c\"</code> yra antipattern!</li> <li><code>.c</code> failai netur\u0117t\u0173 b\u016bti include'inami</li> <li>N\u0117ra headerio \u2192 funkcij\u0173 prototipai \"implicit\"</li> </ul>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_1","title":"\ud83d\udca1 Pamoka","text":"<p><code>#include \"modulis.c\"</code> = ANTIPATTERN! Teisingai: <code>#include \"modulis.h\"</code> + kompiliuoti atskirai</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-03-discovering_c_module","title":"\ud83d\ude80 ETAPAS 03: Discovering_C_MODULE","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_2","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>03_Discovering_C_MODULE/\n\u251c\u2500\u2500 04_OK/              \u2190 Tinkamas modulis\n\u2502   \u251c\u2500\u2500 stack.h\n\u2502   \u251c\u2500\u2500 stack.c\n\u2502   \u2514\u2500\u2500 user.c\n\u2514\u2500\u2500 05_OK_Attack/       \u2190 Ataka pavyksta!\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_2","title":"\ud83d\udccc Koncepcija","text":"<p>MODULE - header (.h) + implementation (.c)</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#04_ok-tinkamas-modulis","title":"04_OK: Tinkamas modulis","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_3","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>04_OK/stack.h</code> <pre><code>#define SIZE 5\n\n// \u2705 Tik deklaracijos\nextern char stack[SIZE];\nextern int top;\n\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>Failas: <code>04_OK/stack.c</code> <pre><code>#include \"stack.h\"\n\n// \u2705 Apibr\u0117\u017eimai .c faile\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>04_OK/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"  // \u2705 Teisingai!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas_3","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc stack.c user.c -o app\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia_2","title":"\u2705 Veikia!","text":"<pre><code>Input:  123456\nOutput: 654321\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#05_ok_attack-ataka-pavyksta","title":"05_OK_Attack: Ataka pavyksta!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_4","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>05_OK_Attack/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];  // \ud83d\udd25 Tiesioginis prieiga!\nextern int top;       // \ud83d\udd25\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd25 ATAKA!\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliuojasi-ataka-pavyko","title":"\u2705 Kompiliuojasi! Ataka PAVYKO!","text":"<pre><code>Input:  123456\nOutput: !654321  \u2190 '!' \u012fterptas!\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_2","title":"\ud83d\udca1 Pamoka","text":"<p>Moduliavimas \u2260 Saugumas Duomenys vis dar nesl\u0117pti!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-04-protecting_implementation","title":"\ud83d\ude80 ETAPAS 04: Protecting_IMPLEMENTATION","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_3","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>04_Protecting_IMPLEMENTATION/\n\u251c\u2500\u2500 01_NL_Attack/       \u2190 Ataka NEPAVYKSTA! (NL)\n\u2502   \u251c\u2500\u2500 stack.h\n\u2502   \u251c\u2500\u2500 stack.c\n\u2502   \u2514\u2500\u2500 user_attack.c\n\u2514\u2500\u2500 02_OK/              \u2190 Veikia teisingai\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_3","title":"\ud83d\udccc Koncepcija","text":"<p>STATIC - internal linkage, information hiding</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#02_ok-tinkamas-kodas","title":"02_OK: Tinkamas kodas","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_5","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>02_OK/stack.h</code> <pre><code>#define SIZE 5\n\n// \u2705 TIKTAI funkcij\u0173 prototipai (n\u0117ra extern stack/top!)\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre></p> <p>Failas: <code>02_OK/stack.c</code> <pre><code>#include \"stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // \u2705 static = internal linkage!\nstatic int top = 0;         // \u2705 Pasl\u0117pta!\n\nstatic void reset(void) {   // \u2705 Private funkcija\n    top = 0;\n}\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>02_OK/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas_4","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc stack.c user.c -o app\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia_3","title":"\u2705 Veikia!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#01_nl_attack-ataka-nepavyksta","title":"01_NL_Attack: Ataka nepavyksta!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_6","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>01_NL_Attack/user_attack.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nextern char stack[];     // \ud83d\udd25 Bandome pasiekti\nextern int top;          // \ud83d\udd25\nextern void reset(void); // \ud83d\udd25 Bandome i\u0161kviesti private funkcij\u0105\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    stack[top++] = '!';  // \ud83d\udd25 ATAKA!\n\n    while (!isEmpty()) \n        putchar(pop());\n    putchar('\\n');\n\n    reset();  // \ud83d\udd25 ATAKA!\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimas_5","title":"\ud83d\udd27 Kompiliavimas","text":"<pre><code>gcc stack.c user_attack.c -o app\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#nl-linkavimo-klaida_1","title":"\u274c NL - Linkavimo klaida!","text":"<pre><code>undefined reference to `reset'\nundefined reference to `stack'\nundefined reference to `top'\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#ataka-nepavyko","title":"\u2705 ATAKA NEPAVYKO! \ud83c\udf89","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_3","title":"\ud83d\udca1 Pamoka","text":"<p><code>static</code> = internal linkage Matoma TIK savo <code>.c</code> faile! Tai C kalbos information hiding mechanizmas!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#problema","title":"\u26a0\ufe0f Problema","text":"<p>Vis tiek tik vienas stekas sistemoje!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-05-defining_user_type","title":"\ud83d\ude80 ETAPAS 05: Defining_USER_TYPE","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_4","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>05_Defining_USER_TYPE/\n\u251c\u2500\u2500 01_NC_Static_in_Struct/  \u2190 NC klaida!\n\u251c\u2500\u2500 02_RT_PassByValue/        \u2190 RT klaida!\n\u2514\u2500\u2500 03_OK/                    \u2190 Veikia!\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_4","title":"\ud83d\udccc Koncepcija","text":"<p>USER-DEFINED TYPE - <code>struct</code> tipas, keli\u0173 egzempliori\u0173 galimyb\u0117</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#01_nc_static_in_struct-kompiliavimo-klaida","title":"01_NC_Static_in_Struct: Kompiliavimo klaida","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas-konceptualus","title":"\ud83d\udcbb Kodas (konceptualus)","text":"<pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c C neleid\u017eia!\n    static int top;           // \u274c\n};\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#nc-kompiliavimo-klaida","title":"\u274c NC - Kompiliavimo klaida!","text":"<pre><code>error: expected specifier-qualifier-list before 'static'\nerror: type name does not allow storage class to be specified\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_4","title":"\ud83d\udca1 Pamoka","text":"<p>C draud\u017eia <code>static</code> strukt\u016bros nariams! C++ turi <code>static</code> narius, bet C - NE</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#02_rt_passbyvalue-runtime-klaida","title":"02_RT_PassByValue: Runtime klaida","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas-konceptualus_1","title":"\ud83d\udcbb Kodas (konceptualus)","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u274c Pass-by-value - modifikuoja tik kopij\u0105!\nvoid init(struct Stack st) {\n    st.top = 0;  // Ne\u012fsimena!\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;  // Ne\u012fsimena!\n    }\n}\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliuojasi-bet-rt-neteisingi-rezultatai","title":"\u2705 Kompiliuojasi, bet RT - neteisingi rezultatai!","text":"<pre><code>Input:  123\nOutput: (tu\u0161\u010dia)  \u2190 Duomenys nepasikeit\u0117!\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_5","title":"\ud83d\udca1 Pamoka","text":"<p>Pass-by-value - C strukt\u016bros kopijuojamos! Reikia naudoti pointers!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#03_ok-tinkamas-variantas","title":"03_OK: Tinkamas variantas","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas-konceptualus_2","title":"\ud83d\udcbb Kodas (konceptualus)","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u2705 Pass-by-pointer!\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nint main(void) {\n    struct Stack st1, st2;  // \u2705 Du nepriklausomi stekai!\n\n    init(&amp;st1);\n    push(&amp;st1, 'A');\n\n    init(&amp;st2);\n    push(&amp;st2, 'B');\n\n    // ...\n}\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia-dabar-turime-kelis-stekus","title":"\u2705 Veikia! Dabar turime kelis stekus!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_6","title":"\ud83d\udca1 Pamoka","text":"<p>Strukt\u016bra = vartotojo tipas <code>struct Stack s1, s2, s3;</code> - kiek norime egzempliori\u0173!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-06-encapsulating_udt_in_module","title":"\ud83d\ude80 ETAPAS 06: ENCAPSULATING_UDT_in_Module","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_5","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>06_ENCAPSULATING_UDT_in_Module/\n\u251c\u2500\u2500 01_OK/              \u2190 Veikia teisingai\n\u2502   \u251c\u2500\u2500 stack.h\n\u2502   \u251c\u2500\u2500 stack.c\n\u2502   \u2514\u2500\u2500 user.c\n\u2514\u2500\u2500 02_OK_Attack/       \u2190 Ataka pavyksta!\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user_attack.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_5","title":"\ud83d\udccc Koncepcija","text":"<p>ENCAPSULATION - UDT modulyje, bet strukt\u016bra vie\u0161a</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#01_ok-modulinis-udt","title":"01_OK: Modulinis UDT","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_7","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>01_OK/stack.h</code> <pre><code>#define SIZE 5\n\n// \u2705 Strukt\u016bra header'yje\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nvoid init(struct Stack *s);\nint isEmpty(struct Stack *s);\nint isFull(struct Stack *s);\nvoid push(struct Stack *s, char c);\nchar pop(struct Stack *s);\n</code></pre></p> <p>Failas: <code>01_OK/stack.c</code> <pre><code>#include \"stack.h\"\n\nvoid init(struct Stack *s) {\n    s-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *s) {\n    return 0 == s-&gt;top;\n}\n\nint isFull(struct Stack *s) {\n    return SIZE == s-&gt;top;\n}\n\nvoid push(struct Stack *s, char c) {\n    if (!isFull(s)) {\n        s-&gt;stack[s-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *s) {\n    if (!isEmpty(s)) {\n        return s-&gt;stack[--s-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>01_OK/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia_4","title":"\u2705 Veikia!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#02_ok_attack-ataka-pavyksta","title":"02_OK_Attack: Ataka pavyksta!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_8","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>02_OK_Attack/user_attack.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n    struct Stack st1, st2;\n\n    printf(\"Input 1st Stack:\\n\");\n    init(&amp;st1);\n    while ((!isFull(&amp;st1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st1, c);\n\n    while (!isEmpty(&amp;st1)) \n        putchar(pop(&amp;st1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(&amp;st2);\n    while ((!isFull(&amp;st2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(&amp;st2, c);\n\n    //// \ud83d\udd25 ATAKA!\n    st2.stack[st2.top++] = '!';\n    ////\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliuojasi-ataka-pavyko_1","title":"\u2705 Kompiliuojasi! Ataka PAVYKO!","text":"<pre><code>Input 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n!7654  \u2190 '!' \u012fterptas!\n2nd Stack is empty\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_7","title":"\ud83d\udca1 Pamoka","text":"<p>Encapsulation \u2260 Information Hiding Strukt\u016bra matoma \u2192 galima modifikuoti laukus!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-07-hiding_udt_information","title":"\ud83d\ude80 ETAPAS 07: HIDING_UDT_Information","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_6","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>07_HIDING_UDT_Information/\n\u2514\u2500\u2500 01_NC[incomplete_type]/  \u2190 NC ataka!\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u251c\u2500\u2500 _user.c          \u2190 NC: incomplete type\n    \u2514\u2500\u2500 user_attack.c    \u2190 NC: bandymas atakuoti\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_6","title":"\ud83d\udccc Koncepcija","text":"<p>OPAQUE POINTER - forward declaration, incomplete type</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#01_ncincomplete_type-ataka-nepavyksta","title":"01_NC[incomplete_type]: Ataka nepavyksta!","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_9","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>01_NC/stack.h</code> <pre><code>#define SIZE 5\n\n// \u2705 INCOMPLETE TYPE - tik deklaracija!\nstruct Stack;\n\nvoid init(struct Stack *s);\nint isEmpty(struct Stack *s);\nint isFull(struct Stack *s);\nvoid push(struct Stack *s, char c);\nchar pop(struct Stack *s);\n</code></pre></p> <p>Failas: <code>01_NC/stack.c</code> <pre><code>#include \"stack.h\"\n\n// \u2705 Pilnas apibr\u0117\u017eimas TIK .c faile!\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\nvoid init(struct Stack *s) {\n    s-&gt;top = 0;\n}\n\nint isEmpty(struct Stack *s) {\n    return 0 == s-&gt;top;\n}\n\nint isFull(struct Stack *s) {\n    return SIZE == s-&gt;top;\n}\n\nvoid push(struct Stack *s, char c) {\n    if (!isFull(s)) {\n        s-&gt;stack[s-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *s) {\n    if (!isEmpty(s)) {\n        return s-&gt;stack[--s-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>01_NC/_user.c</code> (Bandymas naudoti) <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    // \u274c KLAIDA: negalima deklaruoti\n    struct Stack st1, st2;  // \u2190 NC klaida!\n\n    // ...\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#nc-kompiliavimo-klaida_1","title":"\u274c NC - Kompiliavimo klaida!","text":"<pre><code>error: storage size of 'st1' isn't known\nerror: storage size of 'st2' isn't known\nerror: variable has incomplete type 'struct Stack'\n</code></pre> <p>Failas: <code>01_NC/user_attack.c</code> (Bandymas atakuoti) <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n    struct Stack st1, st2;  // \u2190 NC!\n\n    init(&amp;st1);\n    push(&amp;st1, 'A');\n\n    //// \ud83d\udd25 BANDYMAS ATAKUOTI!\n    st2.stack[st2.top++] = '!';  // \u2190 NC!\n    ////\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimo-klaida","title":"\u274c Kompiliavimo klaida!","text":"<pre><code>error: storage size of 'st1' isn't known\nerror: storage size of 'st2' isn't known\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#ataka-nepavyko_1","title":"\u2705 ATAKA NEPAVYKO! \ud83c\udf89","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_8","title":"\ud83d\udca1 Pamoka","text":"<p>Opaque pointer = tikras information hiding Vartotojas ne\u017eino strukt\u016bros apibr\u0117\u017eimo! Forward declaration (<code>struct Stack;</code>) = incomplete type</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#problema_1","title":"\u26a0\ufe0f Problema","text":"<p>Kaip sukurti stek\u0105? <code>struct Stack st;</code> - neveikia (incomplete type)! Sprendimas: <code>create()</code> factory funkcija!</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-08-acquiring_resources","title":"\ud83d\ude80 ETAPAS 08: Acquiring_RESOURCES","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_7","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>08_Acquiring_RESOURCES/\n\u2514\u2500\u2500 02_OK/\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_7","title":"\ud83d\udccc Koncepcija","text":"<p>FACTORY PATTERN - <code>create()</code> / <code>destroy()</code> funkcijos</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#02_ok-factory-pattern","title":"02_OK: Factory Pattern","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kodas_10","title":"\ud83d\udcbb Kodas","text":"<p>Failas: <code>02_OK/stack.h</code> <pre><code>#define SIZE 5\n\nstruct Stack;  // \u2190 opaque type\n\n// \u2705 Factory funkcijos\nstruct Stack* create(void);\nvoid destroy(struct Stack *s);\n\nvoid init(struct Stack *s);\nint isEmpty(struct Stack *s);\nint isFull(struct Stack *s);\nvoid push(struct Stack *s, char c);\nchar pop(struct Stack *s);\n</code></pre></p> <p>Failas: <code>02_OK/stack.c</code> <pre><code>#include &lt;stdlib.h&gt;\n#include \"stack.h\"\n\nstruct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u2705 Factory: suk\u016brimas\nstruct Stack* create(void) {\n    struct Stack *s = (struct Stack*)malloc(sizeof(struct Stack));\n    if (s != NULL) {\n        s-&gt;top = 0;\n    }\n    return s;\n}\n\n// \u2705 Factory: sunaikinimas\nvoid destroy(struct Stack *s) {\n    free(s);\n}\n\nvoid init(struct Stack *s) {\n    if (s != NULL) {\n        s-&gt;top = 0;\n    }\n}\n\nint isEmpty(struct Stack *s) {\n    return (s != NULL) &amp;&amp; (0 == s-&gt;top);\n}\n\nint isFull(struct Stack *s) {\n    return (s != NULL) &amp;&amp; (SIZE == s-&gt;top);\n}\n\nvoid push(struct Stack *s, char c) {\n    if ((s != NULL) &amp;&amp; !isFull(s)) {\n        s-&gt;stack[s-&gt;top++] = c;\n    }\n}\n\nchar pop(struct Stack *s) {\n    if ((s != NULL) &amp;&amp; !isEmpty(s)) {\n        return s-&gt;stack[--s-&gt;top];\n    }\n    return '\\0';\n}\n</code></pre></p> <p>Failas: <code>02_OK/user.c</code> <pre><code>#include &lt;stdio.h&gt;\n#include \"stack.h\"\n\nint main(void) {\n    char c;\n\n    // \u2705 Sukuriame per factory\n    struct Stack *pst1 = create();\n    struct Stack *pst2 = create();\n\n    printf(\"Input 1st Stack:\\n\");\n    init(pst1);\n    while ((!isFull(pst1)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst1, c);\n\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n    putchar('\\n');\n    printf(\"1st Stack is empty\\n\\n\");\n\n    printf(\"Input 2nd Stack:\\n\");\n    init(pst2);\n    while ((!isFull(pst2)) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(pst2, c);\n\n    while (!isEmpty(pst2)) \n        putchar(pop(pst2));\n    putchar('\\n');\n    printf(\"2nd Stack is empty\\n\\n\");\n\n    // \u2705 Atlaisviname atmint\u012f\n    destroy(pst1);\n    destroy(pst2);\n\n    return 0;\n}\n</code></pre></p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#veikia_5","title":"\u2705 Veikia!","text":"<pre><code>Input 1st Stack:\n1234\n4321\n1st Stack is empty\n\nInput 2nd Stack:\n4567\n7654\n2nd Stack is empty\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#pamoka_9","title":"\ud83d\udca1 Pamoka","text":"<p>Factory pattern - <code>create()</code> / <code>destroy()</code> Prototipai C++ konstruktoriams/destruktoriams! Manual lifecycle management</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#etapas-09-completing_lifecycle","title":"\ud83d\ude80 ETAPAS 09: Completing_LIFECYCLE","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#katalogo-struktura_8","title":"\ud83d\udcc2 Katalogo strukt\u016bra","text":"<pre><code>09_Completing_LIFECYCLE/\n\u2514\u2500\u2500 01_OK/\n    \u251c\u2500\u2500 stack.h\n    \u251c\u2500\u2500 stack.c\n    \u2514\u2500\u2500 user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#koncepcija_8","title":"\ud83d\udccc Koncepcija","text":"<p>LIFECYCLE COMPLETION - pilnas objekto gyvavimo ciklo valdymas</p> <p>Pastaba: \u0160is etapas papildo 08 etap\u0105 su dar grie\u017etesniu lifecycle valdymu (pvz., error handling, resurs\u0173 tikrinimas, ir pan.)</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#c-dalies-isvada","title":"\ud83d\udca1 C dalies i\u0161vada","text":"<pre><code>\u2705 Pasiekta (9 etapai):\n  \u2022 Information hiding (opaque pointer)\n  \u2022 Lifecycle management (create/destroy)\n  \u2022 Multiple instances\n  \u2022 True Abstract Data Type\n  \u2022 Factory pattern\n\n\u274c Tr\u016bksta (C++ suteiks):\n  \u2022 Automatinio lifecycle (RAII)\n  \u2022 Type safety (konstruktorius/destruktorius)\n  \u2022 Operators (operatori\u0173 perkrovimas)\n  \u2022 Templates (generics)\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#apibendrinimas","title":"\ud83c\udf93 APIBENDRINIMAS","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#9-etapu-lentele","title":"9 Etap\u0173 Lentel\u0117","text":"Nr Katalogo pavadinimas Pagrindin\u0117 koncepcija Info Hiding? Lifecycle? Subdirektorijos 01 <code>Running_PROGRAM</code> Monolitas \u274c \u274c - 02 <code>Decomposing_to_UNITS</code> Fizinis padalijimas \u274c \u274c <code>02_NL</code>, <code>03_OK_Wrong</code> 03 <code>Discovering_C_MODULE</code> C modulis \u274c \u274c <code>04_OK</code>, <code>05_OK_Attack</code> 04 <code>Protecting_IMPLEMENTATION</code> <code>static</code> linkage \u2705 (bet 1 stekas) \u274c <code>01_NL_Attack</code>, <code>02_OK</code> 05 <code>Defining_USER_TYPE</code> <code>struct</code> tipas \u274c \u274c <code>01_NC</code>, <code>02_RT</code>, <code>03_OK</code> 06 <code>ENCAPSULATING_UDT_in_Module</code> Modulinis UDT \u274c \u274c <code>01_OK</code>, <code>02_OK_Attack</code> 07 <code>HIDING_UDT_Information</code> Opaque pointer \u2705 \u274c <code>01_NC[incomplete_type]</code> 08 <code>Acquiring_RESOURCES</code> Factory pattern \u2705 \u2705 (manual) <code>02_OK</code> 09 <code>Completing_LIFECYCLE</code> Lifecycle completion \u2705 \u2705 <code>01_OK</code>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#mokymosi-rezultatai","title":"\ud83c\udfaf Mokymosi rezultatai","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#c-kalboje-studentai-ismoko","title":"C kalboje studentai i\u0161moko:","text":"<ul> <li>\u2705 Moduliavim\u0105 - header (.h) + implementation (.c)</li> <li>\u2705 Information hiding - <code>static</code> internal linkage</li> <li>\u2705 User-defined types - <code>struct</code> ir rodykl\u0117s</li> <li>\u2705 Opaque pointer idiom - forward declaration</li> <li>\u2705 Factory pattern - manual resource management</li> <li>\u2705 Kompiliavimo/linkavimo klaidas - kaip \u012frankis mokymuisi</li> </ul>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#principai","title":"Principai:","text":"<ul> <li>\u2705 Encapsulation vs Information Hiding - skirtumas</li> <li>\u2705 ADT (Abstract Data Type) - tikra prasm\u0117</li> <li>\u2705 Separation of Concerns - modulinis dizainas</li> <li>\u2705 Lifecycle management - suk\u016brimas/sunaikinimas</li> </ul>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#studentu-uzduotys","title":"\ud83d\udcdd Student\u0173 u\u017eduotys","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#uzduotis-1-evoliucijos-analize","title":"U\u017eduotis 1: Evoliucijos analiz\u0117","text":"<p>Kiekvienam etapui (01-09): 1. Paai\u0161kinkite, kas pager\u0117jo lyginant su ankstesniu 2. Nurodykite, kod\u0117l ankstesnis sprendimas buvo nepakankamas 3. Parodykite kompiliavimo/linkavimo klaid\u0105 ir jos prie\u017east\u012f</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#uzduotis-2-klaidu-kategorijos","title":"U\u017eduotis 2: Klaid\u0173 kategorijos","text":"<p>Klasifikuokite subdirektorijas: - NC (Not Compiling) - kokios klaidos? - NL (Not Linking) - kod\u0117l linker nesuranda simboli\u0173? - OK_Attack - kod\u0117l ataka pavyksta?</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#uzduotis-3-savarankiskas-adt","title":"U\u017eduotis 3: Savaranki\u0161kas ADT","text":"<p>Sukurkite Queue (eil\u0119) ADT naudodami: - Etap\u0105 04: su <code>static</code> (viena eil\u0117) - Etap\u0105 07: su opaque pointer (kelios eil\u0117s) - Etap\u0105 08: su factory pattern</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#uzduotis-4-refleksija","title":"U\u017eduotis 4: Refleksija","text":"<p>\"Kod\u0117l C++ reikalingas, jei C gali pasiekti t\u0105 pat\u012f (09 etapas)?\"</p>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#kompiliavimo-instrukcijos","title":"\u2699\ufe0f Kompiliavimo instrukcijos","text":""},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#c-programos","title":"C programos","text":"<pre><code>gcc -Wall -Wextra -std=c11 -o prog stack.c user.c\n</code></pre>"},{"location":"evolution/Stack_Evolution_Guide_9_Stages_FINAL/#galutine-isvada","title":"\ud83c\udfac Galutin\u0117 i\u0161vada","text":"<p>9 etap\u0173 kelion\u0117 - nuo naivaus monolito link profesionalaus ADT. Kiekvienas \u017eingsnis i\u0161sprend\u017eia konkre\u010di\u0105 problem\u0105, vedantis link OOP princip\u0173.</p> <p>Svarbiausias takeaway: - \u2705 Suprasti KOD\u0116L, o ne tik KAIP - \u2705 C++ = C evoliucija (ne konkurentas!) - \u2705 Kompiliavimo klaidos = mokymo \u012frankis - \u2705 Atak\u0173 scenarijai = saugumo demonstracija</p> <p>V\u0117liau gr\u012f\u0161ime prie <code>typedef</code>, <code>const correctness</code>, <code>function pointers</code> C++ paskaitose! \ud83d\ude04</p> <p>S\u0117km\u0117s mokantis! \ud83d\ude80 Versija: 2026.01 (9 etapai) Licenzija: Laisvai naudojamas mokymo tikslams</p>"},{"location":"evolution/evoliucija-problemos/","title":"Konceptual\u016bs barjerai pereinant nuo C prie C++: Evoliucinio metodo sprendimai","text":""},{"location":"evolution/evoliucija-problemos/#ivadas","title":"\u012evadas","text":"<p>Per\u0117jimas nuo proced\u016brinio C programavimo prie objektinio C++ da\u017enai sukelia studentams rimt\u0173 sunkum\u0173. \u0160ie sunkumai atsiranda ne d\u0117l sintaks\u0117s sud\u0117tingumo, o d\u0117l fundamentali\u0173 m\u0105stymo paradigm\u0173 skirtum\u0173. Evoliucinis metodas sistemingai sprend\u017eia \u0161iuos barjerus, leisdamas studentams nat\u016braliai progresuoti.</p>"},{"location":"evolution/evoliucija-problemos/#1-pagrindinis-barjeras-duomenu-ir-funkciju-atskyrimas-suvienijimas","title":"1. Pagrindinis barjeras: Duomen\u0173 ir funkcij\u0173 atskyrimas \u2192 Suvienijimas","text":""},{"location":"evolution/evoliucija-problemos/#problema","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 m\u0105styti duomenimis ir funkcijomis kaip atskirais elementais:</p> <pre><code>// C m\u0105stymas: duomenys ir funkcijos atskirai\nchar stack[10];\nint top = 0;\n\nvoid push(char c) { /* ... */ }\nchar pop(void) { /* ... */ }\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas","title":"Evoliucinio metodo sprendimas","text":"<p>1-3 etapai: Palaipsnis art\u0117jimas <pre><code>// Etapas 1: Global\u016bs duomenys + funkcijos\nchar stack[10]; int top = 0;\nvoid push(char c);\n\n// Etapas 2: Modulinis dizainas (vis dar atskirai)\n// stack_2.h - funkcijos, stack_2.c - duomenys\n\n// Etapas 3: static pasl\u0117pimas (art\u0117jimas prie suvienijimo)\nstatic char stack[10]; static int top = 0;\n</code></pre></p> <p>4-5 etapai: Konceptualus \u0161uolis <pre><code>// Etapas 4: typedef struct (duomenys kartu)\ntypedef struct {\n    char stack[10];\n    int top;\n} stack;\n\n// Etapas 5: struct su metodais (suvienijimas!)\nstruct stack {\n    char stackas[10];\n    int top;\n    void push(char c);  // Metodas!\n    char pop();\n};\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#kodel-evoliucinis-metodas-veikia","title":"Kod\u0117l evoliucinis metodas veikia?","text":"<ul> <li>Nat\u016bralus progresavimas: Nuo \u017einomo (atskirai) prie ne\u017einomo (kartu)</li> <li>Motyvacija: Kiekvienas \u017eingsnis sprend\u017eia ankstesnio problemas</li> <li>Praktinis supratimas: Studentai mato, kod\u0117l reikia suvienijimo</li> </ul>"},{"location":"evolution/evoliucija-problemos/#2-atminties-valdymo-paradigmos-barjeras","title":"2. Atminties valdymo paradigmos barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_1","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 prie manual memory management, bet nesupranta objekt\u0173 lifecycle:</p> <pre><code>// C stilius: manual kontrol\u0117\nchar* data = malloc(100);\n// ... naudojimas\nfree(data);  // Reikia nepamirsti!\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_1","title":"Evoliucinio metodo sprendimas","text":"<p>6-7 etapai: RAII principas <pre><code>// Etapas 6: Konstruktorius (automatinis prad\u017eia)\nclass stack {\npublic:\n    stack() { top = 0; }  // Automatinis!\n};\n\n// Etapas 7: Konstruktorius + destruktorius (pilnas ciklas)\nclass stack {\npublic:\n    stack(int sz) { stackas = new char[sz]; }  // Gauna i\u0161teklius\n    ~stack() { delete[] stackas; }             // Atlaisvina i\u0161teklius\n};\n</code></pre></p> <p>8-9 etapai: Objekt\u0173 kopijavimo supratimas <pre><code>// Etapas 8: Rule of Three (deep copy)\nstack s1(10);\nstack s2 = s1;  // Dabar supranta, kad reikia kopijuoti duomenis!\n\n// Etapas 9: Rule of Five (move semantics)\nstack s3 = create_stack();  // Supranta, kad galima \"pavogti\"!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#pedagogine-verte","title":"Pedagogin\u0117 vert\u0117","text":"<ul> <li>Crash mokymasis: 7 etapas be Rule of Three crash'ina \u2192 motyvacija</li> <li>Vizualizacija: Shallow vs deep copy diagramos</li> <li>Performance supratimas: Move semantics 1000x grei\u010diau</li> </ul>"},{"location":"evolution/evoliucija-problemos/#3-prieigos-kontroles-encapsulation-barjeras","title":"3. Prieigos kontrol\u0117s (encapsulation) barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_2","title":"Problema","text":"<p>C programuotojai nesupranta, kod\u0117l reikia sl\u0117pti duomenis:</p> <pre><code>// C mentalitetas: \"Viskas turi b\u016bti prieinamas\"\ntypedef struct {\n    char data[10];  // Kod\u0117l negaliu tiesiogiai keisti?\n    int top;\n} stack;\n\nstack st;\nst.data[st.top++] = 'X';  // \"Tai mano duomenys!\"\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_2","title":"Evoliucinio metodo sprendimas","text":"<p>2-3 etapai: Problemos demonstracija <pre><code>// Etapas 2: Global\u016bs duomenys - problemos\nextern char stack[10];\nstack[top++] = '!';  // Pa\u017eeid\u017eia modulio logik\u0105!\n\n// Etapas 3: static apsauga\nstatic char stack[10];  // Linker klaidos moko!\n</code></pre></p> <p>5-6 etapai: C++ sprendimas <pre><code>// Etapas 5: struct metodai, bet duomenys prieinami\nstruct stack {\n    char stackas[10];  // Vis dar galima: st.stackas[0] = 'X'\n    void push(char c);\n};\n\n// Etapas 6: private/public - tikra apsauga!\nclass stack {\nprivate:\n    char stackas[10];  // Kompiliatorius neleid\u017eia!\npublic:\n    void push(char c);\n};\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#mokymosi-procesas","title":"Mokymosi procesas","text":"<ul> <li>Klaidos kaip mokytojai: Linker klaidos rodo apsaugos svarb\u0105</li> <li>Kompiliatoriaus pagalba: private klaidos motyvuoja public interface</li> <li>Praktinis supratimas: Mato, kaip apsauga padeda vengti klaid\u0173</li> </ul>"},{"location":"evolution/evoliucija-problemos/#4-objektu-koncepcijos-barjeras","title":"4. Objekt\u0173 koncepcijos barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_3","title":"Problema","text":"<p>C programuotojai m\u0105sto funkcijomis, ne objektais:</p> <pre><code>// C m\u0105stymas: \"K\u0105 daryti?\"\npush(data, 'X');\nchar c = pop(data);\nreset(data);\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_3","title":"Evoliucinio metodo sprendimas","text":"<p>4-6 etapai: Objektinio m\u0105stymo formavimas <pre><code>// Etapas 4: Objektai kaip duomen\u0173 strukt\u016bros\nstack st1, st2;  // Du objektai!\npush(&amp;st1, 'X');  // Vis dar funkcinis m\u0105stymas\n\n// Etapas 5-6: Objektai su elgesiu\nstack st1, st2;\nst1.push('X');    // Objektas daro veiksmus!\nst2.push('Y');    // Kiekvienas objektas nepriklausomas\n</code></pre></p> <p>7-10 etapai: Pilnavertis objektinis m\u0105stymas <pre><code>// Etapas 7: Objektai su lifecycle\nstack st(100);    // Objektas sukuriamas su parametrais\n// Automati\u0161kai sunaikinamas\n\n// Etapas 10: Template objektai\nStack&lt;string&gt; string_stack;  // Objektai gali b\u016bti bet kokio tipo\nStack&lt;int&gt; int_stack;\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#konceptualus-suolis","title":"Konceptualus \u0161uolis","text":"<ul> <li>Nuo \"k\u0105 daryti\" prie \"kas daro\": st.push() vs push(&amp;st)</li> <li>Objekt\u0173 nepriklausomumas: Kiekvienas objektas - atskiras pasaulis</li> <li>Lifecycle supratimas: Objektai gimsta, gyvena, mir\u0161ta</li> </ul>"},{"location":"evolution/evoliucija-problemos/#5-tipo-saugumo-barjeras","title":"5. Tipo saugumo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_4","title":"Problema","text":"<p>C programuotojai \u012fprat\u0119 prie void* ir manual casting:</p> <pre><code>// C stilius: \"A\u0161 \u017einau, k\u0105 darau\"\nvoid* data = malloc(100);\nchar* stack = (char*)data;  // Manual cast\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_4","title":"Evoliucinio metodo sprendimas","text":"<p>5-6 etapai: C++ tipo saugumas <pre><code>// Etapas 5: const vietoj #define\nconst int STACK_SIZE = 10;  // Tipo saugumas!\n\n// Etapas 6: Konstruktori\u0173 tipo tikrinimas\nstack st(10);     // Kompiliatorius tikrina tipus\nstack st2 = st;   // Tipo suderinamumas\n</code></pre></p> <p>10 etapas: Template tipo saugumas <pre><code>// Modern C++: Pilnas tipo saugumas\nStack&lt;int&gt; int_stack;\nStack&lt;string&gt; string_stack;\n\nint_stack.push(42);        // OK\nint_stack.push(\"hello\");   // Kompiliatoriaus klaida!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#pedagogine-verte_1","title":"Pedagogin\u0117 vert\u0117","text":"<ul> <li>Kompiliatoriaus pagalba: Klaidos compile time, ne runtime</li> <li>Template supratimas: Vienas kodas, daug tip\u0173</li> <li>Saugumo kult\u016bra: Kompiliatorius - draugas, ne prie\u0161as</li> </ul>"},{"location":"evolution/evoliucija-problemos/#6-performance-supratimo-barjeras","title":"6. Performance supratimo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_5","title":"Problema","text":"<p>C programuotojai mano, kad C++ l\u0117tesnis:</p> <pre><code>// C mentalitetas: \"C++ turi overhead\"\nchar stack[10];  // \"Grei\u010diausias b\u016bdas\"\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_5","title":"Evoliucinio metodo sprendimas","text":"<p>8-9 etapai: Performance demonstracija <pre><code>// Etapas 8: Rule of Three - rodo kopijavimo kain\u0105\nstack s1(1000);\nstack s2 = s1;  // Kopijuoja 1000 element\u0173!\n\n// Etapas 9: Move semantics - rodo optimizacijas\nstack s3 = create_stack();  // Tik pointer swap!\n// 1000x grei\u010diau nei kopijavimas\n</code></pre></p> <p>10 etapas: Zero-overhead abstractions <pre><code>// Modern C++: Grei\u010diau nei C!\nStack&lt;int&gt; st;\nst.push(42);  // Inline funkcija - jokio overhead!\n\n// Kompiliatorius optimizuoja geriau nei manual C kodas\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#supratimo-formavimas","title":"Supratimo formavimas","text":"<ul> <li>Matavimas: Real\u016bs benchmark'ai rodo skirtum\u0105</li> <li>Profiling: Valgrind, performance tools</li> <li>Optimizacij\u0173 supratimas: Kompiliatorius protingesnis nei \u017emogus</li> </ul>"},{"location":"evolution/evoliucija-problemos/#7-sintakses-sudetingumo-barjeras","title":"7. Sintaks\u0117s sud\u0117tingumo barjeras","text":""},{"location":"evolution/evoliucija-problemos/#problema_6","title":"Problema","text":"<p>C++ sintaks\u0117 atrodo bauginanti:</p> <pre><code>// Bauginanti sintaks\u0117\ntemplate&lt;typename T&gt;\nclass Stack {\n    Stack(const Stack&amp; other);\n    Stack&amp; operator=(Stack&amp;&amp; other) noexcept;\n};\n</code></pre>"},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-sprendimas_6","title":"Evoliucinio metodo sprendimas","text":"<p>Palaipsnis sintaks\u0117s \u012fvedimas: <pre><code>// Etapas 5: Paprasta sintaks\u0117\nstruct stack {\n    void push(char c);  // Pa\u017e\u012fstama!\n};\n\n// Etapas 6: Nauja sintaks\u0117 po truput\u012f\nclass stack {\nprivate:  // Naujas \u017eodis\n    char data[10];\npublic:   // Naujas \u017eodis\n    stack();  // Konstruktorius\n};\n\n// Etapas 8-9: Sud\u0117tingesn\u0117 sintaks\u0117 su motyvacija\nstack(const stack&amp; other);  // Dabar supranta, kod\u0117l reikia!\n</code></pre></p>"},{"location":"evolution/evoliucija-problemos/#mokymosi-strategija","title":"Mokymosi strategija","text":"<ul> <li>Vienas naujas elementas per kart\u0105: Ne viskas i\u0161 karto</li> <li>Motyvacija pirma: Kod\u0117l reikia, tada kaip</li> <li>Praktinis naudojimas: Kiekviena sintaks\u0117 turi tiksl\u0105</li> </ul>"},{"location":"evolution/evoliucija-problemos/#lyginamoji-analize-metodu","title":"Lyginamoji analiz\u0117 metod\u0173","text":"Barjeras Tradicinis OOP-first Evoliucinis metodas Rezultatas Duomen\u0173 suvienijimas \"Objektas - tai...\" (abstraktus) Global\u016bs \u2192 moduliai \u2192 struct \u2192 class \u2705 Nat\u016bralus supratimas Atminties valdymas \"Naudokite smart_ptr\" (magi\u0161kas) malloc \u2192 new/delete \u2192 RAII \u2192 Rule of 3/5 \u2705 Gil\u016bs pagrindai Encapsulation \"private - gerai, public - blogai\" Global\u016bs \u2192 static \u2192 private (su klaidomis) \u2705 Motyvuotas supratimas Objekt\u0173 koncepcija \"Objektas modeliuoja realyb\u0119\" Funkcijos \u2192 struct \u2192 metodai \u2192 objektai \u2705 Praktinis supratimas Tipo saugumas \"Templates - generinis programavimas\" void* \u2192 const \u2192 class \u2192 template \u2705 Palaipsnis augimas Performance \"C++ optimizuotas\" (tik\u0117jimas) Manual \u2192 copy \u2192 move \u2192 zero-overhead \u2705 \u012erodomas supratimas"},{"location":"evolution/evoliucija-problemos/#studentu-atsiliepimu-analize","title":"Student\u0173 atsiliepim\u0173 analiz\u0117","text":""},{"location":"evolution/evoliucija-problemos/#evoliucinio-metodo-studentai","title":"Evoliucinio metodo studentai:","text":"<p>\"Dabar suprantu, kod\u0117l reikia private - ma\u010diau, kaip global\u016bs kintamieji suk\u0117l\u0117 problemas\"</p> <p>\"Rule of Three n\u0117ra bauginantis - matau, kad tai sprend\u017eia crash'\u0173 problem\u0105\"</p> <p>\"Move semantics - tai ne magija, o paprastas pointer swap\"</p>"},{"location":"evolution/evoliucija-problemos/#tradicinio-metodo-studentai","title":"Tradicinio metodo studentai:","text":"<p>\"Ne\u017einau, kod\u0117l reikia vis\u0173 \u0161i\u0173 class, private, public...\"</p> <p>\"C++ atrodo sud\u0117tingas ir l\u0117tas\"</p> <p>\"Nesupranta, kada naudoti k\u0105\"</p>"},{"location":"evolution/evoliucija-problemos/#metodines-rekomendacijos","title":"Metodin\u0117s rekomendacijos","text":""},{"location":"evolution/evoliucija-problemos/#destytojams","title":"D\u0117stytojams:","text":"<ol> <li>Neskub\u0117kite: Leiskite studentams patirti problemas prie\u0161 duodant sprendimus</li> <li>Naudokite klaidas: Crash'ai ir linker klaidos - puik\u016bs mokytojai</li> <li>Vizualizuokite: Memory layout, shallow vs deep copy diagramos</li> <li>Matuokite: Performance benchmark'ai \u012ftikina geriau nei teorija</li> <li>Praktikuokite: Kiekviena koncepcija turi praktin\u012f projekt\u0105</li> </ol>"},{"location":"evolution/evoliucija-problemos/#studentams","title":"Studentams:","text":"<ol> <li>Nepamir\u0161kite C \u017eini\u0173: Jos - pagrindas C++ supratimui</li> <li>Eksperimentuokite: Bandykite sulau\u017eyti kod\u0105 ir suprasti kod\u0117l</li> <li>Testuokite: Valgrind, unit testai - j\u016bs\u0173 draugai</li> <li>Matuokite: Performance profiling atskleid\u017eia ties\u0105</li> <li>Kantryb\u0117: Objektinis m\u0105stymas formuojasi laipsni\u0161kai</li> </ol>"},{"location":"evolution/evoliucija-problemos/#isvados","title":"I\u0161vados","text":"<p>Evoliucinis metodas s\u0117kmingai sprend\u017eia pagrindinius konceptualius barjerus pereinant nuo C prie C++:</p>"},{"location":"evolution/evoliucija-problemos/#pagrindiniai-privalumai","title":"Pagrindiniai privalumai:","text":"<ul> <li>Nat\u016bralus progresavimas: Nuo \u017einomo prie ne\u017einomo</li> <li>Motyvuotas mokymasis: Kiekvienas \u017eingsnis sprend\u017eia reali\u0105 problem\u0105  </li> <li>Gil\u016bs pagrindai: Supranta ne tik \"kaip\", bet ir \"kod\u0117l\"</li> <li>Praktinis fokusas: Teorija i\u0161plaukia i\u0161 praktikos</li> </ul>"},{"location":"evolution/evoliucija-problemos/#ilgalaikis-poveikis","title":"Ilgalaikis poveikis:","text":"<ul> <li>Studentai geriau supranta C++ filosofij\u0105</li> <li>Ma\u017eiau baim\u0117s prie\u0161 sud\u0117tingas konstrukcijas</li> <li>Geresni debugging \u012fg\u016bd\u017eiai</li> <li>Stipresni performance optimization pagrindai</li> </ul> <p>Svarbiausias principas: Leiskite studentams patiems atrasti, kod\u0117l reikia objektinio programavimo, vietoj to, kad tiesiog pasakytum\u0117te, jog taip yra geriau.</p>"},{"location":"evolution/stack-evoliucija-test/","title":"Nuo C link C++: Metodinis vadovas su Stack ADT evoliucija","text":""},{"location":"evolution/stack-evoliucija-test/#ivadas-evoliucinis-mokymo-metodas","title":"\u012evadas: Evoliucinis mokymo metodas","text":"<p>\u0160is metodinis vadovas skirtas studentams, pereinantiems nuo C programavimo kalbos prie C++. Naudojamas evoliucinis metodas - palaipsnis kodo tobulinimas, rodantis, kaip proced\u016brinis programavimas nat\u016braliai transformuojasi \u012f objektin\u012f programavim\u0105.</p> <p>Metodikos esm\u0117: Kiekvienas \u017eingsnis sprend\u017eia ankstesn\u0117s versijos problemas ir pristato nauj\u0105 C++ koncepcij\u0105, i\u0161laikant funkcionalum\u0105, bet gerinant kodo kokyb\u0119.</p>"},{"location":"evolution/stack-evoliucija-test/#kodel-stack-stekas-kaip-pavyzdys","title":"Kod\u0117l Stack (stekas) kaip pavyzdys?","text":"<p>Stack duomen\u0173 strukt\u016bra idealiai tinka C++ mokymui, nes:</p> <ul> <li>Paprasta koncepcija: LIFO (Last In, First Out) principas</li> <li>Ai\u0161k\u016bs metodai: push(), pop(), top()</li> <li>Evoliucijos galimyb\u0117s: nuo globali\u0173 kintam\u0173j\u0173 iki \u0161iuolaikini\u0173 C++ klasi\u0173</li> <li>Praktinis pritaikymas: naudojama daugelyje algoritm\u0173</li> </ul>"},{"location":"evolution/stack-evoliucija-test/#1-etapas-stack-kaip-programa-c-stilius","title":"1 etapas: Stack kaip \"programa\" (C stilius)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija","title":"Koncepcija","text":"<p>Pirmasis etapas pristato klasikin\u012f C programavimo stili\u0173 su globaliais kintamaisiais ir funkcijomis. \u0160is metodas, nors paprastas ir intuityvus pradedantiesiems, atskleid\u017eia fundamentalias problemas, kurias spr\u0119s v\u0117lesni etapai. Global\u016bs kintamieji ir funkcij\u0173 atskyrimas nuo duomen\u0173 formuoja pagrind\u0105 supratimui, kod\u0117l reikalingas objektinis programavimas.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_1.c\n#include &lt;stdio.h&gt;\n#define STACK_SIZE 10\n\nchar stack[STACK_SIZE];  // Globalus masyvas\nint  top = 0;           // Globalus indeksas\n\nvoid push(char c);\nchar pop(void);\n\nint main(void) {\n    int c;\n\n    // \u012evedimas ir sud\u0117jimas \u012f stek\u0105\n    while ('\\n' != (c=getchar())) push(c);\n\n    // I\u0161\u0117mimas ir spausdinimas (atvirk\u0161\u010diai)\n    while ('\\n' != (c=pop())) putchar(c);\n\n    return 0;\n}\n\nvoid push(char c) {\n    if (top &lt; STACK_SIZE) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (top &gt; 0) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre> <p>Veikimo pavyzdys: - \u012evedimas: <code>12345</code> - I\u0161vedimas: <code>54321</code></p>"},{"location":"evolution/stack-evoliucija-test/#problemos-analize","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Problema Paai\u0161kinimas Pasekm\u0117s Global\u016bs kintamieji stack[] ir top prieinami visur Sunku kontroliuoti prieig\u0105 Vienas stekas Negalima sukurti keli\u0173 stek\u016f Ribota funkcionalumas N\u0117ra inkapsuliavimo Duomenys ir funkcijos atskirti Sunku palaikyti kod\u0105 N\u0117ra klaid\u0173 tikrinimo Primityvus klaid\u0173 valdymas Nesaugus kodas"},{"location":"evolution/stack-evoliucija-test/#2-etapas-stack-kaip-modulis-su-nepaslepta-realizacija","title":"2 etapas: Stack kaip \"modulis su nepasl\u0117pta realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_1","title":"Koncepcija","text":"<p>Antrasis etapas pristato modulinio programavimo prad\u017ei\u0105 - kodo skaidym\u0105 \u012f header ir implementation failus. \u0160is \u017eingsnis formuoja supratim\u0105 apie kodo organizavim\u0105 ir funkcij\u0173 deklaravim\u0105 bei apibr\u0117\u017eim\u0105. Ta\u010diau duomen\u0173 globalumas i\u0161lieka, atskleid\u017eiant modulinio dizaino ribas be tikro inkapsuliavimo.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_1","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_2.h\n#define STACK_SIZE 10\n\nvoid reset(void);\nvoid push(char);\nchar pop(void);\n\n// stack_2.c\n#include &lt;stdio.h&gt;\n#include \"stack_2.h\"\n\nchar stack[STACK_SIZE];  // Vis dar globalus\nint  top = 0;\n\nvoid reset(void) {\n    top = 0;\n}\n\nvoid push(char c) {\n    if (top &lt; STACK_SIZE) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (top &gt; 0) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#kompiliatoriaus-perspejimai","title":"\u26a0\ufe0f Kompiliatoriaus persp\u0117jimai","text":"<pre><code>Linker warning:\nPublic symbol '_stack' defined in both module DRIVER_2.OBJ and STACK_2.OBJ\nPublic symbol '_top' defined in both module DRIVER_2.OBJ and STACK_2.OBJ\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#problemos-analize_1","title":"\ud83d\udd0d Problemos analiz\u0117","text":"Pager\u0117jimas Likusios problemos \u2705 Modulinis dizainas \u274c Duomenys vis dar global\u016bs \u2705 Header failas \u274c Galima tiesiogiai keisti duomenis \u2705 reset() funkcija \u274c Simboli\u0173 dubliavimas"},{"location":"evolution/stack-evoliucija-test/#3-etapas-stack-kaip-modulis-su-paslepta-realizacija","title":"3 etapas: Stack kaip \"modulis su pasl\u0117pta realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_2","title":"Koncepcija","text":"<p>Tre\u010diasis etapas pristato informacijos sl\u0117pimo princip\u0105 naudojant <code>static</code> rakta\u017eod\u012f. \u0160is konceptualus \u0161uolis formuoja supratim\u0105 apie duomen\u0173 apsaug\u0105 ir modulio vidin\u0117s logikos pasl\u0117pim\u0105. Linker klaidos tampa mokymo \u012frankiu, demonstruojan\u010diu, kaip kompiliatorius apsaugo nuo neleistinos prieigos.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_2","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_3.h\n#define STACK_SIZE 10\n\nvoid reset(void);\nvoid push(char);\nchar pop(void);\n\n// stack_3.c\n#include &lt;stdio.h&gt;\n#include \"stack_3.h\"\n\nstatic char stack[STACK_SIZE];  // \ud83d\udd12 Pasl\u0117pta!\nstatic int  top = 0;\nstatic int is_empty(void) { return (0 == top); }\nstatic int is_full(void) { return (STACK_SIZE == top); }\n\nvoid reset(void) {\n    top = 0;\n}\n\nvoid push(char c) {\n    if (!is_full()) \n        stack[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(void) {\n    if (!is_empty()) \n        return stack[--top];\n    printf(\"\\nStekas tuscias\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#linker-klaidos","title":"\u274c Linker klaidos","text":"<pre><code>Link error: Unresolved external '_is_full' referenced from DRIVER_3.OBJ\nLink error: Unresolved external '_stack' referenced from DRIVER_3.OBJ\nLink error: Unresolved external '_top' referenced from DRIVER_3.OBJ\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize","title":"\ud83d\udd0d Analiz\u0117","text":"Pager\u0117jimas Mokymosi vert\u0117 \u2705 static - duomen\u0173 pasl\u0117pimas Informacijos sl\u0117pimo principas \u2705 Pagalbin\u0117s funkcijos pasl\u0117ptos Modulio vidin\u0117 logika \u2705 Linker klaidos rodo apsaug\u0105 Kompiliatoriaus apsauga"},{"location":"evolution/stack-evoliucija-test/#4-etapas-stack-kaip-tipas-modulyje","title":"4 etapas: Stack kaip \"tipas (modulyje)\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_3","title":"Koncepcija","text":"<p>Ketvirtasis etapas pristato duomen\u0173 strukt\u016br\u0173 koncepcij\u0105 per <code>typedef struct</code>. \u0160is \u017eingsnis formuoja supratim\u0105 apie duomen\u0173 ir funkcij\u0173 s\u0105ry\u0161\u012f, leid\u017eia kurti kelis objektus ir pristato rodykli\u0173 perdavimo b\u016btinyb\u0119. Tai tiltas tarp proced\u016brinio ir objektinio programavimo.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_3","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_4.h\n#define STACK_SIZE 10\n\ntypedef struct {\n    char stack[STACK_SIZE];\n    int  top;\n} stack;\n\nvoid reset(stack *);\nvoid push(stack *, char);\nchar pop(stack *);\n\n// stack_4.c\n#include &lt;stdio.h&gt;\n#include \"stack_4.h\"\n\nstatic int is_empty(stack *id) {\n    return (0 == id-&gt;top);\n}\n\nstatic int is_full(stack *id) {\n    return (STACK_SIZE == id-&gt;top);\n}\n\nvoid reset(stack *id) {\n    id-&gt;top = 0;\n}\n\nvoid push(stack *id, char c) {\n    if (!is_full(id)) \n        id-&gt;stack[id-&gt;top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar pop(stack *id) {\n    if (!is_empty(id)) \n        return id-&gt;stack[--id-&gt;top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_1","title":"\ud83d\udd0d Analiz\u0117","text":"Pager\u0117jimas Likusios problemos \u2705 Keli\u0173 stek\u016f galimyb\u0117 \u274c Duomenys vis dar prieinami \u2705 typedef struct \u274c Reikia perduoti rodykles \u2705 Ai\u0161kesn\u0117 sintaks\u0117 \u274c Galimi segmentation fault"},{"location":"evolution/stack-evoliucija-test/#5-etapas-stack-kaip-struktura-klase-c-pradzia","title":"5 etapas: Stack kaip \"strukt\u016bra-klas\u0117\" (C++ prad\u017eia)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_4","title":"Koncepcija","text":"<p>Penktasis etapas \u017eymi per\u0117jim\u0105 \u012f C++ - pristato <code>struct</code> su metodais ir <code>::</code> operatori\u0173. \u0160is konceptualus \u0161uolis formuoja supratim\u0105 apie duomen\u0173 ir funkcij\u0173 suvienijim\u0105 vienoje strukt\u016broje. Kompiliatoriaus klaidos atskleid\u017eia prieigos kontrol\u0117s poreik\u012f.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_4","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_5.h\nconst int STACK_SIZE = 10;\n\nstruct stack {\n    char stackas[STACK_SIZE];\n    int  top;\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n};\n\n// stack_5.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_5.h\"\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (STACK_SIZE == top); \n}\n\nvoid stack::reset() { \n    top = 0; \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_2","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Problema struct su metodais Duomenys ir funkcijos kartu :: operatorius Ai\u0161ki priklausomyb\u0117 klasei const vietoj #define Tipo saugumas Klaida su reset() Rodo, kad reikia public sekcijos!"},{"location":"evolution/stack-evoliucija-test/#6-etapas-stack-kaip-klase-informacijos-slepimas","title":"6 etapas: Stack kaip \"klas\u0117\" (Informacijos sl\u0117pimas)","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_5","title":"Koncepcija","text":"<p>\u0160e\u0161tasis etapas pristato tikr\u0105 objektin\u012f programavim\u0105 - <code>class</code> su <code>private</code> ir <code>public</code> sekcijomis bei konstruktori\u0173. \u0160is konceptualus prover\u017eis formuoja supratim\u0105 apie tikr\u0105 inkapsuliavim\u0105, automatin\u012f objekt\u0173 inicializavim\u0105 ir kompiliatoriaus apsaug\u0105 nuo neleistinos prieigos.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_5","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_6.h\nconst int STACK_SIZE = 10;\n\nclass stack {\nprivate:  // \ud83d\udd12 Pasl\u0117pta!\n    char stackas[STACK_SIZE];\n    int  top;\n    int  is_empty();\n    int  is_full();\n\npublic:   // \ud83c\udf10 Vie\u0161as interfeisas\n    stack();           // \ud83c\udf89 Konstruktorius!\n    void push(char);\n    char pop();\n};\n\n// stack_6.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_6.h\"\n\nstack::stack() { \n    top = 0; \n}\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (STACK_SIZE == top); \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_3","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Nauda private: sekcija Tikras duomen\u0173 pasl\u0117pimas public: sekcija Ai\u0161kus interfeisas Konstruktorius Automatinis inicializavimas Kompiliatoriaus apsauga Neleid\u017eia pa\u017eeisti inkapsuliavimo"},{"location":"evolution/stack-evoliucija-test/#7-etapas-stack-kaip-klase-su-dinamiska-realizacija","title":"7 etapas: Stack kaip \"klas\u0117 su dinami\u0161ka realizacija\"","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_6","title":"Koncepcija","text":"<p>Septintasis etapas pristato dinaminio atminties valdymo koncepcij\u0105 su <code>new</code>/<code>delete</code> operatoriais ir destruktoriumi. \u0160is \u017eingsnis formuoja supratim\u0105 apie RAII (Resource Acquisition Is Initialization) princip\u0105 ir automatin\u012f i\u0161tekli\u0173 valdym\u0105. Parametrinis konstruktorius leid\u017eia lanks\u010diai inicializuoti objektus.</p>"},{"location":"evolution/stack-evoliucija-test/#kodas-ir-analize_6","title":"Kodas ir analiz\u0117","text":"<pre><code>// stack_7.h\nclass stack {\nprivate:\n    char *stackas;  // \ud83c\udfaf Dinaminis masyvas!\n    int  top;\n    int  size;\n\npublic:\n    stack(int);      // \ud83c\udf89 Parametrinis konstruktorius!\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n    int  get_size();\n    ~stack();        // \ud83c\udf89 Destruktorius!\n};\n\n// stack_7.cpp\n#include &lt;stdio.h&gt;\n#include \"stack_7.h\"\n\nstack::stack(int sz) { \n    stackas = new char[size = sz]; \n    reset(); \n}\n\nvoid stack::reset() {\n    top = 0; \n}\n\nint stack::is_empty() { \n    return (0 == top); \n}\n\nint stack::is_full() { \n    return (size == top); \n}\n\nvoid stack::push(char c) {\n    if (!is_full()) \n        stackas[top++] = c;\n    else  \n        printf(\"Stekas pilnas\\n\");\n}\n\nchar stack::pop() {\n    if (!is_empty()) \n        return stackas[--top];\n    printf(\"\\nStekas tuscias\\n\");\n    return '\\n';\n}\n\nint stack::get_size() { \n    return size; \n}\n\nstack::~stack() { \n    delete [] stackas; \n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#analize_4","title":"\ud83d\udd0d Analiz\u0117","text":"C++ naujov\u0117s Nauda Parametrinis konstruktorius Lankstus inicializavimas new/delete Dinaminis atminties valdymas Destruktorius Automatinis i\u0161valymas cout vietoj printf C++ I/O srautai"},{"location":"evolution/stack-evoliucija-test/#8-etapas-rule-of-three-kopijavimo-semantika","title":"8 etapas: Rule of Three - Kopijavimo semantika","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_7","title":"Koncepcija","text":"<p>A\u0161tuntasis etapas pristato vien\u0105 svarbiausi\u0173 C++ koncepcij\u0173 - Rule of Three. \u0160is principas formuoja supratim\u0105 apie objekt\u0173 kopijavimo problemas ir deep copy b\u016btinyb\u0119. Koncepcija atskleid\u017eia, kod\u0117l dinaminio atminties valdymo atveju reikalingi special\u016bs kopijos konstruktorius ir priskyrimo operatorius.</p> <p>Rule of Three taisykl\u0117: Jei klasei reikia vieno i\u0161 trij\u0173 - destruktoriaus, kopijos konstruktoriaus ar priskyrimo operatoriaus, tai grei\u010diausiai reikia vis\u0173 trij\u0173.</p>"},{"location":"evolution/stack-evoliucija-test/#problema-su-7-etapu","title":"Problema su 7 etapu","text":"<pre><code>int main() {\n    stack s1(10);\n    s1.push('A');\n    s1.push('B');\n\n    stack s2 = s1;  // \u26a0\ufe0f Kopijos konstruktorius!\n    // arba\n    stack s3(5);\n    s3 = s1;        // \u26a0\ufe0f Priskyrimo operatorius!\n\n    return 0;       // \ud83d\udca5 CRASH! Double delete!\n}\n</code></pre> <p>Problema: Kompiliatorius automati\u0161kai sukuria \"shallow copy\" - kopijuoja tik pointer reik\u0161m\u0119, ne duomenis!</p>"},{"location":"evolution/stack-evoliucija-test/#rule-of-three-sprendimas","title":"Rule of Three sprendimas","text":"<pre><code>// stack_8.h\nclass stack {\nprivate:\n    char *stackas;\n    int  top;\n    int  size;\n\npublic:\n    stack(int);                        // Konstruktorius\n    stack(const stack&amp; other);         // \ud83c\udf89 Kopijos konstruktorius!\n    stack&amp; operator=(const stack&amp; other); // \ud83c\udf89 Priskyrimo operatorius!\n    ~stack();                          // Destruktorius\n\n    void reset();\n    void push(char);\n    char pop();\n    int  is_empty();\n    int  is_full();\n    int  get_size();\n};\n\n// Kopijos konstruktorius (deep copy)\nstack::stack(const stack&amp; other) {\n    size = other.size;\n    top = other.top;\n    stackas = new char[size];  // \ud83c\udfaf Naujas masyvas!\n\n    // Kopijuojame duomenis\n    for(int i = 0; i &lt;= top; i++) {\n        stackas[i] = other.stackas[i];\n    }\n}\n\n// Priskyrimo operatorius\nstack&amp; stack::operator=(const stack&amp; other) {\n    if(this == &amp;other) {       // \ud83d\udee1\ufe0f Apsauga nuo self-assignment\n        return *this;\n    }\n\n    delete[] stackas;          // \ud83d\uddd1\ufe0f I\u0161valome sen\u0105 atmint\u012f\n\n    size = other.size;\n    top = other.top;\n    stackas = new char[size];  // \ud83c\udfaf Naujas masyvas!\n\n    // Kopijuojame duomenis\n    for(int i = 0; i &lt;= top; i++) {\n        stackas[i] = other.stackas[i];\n    }\n\n    return *this;              // \ud83d\udd04 Gr\u0105\u017einame nuorod\u0105\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#9-etapas-rule-of-five-move-semantika","title":"9 etapas: Rule of Five - Move semantika","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_8","title":"Koncepcija","text":"<p>Devintasis etapas pristato Rule of Five ir move semantikos koncepcij\u0105 i\u0161 C++11. \u0160is \u017eingsnis formuoja supratim\u0105 apie efektyv\u0173 objekt\u0173 perk\u0117lim\u0105 vietoj kopijavimo, ypa\u010d su temporary objektais. Move semantika drasti\u0161kai pagerina performance, nes \"pavogia\" duomenis vietoj j\u0173 kopijavimo.</p> <p>Rule of Five: Rule of Three + move konstruktorius + move assignment operatorius.</p>"},{"location":"evolution/stack-evoliucija-test/#problema-su-rule-of-three","title":"Problema su Rule of Three","text":"<pre><code>stack create_temp_stack() {\n    stack temp(1000);\n    temp.push('X');\n    return temp;  // \ud83d\udcb8 Brangus kopijavimas!\n}\n\nint main() {\n    stack s1 = create_temp_stack();  // Copy constructor\n    stack s2(500);\n    s2 = create_temp_stack();        // Assignment operator\n\n    // Kiekvienas i\u0161kvietimas kopijuoja 1000 char'\u0173 masyv\u0105!\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#move-semantics-sprendimas","title":"Move semantics sprendimas","text":"<pre><code>// Rule of Five papildymai (C++11)\nstack(stack&amp;&amp; other) noexcept;     // \ud83c\udf89 Move konstruktorius!\nstack&amp; operator=(stack&amp;&amp; other) noexcept; // \ud83c\udf89 Move assignment!\n\n// Move konstruktorius - \"pavogti\" duomenis\nstack::stack(stack&amp;&amp; other) noexcept \n    : stackas(other.stackas),    // \ud83c\udfc3\u200d\u2642\ufe0f Paimame pointer\n      top(other.top),\n      size(other.size) \n{\n    // Palikti other tu\u0161\u010di\u0105 b\u016bsen\u0119\n    other.stackas = nullptr;\n    other.top = 0;\n    other.size = 0;\n}\n\n// Move assignment operator\nstack&amp; stack::operator=(stack&amp;&amp; other) noexcept {\n    if(this == &amp;other) {         // Self-assignment check\n        return *this;\n    }\n\n    // I\u0161valome savo duomenis\n    delete[] stackas;\n\n    // \"Pavogti\" other duomenis\n    stackas = other.stackas;\n    top = other.top;\n    size = other.size;\n\n    // Palikti other tu\u0161\u010di\u0105 b\u016bsen\u0119\n    other.stackas = nullptr;\n    other.top = 0;\n    other.size = 0;\n\n    return *this;\n}\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#10-etapas-modern-c-stack","title":"10 etapas: Modern C++ Stack","text":""},{"location":"evolution/stack-evoliucija-test/#koncepcija_9","title":"Koncepcija","text":"<p>De\u0161imtasis etapas pristato \u0161iuolaikin\u012f C++ stili\u0173 su templates, STL konteineriais ir C++11+ funkcijomis. \u0160is finalinis \u017eingsnis demonstruoja, kaip evoliucijos metu \u012fgytos \u017einios leid\u017eia suprasti ir efektyviai naudoti \u0161iuolaikines C++ galimybes. Template sistema leid\u017eia kurti tipo-saugius ir lank\u0161\u010dius sprendimus.</p>"},{"location":"evolution/stack-evoliucija-test/#modern-c-implementacija","title":"Modern C++ implementacija","text":"<pre><code>// modern_stack.hpp\n#pragma once\n#include &lt;vector&gt;\n#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nclass Stack {\nprivate:\n    std::vector&lt;T&gt; data;\n\npublic:\n    // Konstruktoriai\n    Stack() = default;\n    explicit Stack(size_t initial_capacity) {\n        data.reserve(initial_capacity);\n    }\n\n    // Rule of Five (C++11) - kompiliatorius automati\u0161kai\n    Stack(const Stack&amp;) = default;\n    Stack&amp; operator=(const Stack&amp;) = default;\n    Stack(Stack&amp;&amp;) = default;\n    Stack&amp; operator=(Stack&amp;&amp;) = default;\n    ~Stack() = default;\n\n    // Pagrindin\u0117s operacijos\n    void push(const T&amp; item) {\n        data.push_back(item);\n    }\n\n    void push(T&amp;&amp; item) {  // Move semantics\n        data.push_back(std::move(item));\n    }\n\n    template&lt;typename... Args&gt;\n    void emplace(Args&amp;&amp;... args) {  // Perfect forwarding\n        data.emplace_back(std::forward&lt;Args&gt;(args)...);\n    }\n\n    T pop() {\n        if (empty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        T result = std::move(data.back());\n        data.pop_back();\n        return result;\n    }\n\n    const T&amp; top() const {\n        if (empty()) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        return data.back();\n    }\n\n    // Utility funkcijos\n    [[nodiscard]] bool empty() const noexcept {\n        return data.empty();\n    }\n\n    [[nodiscard]] size_t size() const noexcept {\n        return data.size();\n    }\n\n    void clear() noexcept {\n        data.clear();\n    }\n\n    // Iterator support\n    auto begin() { return data.begin(); }\n    auto end() { return data.end(); }\n    auto begin() const { return data.cbegin(); }\n    auto end() const { return data.cend(); }\n};\n</code></pre>"},{"location":"evolution/stack-evoliucija-test/#modern-c-naujoves","title":"\ud83d\udd0d Modern C++ naujov\u0117s","text":"Funkcija C++ versija Nauda template C++98 Tipo saugumas ir lankstumas std::vector C++98 Automatinis atminties valdymas = default C++11 Ai\u0161kus intent noexcept C++11 Optimizacijos galimyb\u0117s [[nodiscard]] C++17 Persp\u0117jimai apie nepanaudotas reik\u0161mes auto C++11/14 Tipo i\u0161vedimas Range-based for C++11 Paprastesnis iteravimas Perfect forwarding C++11 Efektyvus argument\u0173 perdavimas"},{"location":"evolution/stack-evoliucija-test/#isvados","title":"I\u0161vados","text":""},{"location":"evolution/stack-evoliucija-test/#evoliucinio-metodo-privalumai","title":"Evoliucinio metodo privalumai","text":"<ol> <li>Nat\u016bralus progresavimas: Nuo paprast\u0173 prie sud\u0117ting\u0173 koncepcij\u0173</li> <li>Motyvacija: Kiekvienas \u017eingsnis sprend\u017eia reali\u0105 problem\u0105</li> <li>Praktinis mokymasis: Ta pati u\u017eduotis, skirtingi sprendimai</li> <li>Klaid\u0173 mokymasis: Klaidos tampa mokymo \u012frankiu</li> </ol>"},{"location":"evolution/stack-evoliucija-test/#pagrindines-c-koncepcijos","title":"Pagrindin\u0117s C++ koncepcijos","text":"<ul> <li>Inkapsuliavimas: private/public</li> <li>Konstruktoriai/destruktoriai: Automatinis valdymas</li> <li>Rule of Three/Five: Objekt\u0173 kopijavimo ir perk\u0117limo valdymas</li> <li>Templates: Tipo saugumas ir lankstumas</li> <li>STL: Standartin\u0117s bibliotekos</li> </ul>"},{"location":"evolution/stack-evoliucija-test/#tolesnio-mokymosi-kryptys","title":"Tolesnio mokymosi kryptys","text":"<ul> <li>Paveld\u0117jimas: class Derived : public Base</li> <li>Polimorfizmas: Virtual funkcijos</li> <li>Templates: Generinis programavimas</li> <li>STL: Konteineriai ir algoritmai</li> <li>Modern C++: Smart pointers, lambdas, ranges</li> </ul> <p>Svarbu: \u0160is vadovas - tik prad\u017eia. C++ - plati ir gili kalba, reikalaujanti nuolatinio mokymosi ir praktikos. </p>"},{"location":"evolution/stack-evolution-1/","title":"ADT Stekas Evoliucija: Nuo C iki Modernaus C++","text":""},{"location":"evolution/stack-evolution-1/#turinys","title":"Turinys","text":"<ol> <li>\u012evadas ir Evoliucijos Ap\u017evalga</li> <li>1 Etapas: Monolitin\u0117 Programa</li> <li>2 Etapas: Fail\u0173 Dekompozicija</li> <li>3 Etapas: Moduli\u0173 Sistema</li> <li>4 Etapas: Informacijos Sl\u0117pimas</li> <li>5 Etapas: Vartotojo Apibr\u0117\u017eiamas Tipas</li> <li>6 Etapas: Tipas Modulyje</li> <li>7 Etapas: Pilna Inkapsuliacija</li> <li>Tipin\u0117s Klaidos ir J\u0173 Sprendimas</li> <li>Atak\u0173 Demonstracijos</li> <li>Praktiniai Patarimai</li> <li>Santrauka ir I\u0161vados</li> </ol>"},{"location":"evolution/stack-evolution-1/#ivadas-ir-evoliucijos-apzvalga","title":"\u012evadas ir Evoliucijos Ap\u017evalga","text":""},{"location":"evolution/stack-evolution-1/#kas-yra-adt-abstract-data-type","title":"Kas yra ADT (Abstract Data Type)?","text":"<p>Abstract Data Type - tai duomen\u0173 tipas, apibr\u0117\u017eiamas per jo elges\u012f (operacijas), o ne per vidin\u0119 strukt\u016br\u0105. ADT slepia implementacijos detales ir atskleid\u017eia tik s\u0105saj\u0105 (interface).</p>"},{"location":"evolution/stack-evolution-1/#kodel-svarbu-suprasti-evoliucija","title":"Kod\u0117l Svarbu Suprasti Evoliucij\u0105?","text":"<ul> <li>Istorinis kontekstas - kaip vyst\u0117si programavimo paradigmos</li> <li>Tipin\u0117s klaidos - koki\u0173 klaid\u0173 i\u0161vengti</li> <li>Dizaino principai - kod\u0117l tam tikri sprendimai yra geresni</li> <li>Praktiniai \u012fg\u016bd\u017eiai - kaip teisingai strukt\u016brizuoti kod\u0105</li> </ul>"},{"location":"evolution/stack-evolution-1/#evoliucijos-kelias","title":"Evoliucijos Kelias","text":"<p>apie dvi dalis</p>"},{"location":"evolution/stack-evolution-1/#i-dalis-nuo-naivaus-c-iki-brandaus-c","title":"I dalis: Nuo naivaus C iki brandaus C","text":"<p>\u0160is konspektas atskleid\u017eia pirmuosius C \"epochos\" 7 evoliucijos etapus, kurie parodo, kaip paprastas stekas transformuojasi \u012f pilnai inkapsuliuot\u0105 ADT:</p> <ul> <li>01 etapas: Monolitin\u0117 Programa</li> <li>02 etapas: Fail\u0173 Dekompozicija</li> <li>03 etapas: Moduli\u0173 Sistema</li> <li>04 etapas: Informacijos Sl\u0117pimas</li> <li>05 etapas: Vartotojo Apibr\u0117\u017eiamas Tipas</li> <li>06 etapas: Tipas Modulyje</li> <li>07 etapas: Pilna Inkapsuliacija</li> </ul>"},{"location":"evolution/stack-evolution-1/#1-etapas-monolitine-programa","title":"1 Etapas: Monolitin\u0117 Programa","text":""},{"location":"evolution/stack-evolution-1/#charakteristikos","title":"Charakteristikos","text":"<ul> <li>Viskas vienoje vietoje - duomenys, funkcijos ir main() funkcija</li> <li>Global\u016bs kintamieji - <code>stack[]</code> ir <code>top</code></li> <li>Tiesioginis prieigos - joki\u0173 abstrakcij\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#kodas-01_n_usestackc","title":"Kodas: <code>01_n_usestack.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SIZE 5\n\nchar stack[SIZE];  // Globalus masyvas\nint top = 0;       // Globalus indeksas\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\nint isFull(void) {\n    return SIZE == top;\n}\n\nvoid push(char c) {\n    if (!isFull()) {\n        stack[top++] = c;\n    }\n}\n\nchar pop(void) {\n    if (!isEmpty()) {\n        return stack[--top];\n    }\n    return '\\0';\n}\n\nint main(void) {\n    char c;\n    init();\n\n    while ((c = getchar()) != '\\n') {\n        push(c);\n    }\n\n    while (!isEmpty()) {\n        putchar(pop());\n    }\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas-ir-vykdymas","title":"Kompiliavimas ir Vykdymas","text":"<pre><code>gcc 01_n_usestack.c -o 01_n_usestack\n./01_n_usestack\n# Input: 123456\n# Output: 54321\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai","title":"\u2705 Privalumai","text":"<ul> <li>Paprastumas - viskas ai\u0161kiai matoma</li> <li>Greitas prototipavimas - lengva prad\u0117ti</li> <li>Joki\u0173 sud\u0117ting\u0173 koncept\u0173 - tinka mokymosi prad\u017eiai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Nelankstumas - tik vienas stekas</li> <li>Global\u016bs kintamieji - name pollution</li> <li>Sunku testuoti - viskas susimai\u0161\u0119</li> <li>Neperkeliamas kodas - sunku panaudoti kitur</li> </ul>"},{"location":"evolution/stack-evolution-1/#kada-naudoti","title":"\ud83c\udfaf Kada Naudoti","text":"<ul> <li>Labai ma\u017ei projektai</li> <li>Greitai prototipai</li> <li>Mokymosi tikslai</li> </ul>"},{"location":"evolution/stack-evolution-1/#2-etapas-failu-dekompozicija","title":"2 Etapas: Fail\u0173 Dekompozicija","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-fizinis-kodo-skaidymas","title":"Koncepcija: Fizinis Kodo Skaidymas","text":"<p>Pirmasis bandymas atskirti stekas nuo naudotojo kodo. \u010cia susiduriame su declarations vs definitions koncepcija.</p>"},{"location":"evolution/stack-evolution-1/#21-teisingas-variantas-02_n_stackc-02_n_userc","title":"2.1 Teisingas Variantas: <code>02_n_stack.c</code> + <code>02_n_user.c</code>","text":""},{"location":"evolution/stack-evolution-1/#stekas-02_n_stackc","title":"Stekas: <code>02_n_stack.c</code>","text":"<pre><code>#define SIZE 5\n\nchar stack[SIZE];\nint top = 0;\n\nvoid init(void) {\n    top = 0;\n}\n\nint isEmpty(void) {\n    return 0 == top;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-02_n_userc","title":"Naudotojas: <code>02_n_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"02_n_stack.c\"  // \u26a0\ufe0f \u012etraukiame .c fail\u0105!\n\nint main(void) {\n    char c;\n    init();\n\n    while ((!isFull()) &amp;&amp; ('\\n' != (c = getchar()))) \n        push(c);\n\n    while (!isEmpty()) \n        putchar(pop());\n\n    putchar('\\n');\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas","title":"Kompiliavimas","text":"<pre><code>gcc 02_n_user.c -o 02_n_use_stack  # Veikia!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#22-klaidingas-variantas-02_nx_userc","title":"2.2 Klaidingas Variantas: <code>02_nx_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n// N\u0117ra joki\u0173 deklaracij\u0173!\n\nint main(void) {\n    char c;\n\n    init();        // \u274c Implicit declaration\n    // ... kitos funkcijos\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaidos","title":"Kompiliavimo Klaidos","text":"<pre><code>gcc 02_n_stack.c 02_nx_user.c -o 02_nx_use_stack\n\n# GCC Warning:\n02_nx_user.c:6:5: warning: implicit declaration of function 'init'\n\n# Clang Error:\n02_nx_user.c:6:5: error: call to undeclared function 'init'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Implicit Function Declarations - kai kompiliatorius nemato funkcijos deklaracijos, jis \"sp\u0117ja\" jos prototip\u0105. Tai pavojinga ir gali sukelti runtime klaidas!</p>"},{"location":"evolution/stack-evolution-1/#privalumai_1","title":"\u2705 Privalumai","text":"<ul> <li>Fizinis kodo atskyrimas</li> <li>Galima kompiliuoti atskirai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_1","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Vis dar global\u016bs kintamieji</li> <li>Neai\u0161ki s\u0105saja (interface)</li> <li>Include .c fail\u0173 yra blogas sprendimas</li> </ul>"},{"location":"evolution/stack-evolution-1/#3-etapas-moduliu-sistema","title":"3 Etapas: Moduli\u0173 Sistema","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-header-failai-ir-moduliai","title":"Koncepcija: Header Failai ir Moduliai","text":"<p>\u010cia \u012fvedame header failus (.h) ir mokam\u0117s declarations vs definitions skirtumo.</p>"},{"location":"evolution/stack-evolution-1/#31-klaidingas-variantas-03_nx_stackh-03_nx_stackc","title":"3.1 Klaidingas Variantas: <code>03_nx_stack.h</code> + <code>03_nx_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_nx_stackh","title":"Header: <code>03_nx_stack.h</code>","text":"<pre><code>#define SIZE 100\n\nchar stack[SIZE];  // \u274c Definition header faile!\nint top;           // \u274c Definition header faile!\n\nvoid init(void);   // \u2705 Declaration\nint isEmpty(void); // \u2705 Declaration\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 03_nx_stack.c 03_nx_user.c -o 03_nx_use_stack\n\n# Multiple definition error:\nmultiple definition of `stack'\nmultiple definition of `top'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_1","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Multiple Definition Error - kai tas pats simbolis apibr\u0117\u017eiamas keliose vietose. Header failai yra \u012ftraukiami \u012f kiekvien\u0105 .c fail\u0105, tod\u0117l definitions dubliuojasi!</p>"},{"location":"evolution/stack-evolution-1/#32-kitas-klaidingas-variantas-03_ny_stackh","title":"3.2 Kitas Klaidingas Variantas: <code>03_ny_stack.h</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_ny_stackh","title":"Header: <code>03_ny_stack.h</code>","text":"<pre><code>#define SIZE 100\n\nextern char stack[SIZE];  // \u2705 Declaration\nextern int top;           // \u2705 Declaration\n\nextern void init(void);   // \u2705 Declaration\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-03_ny_stackc","title":"Implementation: <code>03_ny_stack.c</code>","text":"<pre><code>#include \"03_ny_stack.h\"\n\n// \u274c N\u0117ra definitions!\n\nvoid init(void) {\n    top = 0;  // Naudojame neapibr\u0117\u017et\u0105 'top'\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_1","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 03_ny_stack.c 03_ny_user.c -o 03_ny_use_stack\n\n# Undefined reference error:\nundefined reference to `stack'\nundefined reference to `top'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_2","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Undefined Reference Error - <code>extern</code> sako \"\u0161is simbolis egzistuoja ka\u017ekur kitur\", bet jei jo niekur neapibr\u0117\u017eiame, linker negali jo rasti!</p>"},{"location":"evolution/stack-evolution-1/#33-teisingas-variantas-03_stackh-03_stackc","title":"3.3 Teisingas Variantas: <code>03_stack.h</code> + <code>03_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-03_stackh","title":"Header: <code>03_stack.h</code>","text":"<pre><code>// Tik declarations!\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-03_stackc","title":"Implementation: <code>03_stack.c</code>","text":"<pre><code>#include \"03_stack.h\"\n\n#define SIZE 5\n\nchar stack[SIZE];  // \u2705 Definition implementation faile\nint top;           // \u2705 Definition implementation faile\n\nvoid init(void) {\n    top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-03_userc","title":"Naudotojas: <code>03_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"03_stack.h\"  // \u2705 Tik header\n\nint main(void) {\n    char c;\n    init();\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimas_1","title":"Kompiliavimas","text":"<pre><code>gcc 03_stack.c 03_user.c -o 03_use_stack  # \u2705 Veikia!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_2","title":"\u2705 Privalumai","text":"<ul> <li>Ai\u0161ki s\u0105saja (header failas)</li> <li>Teisingas moduli\u0173 skaidymas</li> <li>Galima kompiliuoti atskirai</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_2","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Vis dar global\u016bs kintamieji</li> <li>Galimos \"atakos\" (\u017er. <code>03_z_user.c</code>)</li> </ul>"},{"location":"evolution/stack-evolution-1/#4-etapas-informacijos-slepimas","title":"4 Etapas: Informacijos Sl\u0117pimas","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-static-raktazodis","title":"Koncepcija: <code>static</code> Rakta\u017eodis","text":"<p>Naudojame <code>static</code> rakta\u017eod\u012f, kad pasl\u0117ptume implementacijos detales nuo i\u0161orinio pasaulio.</p>"},{"location":"evolution/stack-evolution-1/#kodas-04_stackc","title":"Kodas: <code>04_stack.c</code>","text":"<pre><code>#include \"04_stack.h\"\n\n#define SIZE 5\n\nstatic char stack[SIZE];    // \u2705 Internal linkage\nstatic int top;             // \u2705 Internal linkage\n\nstatic void reset(void) {   // \u2705 Private funkcija\n    top = 0;\n}\n\nvoid init(void) {           // \u2705 Public funkcija\n    top = 0;\n}\n\n// ... kitos public funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#header-04_stackh","title":"Header: <code>04_stack.h</code>","text":"<pre><code>// Tik public interface\nvoid init(void);\nint isEmpty(void);\nint isFull(void);\nvoid push(char c);\nchar pop(void);\n// N\u0117ra reset() - ji private!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_3","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Static Storage Class - <code>static</code> global\u016bs kintamieji ir funkcijos yra matomi tik tame faile, kur apibr\u0117\u017eti. Tai C kalbos information hiding mechanizmas.</p>"},{"location":"evolution/stack-evolution-1/#atakos-bandymas-04_zx_userc","title":"Atakos Bandymas: <code>04_zx_user.c</code>","text":"<pre><code>#include \"04_stack.h\"\n\nextern char stack[];     // \u274c Bandome pasiekti\nextern int top;          // \u274c Bandome pasiekti\nextern void reset(void); // \u274c Bandome pasiekti\n\nint main(void) {\n    // ...\n    stack[top++] = '!';  // \u274c Ataka nepavyko!\n    reset();             // \u274c Ataka nepavyko!\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_2","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 04_stack.c 04_zx_user.c -o 04_zx_use_stack\n\n# Undefined reference errors:\nundefined reference to `stack'\nundefined reference to `top'\nundefined reference to `reset'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_3","title":"\u2705 Privalumai","text":"<ul> <li>Information hiding - implementacija pasl\u0117pta</li> <li>Saugumas - negalima tiesiogiai keisti duomen\u0173</li> <li>Moduliarumas - ai\u0161ki public/private riba</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_3","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Tik vienas stekas - static kintamieji yra global\u016bs modulio viduje</li> <li>Negalima kurti keli\u0173 egzempliori\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#5-etapas-vartotojo-apibreziamas-tipas","title":"5 Etapas: Vartotojo Apibr\u0117\u017eiamas Tipas","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-struct-ir-keliu-egzemplioriu-galimybe","title":"Koncepcija: <code>struct</code> ir Keli\u0173 Egzempliori\u0173 Galimyb\u0117","text":"<p>\u012evedame <code>struct Stack</code> tip\u0105, kuris leid\u017eia kurti kelis stekas.</p>"},{"location":"evolution/stack-evolution-1/#51-klaidingas-variantas-05_nx_usestackc","title":"5.1 Klaidingas Variantas: <code>05_nx_usestack.c</code>","text":"<pre><code>struct Stack {\n    static char stack[SIZE];  // \u274c Negalima!\n    static int top;           // \u274c Negalima!\n};\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_3","title":"Kompiliavimo Klaida","text":"<pre><code>gcc 05_nx_usestack.c -o 05_nx_usestack\n\n# GCC:\nerror: expected specifier-qualifier-list before 'static'\n\n# Clang:\nerror: type name does not allow storage class to be specified\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_4","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Storage Class in Structs - C kalba draud\u017eia <code>static</code>, <code>extern</code>, <code>auto</code>, <code>register</code> specifikatorius strukt\u016bros nariams!</p>"},{"location":"evolution/stack-evolution-1/#52-kitas-klaidingas-variantas-05_ny_usestackc","title":"5.2 Kitas Klaidingas Variantas: <code>05_ny_usestack.c</code>","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u274c Funkcijos parametrai \"by value\"\nvoid init(struct Stack st) {\n    st.top = 0;  // Kei\u010dia tik kopij\u0105!\n}\n\nvoid push(struct Stack st, char c) {\n    if (!isFull(st)) {\n        st.stack[st.top++] = c;  // Kei\u010dia tik kopij\u0105!\n    }\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#vykdymo-rezultatas","title":"Vykdymo Rezultatas","text":"<pre><code>./05_ny_usestack\n123\n# Output: (tu\u0161\u010dia) - duomenys nepasikeit\u0117!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_5","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Pass by Value vs Pass by Reference - C kalboje strukt\u016bros perduodamos by value (kopijuojamos). Norint keisti original\u0105, reikia naudoti pointers!</p>"},{"location":"evolution/stack-evolution-1/#53-teisingas-variantas-05_n_usestackc","title":"5.3 Teisingas Variantas: <code>05_n_usestack.c</code>","text":"<pre><code>struct Stack {\n    char stack[SIZE];\n    int top;\n};\n\n// \u2705 Naudojame pointers\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\nvoid push(struct Stack *pst, char c) {\n    if (!isFull(pst)) {\n        pst-&gt;stack[pst-&gt;top++] = c;\n    }\n}\n\nint main(void) {\n    struct Stack st1, st2;  // \u2705 Du atskiri stekai!\n\n    printf(\"Ivesk st1\\n\");\n    init(&amp;st1);\n    // ... naudojame st1\n\n    printf(\"Ivesk st2\\n\");\n    init(&amp;st2);\n    // ... naudojame st2\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_4","title":"\u2705 Privalumai","text":"<ul> <li>Keli egzemplioriai - galima kurti daug stek\u0173</li> <li>Type safety - ai\u0161kus duomen\u0173 tipas</li> <li>Lokal\u016bs duomenys - kiekvienas stekas turi savo duomenis</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_4","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Atskleid\u017eiama strukt\u016bra - galimos atakos</li> <li>Reikia modulio - geriau atskirti \u012f failus</li> </ul>"},{"location":"evolution/stack-evolution-1/#6-etapas-tipas-modulyje","title":"6 Etapas: Tipas Modulyje","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-strukturos-tipas-atskirame-module","title":"Koncepcija: Strukt\u016bros Tipas Atskirame Module","text":"<p>Perkeliame <code>struct Stack</code> \u012f atskir\u0105 modul\u012f, bet strukt\u016bros nariai vis dar matomi.</p>"},{"location":"evolution/stack-evolution-1/#header-06_stackh","title":"Header: <code>06_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack {          // \u2705 Public strukt\u016bra\n    char stack[SIZE];   // \u274c Matomi nariai\n    int top;            // \u274c Matomi nariai\n};\n\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\n// ...\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-06_stackc","title":"Implementation: <code>06_stack.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nstatic void reset(struct Stack *pst) {  // \u2705 Private funkcija\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-06_userc","title":"Naudotojas: <code>06_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;\n\n    // Naudojame per interface\n    init(&amp;st1);\n    push(&amp;st1, 'A');\n\n    // Bet galime ir tiesiogiai!\n    st1.stack[st1.top++] = 'B';  // \u2705 Veikia, bet blogai!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#atakos-demonstracija-06_z_userc","title":"Atakos Demonstracija: <code>06_z_user.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st2;\n\n    init(&amp;st2);\n    push(&amp;st2, '1');\n    push(&amp;st2, '2');\n    push(&amp;st2, '3');\n\n    st2.stack[st2.top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty(&amp;st2)) \n        putchar(pop(&amp;st2));\n    // Output: !321\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_5","title":"\u2705 Privalumai","text":"<ul> <li>Modulinis dizainas</li> <li>Keli egzemplioriai</li> <li>Ai\u0161ki s\u0105saja</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_5","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Strukt\u016bros nariai matomi - galimos atakos</li> <li>N\u0117ra tikros inkapsuliacija</li> </ul>"},{"location":"evolution/stack-evolution-1/#7-etapas-pilna-inkapsuliacija","title":"7 Etapas: Pilna Inkapsuliacija","text":""},{"location":"evolution/stack-evolution-1/#koncepcija-forward-declaration-ir-opaque-pointers","title":"Koncepcija: Forward Declaration ir Opaque Pointers","text":"<p>Naudojame forward declaration ir opaque pointers, kad visi\u0161kai pasl\u0117ptume strukt\u016bros implementacij\u0105.</p>"},{"location":"evolution/stack-evolution-1/#71-klaidingi-variantai","title":"7.1 Klaidingi Variantai","text":""},{"location":"evolution/stack-evolution-1/#bandymas-1-07_nx_userc","title":"Bandymas 1: <code>07_nx_user.c</code>","text":"<pre><code>#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack st1, st2;  // \u274c Incomplete type!\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_4","title":"Kompiliavimo Klaida","text":"<pre><code># GCC:\nerror: storage size of 'st1' isn't known\n\n# Clang:\nerror: variable has incomplete type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#bandymas-2-07_ny_userc","title":"Bandymas 2: <code>07_ny_user.c</code>","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include \"07_n_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n\n    pst1 = calloc(sizeof(struct Stack), 1);  // \u274c Incomplete type!\n    // ...\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_5","title":"Kompiliavimo Klaida","text":"<pre><code>error: invalid application of 'sizeof' to incomplete type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pagrindine-pamoka_6","title":"\ud83d\udd0d Pagrindin\u0117 Pamoka","text":"<p>Incomplete Types - kai turime tik forward declaration (<code>struct Stack;</code>), negalime: - Kurti kintam\u0173j\u0173 to tipo - Naudoti <code>sizeof</code> - Pasiekti nari\u0173</p> <p>Bet galime kurti pointers \u012f t\u0105 tip\u0105!</p>"},{"location":"evolution/stack-evolution-1/#72-teisingas-variantas-07_stackh-07_stackc","title":"7.2 Teisingas Variantas: <code>07_stack.h</code> + <code>07_stack.c</code>","text":""},{"location":"evolution/stack-evolution-1/#header-07_stackh","title":"Header: <code>07_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack;  // \u2705 Forward declaration (opaque type)\n\nstruct Stack* create(void);     // \u2705 Factory funkcija\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#implementation-07_stackc","title":"Implementation: <code>07_stack.c</code>","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include \"07_stack.h\"\n\nstruct Stack {              // \u2705 Tikroji definicija (pasl\u0117pta)\n    char stack[SIZE];\n    int top;\n};\n\nstruct Stack* create(void) {\n    return (struct Stack*) calloc(sizeof(struct Stack), 1);\n}\n\nstatic void reset(struct Stack *pst) {  // \u2705 Private\n    pst-&gt;top = 0;\n}\n\nvoid init(struct Stack *pst) {\n    pst-&gt;top = 0;\n}\n\n// ... kitos funkcijos\n</code></pre>"},{"location":"evolution/stack-evolution-1/#naudotojas-07_userc","title":"Naudotojas: <code>07_user.c</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1;\n\n    pst1 = create();  // \u2705 Naudojame factory\n\n    init(pst1);\n    push(pst1, '1');\n    push(pst1, '2');\n    push(pst1, '3');\n\n    while (!isEmpty(pst1)) \n        putchar(pop(pst1));\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#atakos-bandymas-07_zx_userc","title":"Atakos Bandymas: <code>07_zx_user.c</code>","text":"<pre><code>#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst1 = create();\n\n    init(pst1);\n    push(pst1, '1');\n\n    pst1-&gt;stack[pst1-&gt;top++] = '!';  // \u274c Ataka nepavyko!\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_6","title":"Kompiliavimo Klaida","text":"<pre><code># GCC:\nerror: invalid use of undefined type 'struct Stack'\n\n# Clang:\nerror: incomplete definition of type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#73-pilnas-variantas-su-destroy-077_stackh","title":"7.3 Pilnas Variantas su <code>destroy()</code>: <code>077_stack.h</code>","text":"<pre><code>#define SIZE 5\n\nstruct Stack;\n\nstruct Stack* create(void);\nvoid destroy(struct Stack *);    // \u2705 Memory management\nvoid init(struct Stack *);\nint isEmpty(struct Stack *);\nint isFull(struct Stack *);\nvoid push(struct Stack *, char);\nchar pop(struct Stack *);\n</code></pre>"},{"location":"evolution/stack-evolution-1/#privalumai_6","title":"\u2705 Privalumai","text":"<ul> <li>Pilna inkapsuliacija - strukt\u016bra visi\u0161kai pasl\u0117pta</li> <li>Saugumas - ne\u012fmanomos atakos</li> <li>Lankstumas - galima keisti implementacij\u0105</li> <li>Memory management - kontroliuojamas objekt\u0173 gyvavimo ciklas</li> </ul>"},{"location":"evolution/stack-evolution-1/#trukumai_6","title":"\u274c Tr\u016bkumai","text":"<ul> <li>Sud\u0117tingumas - reikia factory funkcij\u0173</li> <li>Heap allocation - dinaminis atminties valdymas</li> <li>Performance overhead - pointer indirection</li> </ul>"},{"location":"evolution/stack-evolution-1/#tipines-klaidos-ir-ju-sprendimas","title":"Tipin\u0117s Klaidos ir J\u0173 Sprendimas","text":""},{"location":"evolution/stack-evolution-1/#1-implicit-function-declarations","title":"1. Implicit Function Declarations","text":""},{"location":"evolution/stack-evolution-1/#problema","title":"\u274c Problema","text":"<pre><code>// N\u0117ra #include arba deklaracijos\nint main(void) {\n    init();  // Compiler \"sp\u0117ja\" prototip\u0105\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas","title":"\u2705 Sprendimas","text":"<pre><code>#include \"stack.h\"  // Arba\nvoid init(void);    // Explicit declaration\n\nint main(void) {\n    init();  // Dabar OK\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-multiple-definition-errors","title":"2. Multiple Definition Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_1","title":"\u274c Problema","text":"<pre><code>// header.h\nint global_var = 42;  // Definition header faile!\n\n// file1.c\n#include \"header.h\"   // \u012etraukia definition\n\n// file2.c  \n#include \"header.h\"   // Dar kart\u0105 \u012ftraukia definition\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_1","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// implementation.c\nint global_var = 42;    // Definition tik vienoje vietoje\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-undefined-reference-errors","title":"3. Undefined Reference Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_2","title":"\u274c Problema","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// Bet niekur n\u0117ra definition!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_2","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nextern int global_var;  // Declaration\n\n// implementation.c\nint global_var = 42;    // Definition\n</code></pre>"},{"location":"evolution/stack-evolution-1/#4-pass-by-value-klaidos","title":"4. Pass by Value Klaidos","text":""},{"location":"evolution/stack-evolution-1/#problema_3","title":"\u274c Problema","text":"<pre><code>void modify(struct Data data) {\n    data.value = 100;  // Kei\u010dia tik kopij\u0105!\n}\n\nint main(void) {\n    struct Data d = {0};\n    modify(d);\n    printf(\"%d\\n\", d.value);  // Vis dar 0!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_3","title":"\u2705 Sprendimas","text":"<pre><code>void modify(struct Data *data) {\n    data-&gt;value = 100;  // Kei\u010dia original\u0105\n}\n\nint main(void) {\n    struct Data d = {0};\n    modify(&amp;d);\n    printf(\"%d\\n\", d.value);  // Dabar 100!\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#5-incomplete-type-errors","title":"5. Incomplete Type Errors","text":""},{"location":"evolution/stack-evolution-1/#problema_4","title":"\u274c Problema","text":"<pre><code>// header.h\nstruct Stack;  // Forward declaration\n\n// user.c\nstruct Stack st;  // Negalima - incomplete type!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#sprendimas_4","title":"\u2705 Sprendimas","text":"<pre><code>// header.h\nstruct Stack;\nstruct Stack* create(void);  // Factory funkcija\n\n// user.c\nstruct Stack *pst = create();  // Pointer OK!\n</code></pre>"},{"location":"evolution/stack-evolution-1/#ataku-demonstracijos","title":"Atak\u0173 Demonstracijos","text":""},{"location":"evolution/stack-evolution-1/#1-globaliu-kintamuju-ataka-3-etapas","title":"1. Globali\u0173 Kintam\u0173j\u0173 Ataka (3 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-kodas-03_z_userc","title":"Atakos kodas: <code>03_z_user.c</code>","text":"<pre><code>#include \"03_stack.h\"\n\nextern char stack[];  // Pasiekiame global\u0173 kintam\u0105j\u012f\nextern int top;\n\nint main(void) {\n    init();\n    push('1'); push('2'); push('3');\n\n    stack[top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty()) putchar(pop());\n    // Output: !321 (vietoj 321)\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-strukturos-nariu-ataka-6-etapas","title":"2. Strukt\u016bros Nari\u0173 Ataka (6 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-kodas-06_z_userc","title":"Atakos kodas: <code>06_z_user.c</code>","text":"<pre><code>#include \"06_stack.h\"\n\nint main(void) {\n    struct Stack st;\n\n    init(&amp;st);\n    push(&amp;st, '1'); push(&amp;st, '2'); push(&amp;st, '3');\n\n    st.stack[st.top++] = '!';  // \u2705 Ataka pavyko!\n\n    while (!isEmpty(&amp;st)) putchar(pop(&amp;st));\n    // Output: !321\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-nepavykusi-ataka-7-etapas","title":"3. Nepavykusi Ataka (7 etapas)","text":""},{"location":"evolution/stack-evolution-1/#atakos-bandymas-07_zx_userc_1","title":"Atakos bandymas: <code>07_zx_user.c</code>","text":"<pre><code>#include \"07_stack.h\"\n\nint main(void) {\n    struct Stack *pst = create();\n\n    init(pst);\n    push(pst, '1');\n\n    pst-&gt;stack[pst-&gt;top++] = '!';  // \u274c Ataka nepavyko!\n\n    return 0;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#kompiliavimo-klaida_7","title":"Kompiliavimo klaida","text":"<pre><code>error: incomplete definition of type 'struct Stack'\n</code></pre>"},{"location":"evolution/stack-evolution-1/#pamoka","title":"\ud83d\udd0d Pamoka","text":"<p>Inkapsuliacija veikia! - 7 etape strukt\u016bros implementacija yra visi\u0161kai pasl\u0117pta, tod\u0117l jokie \"hack'ai\" neveiks.</p>"},{"location":"evolution/stack-evolution-1/#praktiniai-patarimai","title":"Praktiniai Patarimai","text":""},{"location":"evolution/stack-evolution-1/#1-kompiliavimo-strategijos","title":"1. Kompiliavimo Strategijos","text":""},{"location":"evolution/stack-evolution-1/#atskirai-kompiliavimas","title":"Atskirai Kompiliavimas","text":"<pre><code># Kompiliuojame \u012f object failus\ngcc -c stack.c -o stack.o\ngcc -c user.c -o user.o\n\n# Linkuojame\ngcc stack.o user.o -o program\n</code></pre>"},{"location":"evolution/stack-evolution-1/#makefile-pavyzdys","title":"Makefile Pavyzdys","text":"<pre><code>CC = gcc\nCFLAGS = -Wall -Wextra -std=c99\n\nprogram: stack.o user.o\n    $(CC) stack.o user.o -o program\n\nstack.o: stack.c stack.h\n    $(CC) $(CFLAGS) -c stack.c\n\nuser.o: user.c stack.h\n    $(CC) $(CFLAGS) -c user.c\n\nclean:\n    rm -f *.o program\n</code></pre>"},{"location":"evolution/stack-evolution-1/#2-header-guardai","title":"2. Header Guard'ai","text":"<pre><code>#ifndef STACK_H\n#define STACK_H\n\n// Header turinys\n\n#endif /* STACK_H */\n</code></pre>"},{"location":"evolution/stack-evolution-1/#3-const-correctness","title":"3. Const Correctness","text":"<pre><code>// Funkcijos, kurios nekei\u010dia duomen\u0173\nint isEmpty(const struct Stack *pst);\nint isFull(const struct Stack *pst);\nchar peek(const struct Stack *pst);  // \u017di\u016bri be pop\n</code></pre>"},{"location":"evolution/stack-evolution-1/#4-error-handling","title":"4. Error Handling","text":"<pre><code>typedef enum {\n    STACK_OK,\n    STACK_EMPTY,\n    STACK_FULL,\n    STACK_NULL_POINTER\n} StackResult;\n\nStackResult push(struct Stack *pst, char c) {\n    if (!pst) return STACK_NULL_POINTER;\n    if (isFull(pst)) return STACK_FULL;\n\n    pst-&gt;stack[pst-&gt;top++] = c;\n    return STACK_OK;\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#5-memory-management","title":"5. Memory Management","text":"<pre><code>// Visada poruokite create/destroy\nstruct Stack *pst = create();\nif (pst) {\n    // Naudojame...\n    destroy(pst);  // Nepamir\u0161kite!\n    pst = NULL;    // Apsauga nuo dangling pointer\n}\n</code></pre>"},{"location":"evolution/stack-evolution-1/#santrauka-ir-isvados","title":"Santrauka ir I\u0161vados","text":""},{"location":"evolution/stack-evolution-1/#evoliucijos-etapu-santrauka","title":"Evoliucijos Etap\u0173 Santrauka","text":"Etapas Sprendimas Privalumai Tr\u016bkumai Saugumas 1 Monolitin\u0117 programa Paprastumas Nelankstumas \u274c Jokio 2 Fail\u0173 dekompozicija Fizinis skaidymas Global\u016bs kintamieji \u274c Jokio 3 Moduli\u0173 sistema Ai\u0161ki s\u0105saja Global\u016bs kintamieji \u274c Atakos galimos 4 Information hiding Pasl\u0117pta implementacija Tik vienas egzempliorius \u26a0\ufe0f Dalinis 5 Vartotojo tipas Keli egzemplioriai Atskleid\u017eiama strukt\u016bra \u274c Atakos galimos 6 Tipas modulyje Modulinis dizainas Matomi nariai \u274c Atakos galimos 7 Pilna inkapsuliacija Visi\u0161kas saugumas Sud\u0117tingumas \u2705 Pilnas"},{"location":"evolution/stack-evolution-1/#pagrindiniai-principai","title":"Pagrindiniai Principai","text":""},{"location":"evolution/stack-evolution-1/#1-separation-of-concerns","title":"1. Separation of Concerns","text":"<ul> <li>Atskirti interface nuo implementation</li> <li>Atskirti public nuo private</li> <li>Atskirti data nuo behavior</li> </ul>"},{"location":"evolution/stack-evolution-1/#2-information-hiding","title":"2. Information Hiding","text":"<ul> <li>Sl\u0117pti implementacijos detales</li> <li>Atskleid\u017eiami tik b\u016btini elementai</li> <li>Naudoti <code>static</code> ir opaque pointers</li> </ul>"},{"location":"evolution/stack-evolution-1/#3-type-safety","title":"3. Type Safety","text":"<ul> <li>Naudoti strukt\u016bras vietoj primityvi\u0173 tip\u0173</li> <li>Ai\u0161k\u016bs funkcij\u0173 prototipai</li> <li>Const correctness</li> </ul>"},{"location":"evolution/stack-evolution-1/#4-memory-management","title":"4. Memory Management","text":"<ul> <li>Ai\u0161kus objekt\u0173 gyvavimo ciklas</li> <li>Factory funkcijos k\u016brimui</li> <li>Destructor funkcijos sunaikinimui</li> </ul>"},{"location":"evolution/stack-evolution-1/#kada-naudoti-kuri-etapa","title":"Kada Naudoti Kur\u012f Etap\u0105?","text":""},{"location":"evolution/stack-evolution-1/#etapai-1-2-mokymasis-ir-prototipai","title":"Etapai 1-2: Mokymasis ir Prototipai","text":"<ul> <li>Greitai eksperimentai</li> <li>Labai ma\u017ei projektai</li> <li>Algoritmo testavimas</li> </ul>"},{"location":"evolution/stack-evolution-1/#etapai-3-4-mazi-projektai","title":"Etapai 3-4: Ma\u017ei Projektai","text":"<ul> <li>Vienas programuotojas</li> <li>Paprastos duomen\u0173 strukt\u016bros</li> <li>Nereikia keli\u0173 egzempliori\u0173</li> </ul>"},{"location":"evolution/stack-evolution-1/#etapai-5-6-vidutiniai-projektai","title":"Etapai 5-6: Vidutiniai Projektai","text":"<ul> <li>Reikia keli\u0173 egzempliori\u0173</li> <li>Komandinis darbas</li> <li>Modulinis dizainas</li> </ul>"},{"location":"evolution/stack-evolution-1/#7-etapas-dideli-projektai","title":"7 Etapas: Dideli Projektai","text":"<ul> <li>Bibliotek\u0173 k\u016brimas</li> <li>Maksimalus saugumas</li> <li>API dizainas</li> <li>Ilgalaikis palaikymas</li> </ul>"},{"location":"evolution/stack-evolution-1/#kelias-i-c","title":"Kelias \u012f C++","text":"<p>\u0160ie C kalbos principai tiesiogiai veda \u012f C++ koncepcijas:</p> <pre><code>// C (7 etapas)\nstruct Stack* create(void);\nvoid destroy(struct Stack*);\nvoid push(struct Stack*, char);\n\n// C++ (klas\u0117s)\nclass Stack {\npublic:\n    Stack();           // Constructor\n    ~Stack();          // Destructor\n    void push(char);   // Method\nprivate:\n    char stack[SIZE];  // Private members\n    int top;\n};\n</code></pre>"},{"location":"evolution/stack-evolution-1/#galutine-isvada","title":"\ud83c\udfaf Galutin\u0117 I\u0161vada","text":"<p>ADT evoliucija parodo, kaip programavimo kalbos ir paradigmos vyst\u0117si sprend\u017eiant realias problemas. Kiekvienas etapas atskleid\u017eia nauj\u0105 problem\u0105 ir jos sprendim\u0105, vedant\u012f link moderni\u0173 objektinio programavimo princip\u0173.</p> <p>Svarbiausias takeaway: Suprasti kod\u0117l tam tikri sprendimai yra geresni, o ne tik kaip juos implementuoti. Tai pad\u0117s jums priimti geresnius dizaino sprendimus ateityje!</p>"},{"location":"evolution/stack-evolution-1/#klausimu-ir-uzduociu-pavyzdziai","title":"Klausim\u0173 ir U\u017eduo\u010di\u0173 Pavyzd\u017eiai","text":""},{"location":"evolution/stack-evolution-1/#diskusijos-klausimai","title":"\ud83e\udd14 Diskusijos Klausimai","text":"<ol> <li>Kod\u0117l <code>static</code> kintamieji 4 etape neleid\u017eia kurti keli\u0173 stek\u0173?</li> <li>Kuo skiriasi \"declaration\" nuo \"definition\"?</li> <li>Kod\u0117l forward declaration leid\u017eia kurti pointers, bet ne variables?</li> <li>Kaip opaque pointers padeda u\u017etikrinti API stabilum\u0105?</li> </ol>"},{"location":"evolution/stack-evolution-1/#praktines-uzduotys","title":"\ud83d\udcbb Praktin\u0117s U\u017eduotys","text":"<ol> <li>Implementuokite Queue ADT naudodami 7 etap\u0105</li> <li>Sukurkite Dynamic Array su automatic resizing</li> <li>Padarykite Stack thread-safe naudodami mutex</li> <li>Implementuokite Generic Stack naudodami void pointers</li> </ol>"},{"location":"evolution/stack-evolution-1/#kodo-analizes-uzduotys","title":"\ud83d\udd0d Kodo Analiz\u0117s U\u017eduotys","text":"<ol> <li>Raskite klaidas pateiktuose kodo fragmentuose</li> <li>Paai\u0161kinkite, kod\u0117l tam tikri kompiliavimo bandymai nepavyko</li> <li>Pasi\u016blykite, kaip pagerinti duot\u0105 implementacij\u0105</li> </ol> <p>S\u0117km\u0117s mokantis! \ud83d\ude80</p>"}]}